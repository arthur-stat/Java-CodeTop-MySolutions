题目简述：

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

题目链接：[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

# 引言

本问题的四种解法大致可以分为三类：

1. 考虑每一列上至多能接多少雨水（列视角）

   - 前后缀最大值分解（动态规划）
   - 列上的相向双指针
2. 考虑对应高度的盆地内的水平铺满矩形至多能接多少雨水（行视角）

   - 单调递减栈（立刻结算盆地）

   - 单调栈 NGE / PGE
3. 其他
   - 列的横截面的相向双指针

# 前后缀最大值分解（动态规划）

## 思路

预处理数组，分别用数组 `pre` 与 `suf` 存储前缀最大值与后缀最大值。即，`pre[i]` 表示 `height[0]` 到 `height[i]` 的最大值，`suf[i]` 表示 `height[i]` 到 `height[n-1]` 的最大值，那么状态转移很容易写出来：

- `pre[i] = max(pre[i-1], heights[i])`
- `suf[i] = max(suf[i+1], heights[i])`

这样，对于第 `i` 个列，我们考虑该列能够容纳的最大雨水量。假设 `heights[i]` 大于 `pre[i-1]`，或 `heights[i]` 大于 `suf[i+1]`，那么第 `i` 列上均无法容纳任何雨水，因为他不会是任何一个盆地的内容（尽管可能是边界）；反之，根据木桶效应，则第 `i` 列可以容纳 `min(pre[i-1], suf[i+1]) - heights[i]` 格雨水。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 1) return 0;
        int[] dpPre = new int[n];
        int[] dpSuf = new int[n];
        dpPre[0] = height[0];
        dpSuf[n - 1] = height[n - 1];
        
        for (int i = 1; i < n - 1; i++) {
            dpPre[i] = Math.max(dpPre[i - 1], height[i]);
            dpSuf[n - i - 1] = Math.max(dpSuf[n - i], height[n - i - 1]);
        }

        dpPre[n - 1] = Math.max(dpPre[n - 2], height[n - 1]);
        dpSuf[0] = Math.max(dpSuf[1], height[0]);

        int rainy = 0;
        for (int i = 1; i < n - 1; i++) {
            int rain = Math.min(dpPre[i - 1], dpSuf[i + 1]) - height[i];
            if (rain > 0) {
                rainy += rain;
            }
        }

        return rainy;
    }
}
```

# 相向双指针

## 思路

这是一个非常好且简单易理解的思路。比魔幻的列上相向双指针好理解得多，浅显易懂。

移步：[双指针（理解起来比较简单的新思路，不计算每一格的雨水量，直接计算整体雨水量）](https://leetcode.cn/problems/trapping-rain-water/solutions/2206862/shuang-zhi-zhen-li-jie-qi-lai-bi-jiao-ji-bdis/)，结合文章中的图像非常直观，这里只给出代码实现。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。缺点是双指针是相向的，无法处理实时的流。

```java
class Solution {
    public int trap(int[] height) {
        if (height.length <= 1) return 0;
        int left = 0;
        int right = height.length - 1;
        int leftMax = height[left];
        int rightMax = height[right];
        int totalSquare = 0;
        int pillarSquare = 0;
        for (int h : height) pillarSquare += h;

        while (left < right) {
            if (height[left] < height[right]) {
                totalSquare += leftMax;
                leftMax = Math.max(leftMax, height[++left]);
            } else {
                totalSquare += rightMax;
                rightMax = Math.max(rightMax, height[--right]);
            }
        }

        return totalSquare - pillarSquare + height[left];
    }
}
```

## 另一个思路

一次性直接计算水面高度，逻辑更复杂些：[【视频】三种方法：前后缀分解/双指针/单调栈（Python/Java/C++/C/Go/JS/Rust）](https://leetcode.cn/problems/trapping-rain-water/solutions/1974340/zuo-liao-nbian-huan-bu-hui-yi-ge-shi-pin-ukwm/)

# 单调递减栈（立刻结算盆地）

## 思路

> 上面的那些方法相当于「竖着」计算面积，单调栈的做法相当于「横着」计算面积。
>
> 这个方法可以总结成 16 个字：**找上一个更大元素，在找的过程中填坑。**
>
> 勒贝格积分……？

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int rainy = 0;
        int[] stack = new int[n];
        int stackTop = -1;

        // 索引单调栈，栈内索引指向的元素单调递减
        for (int i = 0; i < n; i++) {

            // 出栈索引指向的元素必小于等于当前索引指向的元素，更重要的是出栈索引单调递减，但出栈索引指向的元素单调递增
            while (stackTop >= 0 && height[stack[stackTop]] <= height[i]) {
                int bottomIndex = stack[stackTop--];
                if (stackTop < 0) break;
                
                int leftIndex = stack[stackTop];
                int minHeight = Math.min(height[leftIndex], height[i]) - height[bottomIndex];
                int width = i - leftIndex - 1;
                rainy += minHeight * width;
            }
            stack[++stackTop] = i;
        }

        return rainy;
    }
}
```

# 单调栈 NGE / PGE

这个方法是我想到并写出能够 AC 代码的首个方法，但其实我现在更推荐考虑前后缀最大值分解或双指针法，因为他们的思想更直观，不涉及 “局部盆地” 这种概念，直接考虑每一列上能容纳多少雨水；或者单调递减栈立即结算盆地也比本解法更直观。

## 思路

这个问题和 [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 有一些相似之处。如果考虑该方法但对 NGE / PGE 不熟悉，建议先了解 [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)。

想到可能需要使用单调栈，因为对于一个能蓄水的列而言，其左右侧应分别存在一个比该列柱子更高的柱子，蕴含双侧 “下一个更大 / 更小元素” 的逻辑。

为方便表述，定义一个名词：盆地矩形。对于一个大的盆地，我们可以用若干个横向**铺满**的矩形恰分割该盆地，如果这样的矩形是尽可能大的，则称这些矩形为局部的盆地。

- 如果一个柱子不存在左侧的下一个更大元素或不存在右侧的下一个更大元素，那么这一层以该柱子为底形成的盆地一定接不了雨水，或者干脆不存在盆地；
- 如果一个柱子同时存在大侧的下一个更小元素与不存在右侧的下一个更大元素，那么这一层以该柱子为底形成的盆地可以接住雨水，且层宽——以当前层位底的局部盆地底长恰为右侧下一个更大元素到左侧下一个更大元素之间的元素数量。根据木桶理论，局部盆地能接住的水取决于两端最小的元素，因此取两端元素最小值减去当前柱子高度得到局部盆地的深度，再乘此前的数量，便是该局部盆地能接住的雨水量。

最后遍历每一个元素，把每个元素为底形成的局部盆地可以接住雨水量相加，就是我们一共能接住的最多雨水量。

<u>可以看出，这种 “局部盆地” 的思想虽然扫描是逐列进行的，但计算水量时是按局部盆地容积累加的，即同时考虑按行与列，按局部盆地大小进行水量的计算。这一实践与下文的前后缀最大值分解、双指针法都有本质不同，后者们水量的计算上也是逐列进行的。</u>

虽然的确这样最后能算出正确结果，但更多是出于我的一种直觉。可能需要进一步的严格证明。

## 代码

在 [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 中，为了寻找两侧的下一个更小元素（本问题则是计算两侧的下一个更大元素，但无任何本质区别），我们先给出了两次单调栈扫描的方案，随后给出了优化后的一次单调栈扫描方案。

两次单调栈的方案是一次扫描中只实现寻找某一侧的下一个更大 / 更小元素，进行两次扫描后即得到两侧的下一个更大 / 更小元素，这是只利用了 “出栈” 的信息。事实上，同时利用上 “留在栈内” 的信息，可以在一次扫描中同时获得两侧的下一个更大 / 更小元素。这里就直接给出最优实现，如果需要更基础的两次扫描实现，请参考我在 [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 题解中给出的实现。

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int rainy = 0;
        int[][] tmp = scan(height);
        int[] lastGter = tmp[0];
        int[] nextGter = tmp[1];

        for (int i = 0; i < n; i++) {
            if (lastGter[i] != -1 && nextGter[i] != 0) {
                rainy += (nextGter[i] - lastGter[i] - 1) * (Math.min(height[nextGter[i]], height[lastGter[i]]) - height[i]);
            }
        }

        return rainy;
    }

    private int[][] scan(int[] nums) {
        int n = nums.length;
        int[] lastGter = new int[n];
        int[] nextGter = new int[n];
        int[] stack = new int[n];
        int stackTop = -1;

        for (int i = 0; i < n; i++) {
            while (stackTop >= 0 && nums[stack[stackTop]] < nums[i]) {
                nextGter[stack[stackTop--]] = i;
            }
            lastGter[i] = stackTop >= 0 && nums[stack[stackTop]] > nums[i] ? stack[stackTop] : -1;
            stack[++stackTop] = i;
        }

        return new int[][]{lastGter, nextGter};
    }
}
```
