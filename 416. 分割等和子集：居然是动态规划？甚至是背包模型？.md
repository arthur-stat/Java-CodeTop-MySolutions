题目简述：

> 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

题目链接：[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

# 思路

初见时让我很震惊，看上去似乎是一个典型的 DFS 问题，或许可以考虑回溯算法，但居然是动态规划？据说暴力搜索无论如何也会超时。但可以考虑记忆化搜索。

如果不深入分析，只看题干，我无论如何也不会想到这是个动态规划问题，甚至还是 0-1 背包模型。

---

仔细回顾 0-1 背包模型，发现与本问题的确有许多共同之处。本问题可以转化为：***能否找到一个子集，使得该子集内数字的总和等于全部数字总和的一半***。注意全部数字总和我们是事先能直接计算的，因此这是一个定值。***对于 `nums[i]`，都是 “选与不选” 的问题。如果选 `nums[i]`，就将其纳入目标子集；如果不选 `nums[i]`，事实上是将其纳入另一个子集，但我们视为不纳入目标子集***。这样的话，本问题就完全符合 0-1 背包模型了。

---

定义 $dp[i][j]$ 表示 `nums[0]` 至 `nums[i]` 能否组合成数字总和为 $j$ 的子集，则
$$
dp[i][j]=\left\{\begin{align}&dp\big[i-1\big]\big[j-\mathrm{nums}[i]\big],&&\text{pick }\mathrm{nums}[i]\\\\&dp[i-1][j],&&\text{do not pick }\mathrm{nums}[i]\end{align}\right.
$$
即
$$
dp[i][j]=dp\big[i-1\big]\big[j-\mathrm{nums}[i]\big]\lor dp[i-1][j]
$$
上式的前提是 $j-\mathrm{nums}[i]\geqslant0$，否则取 $dp[i][j]=dp[i-1][j]$。按状态的语义对 $dp[0][\ast]$ 进行初始化赋值即可。

如果 $\exists k\ \text{ s.t. }\ dp[k][\frac{\mathrm{sum}}2]=\mathrm{true}$，则问题的解为 `true`，否则为 `false`。

# 代码

算法的时间复杂度为 $O(n^2)$，考虑滚动数组优化空间开销，空间复杂度为 $O(n)$。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        int n = nums.length;
        for (int i = 0; i < n; i++) sum += nums[i];
        if ((sum & 1) == 1) return false;
        int target = sum / 2;

        boolean[] dp1 = new boolean[target + 1];
        boolean[] dp2 = new boolean[target + 1];

        // init i = 0
        dp1[0] = true;
        if (nums[0] <= target) dp1[nums[0]] = true;
        if (dp1[target]) return true;

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= target; j++) {
                dp2[j] = j - nums[i] >= 0 ? dp1[j - nums[i]] : false;
                dp2[j] = dp2[j] || dp1[j];
            }
            if (dp2[target]) return true;
            boolean[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
        }

        return false;
    }
}
```

