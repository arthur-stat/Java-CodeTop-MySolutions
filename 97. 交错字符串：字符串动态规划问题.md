题目简述：

> 给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。
>
> 两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：
>
> - `s = s1 + s2 + ... + sn`
> - `t = t1 + t2 + ... + tm`
> - `|n - m| <= 1`
> - **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`
>
> **注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。
>
> **进阶：**您能否仅使用 `O(s2.length)` 额外的内存空间来解决它?

题目链接：[97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

# 思路

一开始好一会都没反应过来，只想着双指针 + DFS，又总感觉时间复杂度太高，太麻烦。

看了题目的标签提示，发现居然是动态规划……嗯，<u>大部分动态规划问题最难的一步就是你要意识到这是一个动态规划问题</u>。

既然明确了这是一个动态规划问题，那是这问题就是手拿把掐了，同时也终于理解了 “您能否仅使用 `O(s2.length)` 额外的内存空间来解决它?”——显然就是滚动数组嘛。

直接进行一整个定义，设 $dp[i][j]$ 表示 `s3[0]` 至 `s3[i+j]` 的子串是否由 `s1[0]` 至 `s1[i]` 的子串以及 `s2[0]` 至 `s2[j]` 的子串交错组成，那么
$$
dp[i][j]=\left\{\begin{align}&\mathrm{true},&&dp[i][j-1]=\mathrm{true},\ \ s3[i+j]=s2[j]\\\\&\mathrm{true},&&dp[i-1][j]=\mathrm{true},\ \ s3[i+j]=s1[i]\\\\&\mathrm{false},&&\text{Otherwise}\end{align}\right.
$$
为简化处理边界情况，考虑 1-based 索引，$dp[0][0]$ 定义为 $\mathrm{true}$，表示三个子串均为空串。

最终 $dp$ 矩阵的最后一个主对角元即为问题的解。

# 代码

采用滚动数组优化空间开销，算法的时间复杂度为 $O(mn)$，空间复杂度为 $O(n)$。

```java
class Solution {

    public boolean isInterleave(String s1, String s2, String s3) {
        if (!checkValidLength(s1, s2, s3)) return false;

        int m = s1.length();
        int n = s2.length();

        boolean[] dp1 = new boolean[n + 1];
        boolean[] dp2 = new boolean[n + 1];

        // init
        dp1[0] = true;
        for (int j = 1; j <= n; j++) {
            if (s2.charAt(j - 1) == s3.charAt(j - 1) ) {
                dp1[j] = true;
            } else {
                break;
            }
        }

        for (int i = 1; i <= m; i++) {
            dp2[0] = dp1[0] && s1.charAt(i - 1) == s3.charAt(i - 1);

            for (int j = 1; j <= n; j++) {
                if (dp2[j - 1] && s3.charAt(i + j - 1) == s2.charAt(j - 1)) {
                    dp2[j] = true;
                } else if (dp1[j] && s3.charAt(i + j - 1) == s1.charAt(i - 1)) {
                    dp2[j] = true;
                } else {
                    dp2[j] = false;
                }
            }

            boolean[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
        }

        return dp1[n];
    }

    private boolean checkValidLength(String s1, String s2, String s3) {
        if (s1.isEmpty()) return s2.equals(s3);
        if (s2.isEmpty()) return s1.equals(s3);
        return s1.length() + s2.length() == s3.length();
    }
}
```

