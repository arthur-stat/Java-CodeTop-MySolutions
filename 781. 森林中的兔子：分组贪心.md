题目简述：

> 森林中有未知数量的兔子。提问其中若干只兔子 **"还有多少只兔子与你（指被提问的兔子）颜色相同?"** ，将答案收集到一个整数数组 `answers` 中，其中 `answers[i]` 是第 `i` 只兔子的回答。
>
> 给你数组 `answers` ，返回森林中兔子的最少数量。

题目链接：[781. 森林中的兔子](https://leetcode.cn/problems/rabbits-in-forest/)

# 思路

我们尽可能地使兔子们被划分为同一类。首先要明确下面三个正确的直觉：

1. 要让森林中的兔子最小化，那么就应该让每种颜色的兔子数量最大化。相反地，如果我们认为每只回答的兔子都是唯一的一种颜色，即最小化每种颜色的兔子数量，此时森林中就有最多的兔子。

2. 如果两只兔子回答的与自己颜色相同的其他兔子数量 $a,b$ 不同，即 $a\neq b$，那么两只兔子的颜色一定不同；换句话说，如果两只兔子的颜色相同，那么他们的回答必然是相同的。

3. 如果两只兔子的回答是相同的，那么我们可以知道他们的颜色有可能是相同的，但此时我们还不能下定论。例如，假设两只兔子的回答都是 $1$，那么他们的确有可能具有相同颜色，如果此时不存在其他兔子的回答，我们就可以说森林里至少有两只兔子，并且他们都是同一种颜色。

   可是，如果现在有三只兔子的回答都是 $1$，显然现在森林里的兔子就至少具有两种颜色了，其中一种颜色对应一只兔子，另一种颜色对应两只兔子。

综上，我们可以在遍历 `answers` 的同时统计兔子们回答的数值的频次。假设一只兔子的回答是 $x$，而 $x$ 已经在此前兔子们的回答中出现了 $x$ 次，那么我们可以贪心地认为这 $x+1$ 只兔子——即此前回答 $x$ 的兔子们以及当前的兔子同属一种颜色，并且该颜色不可能再有别的兔子了，否则与 $x$ 的语义 “其他相同颜色兔子的数量” 相左，产生矛盾。所以，如果以后还有兔子也回答 $x$，我们不会再将未来的兔子归到当前颜色中，因为当前颜色已经 “盖棺定论” 了，我们已经贪心地尽可能使更多的兔子属于这一颜色了，当前颜色下无法再容纳更多的兔子了，故对于以后回答 $x$ 的兔子，我们应将其视为一种新的颜色。

在实际的编程实现中，我们可以用哈希表统计值 $x$ 到该值对应的频数。如果遍历 `answers` 到其中一只兔子的回答时，$x$ 的频数 $freq$ 小于 $x+1$，则我们可以 “安全地” 认为这 $freq$ 只兔子属于同一种颜色。但如果 $freq$ 等于 $x+1$，此时该颜色无法再容纳更多的兔子，我们需要结算该颜色并对未来再回答 $x$ 的兔子考虑新的颜色，因此我们将现有的 $freq$ 只兔子直接加入到累计的兔子数量中，并从哈希表中移除 $x$ 的 key 以表示结算一个颜色、开始记录一种新的颜色。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int numRabbits(int[] answers) {
        Map<Integer, Integer> map = new HashMap<>();
        int over = 0;  // 已被确定、能够盖棺定论的一种颜色的兔子数量
        for (int answer : answers) {
            int sta = map.merge(answer, 1, Integer::sum);
            if (answer + 1 == sta) {
                over += sta;
                map.remove(answer);
            }
        }

        for (var entry : map.entrySet()) {
            over += entry.getKey() + 1;
        }

        return over;
    }
}
```

