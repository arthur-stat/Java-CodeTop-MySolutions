题目简述：

> 给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。
>
> 按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：
>
> 1. `"123"`
> 2. `"132"`
> 3. `"213"`
> 4. `"231"`
> 5. `"312"`
> 6. `"321"`
>
> 给定 `n` 和 `k`，返回第 `k` 个排列。
>
> **提示：**
>
> - `1 <= n <= 9`
> - `1 <= k <= n!`

题目链接：[60. 排列序列](https://leetcode.cn/problems/permutation-sequence/)

# 笨办法

## 思路

回溯算法找出全部排列，然后返回第 `k` 个排列。

显然针对本问题这是效率很差的办法，但你就说 `n` 不算很大时能不能用吧。

## 代码

`n <= 9` 的数据范围下 AC 时花费了 1081ms，效率低下。

```java
class Solution {

    private boolean[] used;
    private String[] permutations;
    private char[] path;
    private int count;
    private int n;

    public String getPermutation(int n, int k) {
        used = new boolean[n + 1];
        permutations = new String[factorial(n)];
        path = new char[n];
        count = 0;
        this.n = n;
        dfs(0);
        Arrays.sort(permutations);
        return permutations[k - 1];
    }

    private void dfs(int i) {
        if (i == n) {
            permutations[count++] = new String(path);
        }

        for (int d = 1; d <= n; d++) {
            if (!used[d]) {
                used[d] = true;
                path[i] = (char) (d + '0');
                dfs(i + 1);
                used[d] = false;
            }
        }
    }

    private int factorial(int n) {
        int res = n;
        while (n > 1) {
            n--;
            res *= n;
        }
        return res;
    }
}
```

# Factorial Number System

## 思路

找出全部排列的办法当然过于笨重了，效率低下。我们应该尽可能减少不必要的搜索。

假设我们现在还有 $m$ 个未使用的数字，那么取走其中一个数字，剩下的数字便拥有 $(m-1)!$ 种排列。因此，如果我们取走 $m$ 个未使用的数字中最小的一个数字，那么余下的 $m-1$ 个数字中每次选择既可以取最小的数字，也可以每次选择最大最大的数字，分别对应字典序下确界 $1$ 与字典序上确界 $(m-1)!$。

如果我们取走的是第二小的数字，那么余下的 $m-1$ 个数字中每次选择既可以取最小的数字，也可以每次选择最大最大的数字，分别对应字典序下确界 $1\times(m-1)!+1$ 与字典序上确界 $2\times(m-1)!$。

以此类推，在 $m$ 个未使用的数字中我们取走第 $a$ 小的数字，那么剩余数字的排列字典序序下确界为 $(a-1)\times(m-1)!+1$，上确界为 $a\times(m-1)!$。

因此，确定了选择哪一个数字后，我们可以累积 $(a-1)\times(m-1)!$ 种排列字典序，而对于剩下的 $m-1$ 数字则继续考虑应选择哪一个数字，于是问题转换为了子问题。

综上，既然 $k$ 是确定的，那么我们就可以根据 $k$ 结合字典序上下确界以确定每一次应选择哪一个数字。

这种方案有个专门称呼，叫做阶乘进制系统（Factorial Number System），因为每一步的累积可以被视为在用阶乘作为基数表示一个数。但我觉得，本问题其实就从累积排列数的角度看，就已经足够自然了，没必要引入更多术语。

根据排列顺序寻找排列的过程被称为逆康拓展开。如果是反过来对于给定排列计算其排列顺序，则这一过程被称为康拓排序。

## 代码

在 `n <= 9` 的数据范围下，可以认为算法几乎没有开销。

算法的理论时间复杂度为 $O(n^2)$。

```java
class Solution {

    private static final int[] FACTORIAL = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};

    public String getPermutation(int n, int k) {
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= n; i++) numbers.add(i);
        StringBuilder res = new StringBuilder();

        int accumulate = 0;
        for (int i = 0; i < n; i++) {
            accumulate = build(res, numbers, accumulate, k);
        }

        return res.toString();
    }

    public int build(StringBuilder res, List<Integer> numbers, int accumulate, int k) {
        int m = numbers.size();
        int newaccumulate = -1;

        for (int i = 1; i <= m; i++) {
            if (k <= accumulate + i * FACTORIAL[m - 1]) {
                res.append(numbers.remove(i - 1));
                newaccumulate = accumulate + (i - 1) * FACTORIAL[m - 1] ;
                break;
            }
        }

        return newaccumulate;
    }
}
```