题目简述：

> 定一个字符串，找出最长子串$T$的长度，它最多包含`2`个不同的字符。

题目链接：[928 · 最多有两个不同字符的最长子串](https://www.lintcode.com/problem/928/)

# 思路

显然滑动窗口嘛，与下面的几个问题的解决方案是同一种思想：

- [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- [386 · 最多有k个不同字符的最长子字符串](https://www.lintcode.com/problem/386/)
- [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

原理简而言之就是，我们保证以滑动窗口的右端点为子串结束位置时，让滑动窗口的左端点尽可能向左延展，那么就可以得到以该点作为滑动窗口右端点的至多包含 $2$ 个不同字符的最长子串——如果超过 $2$ 个就收缩左端点直到不重复字符数再次等于 $2$ 个。当我们遍历每一个点考虑其作为滑动窗口右端点后，就可以得到全局最长的至多包含 $2$ 个不同字符的最长子串。

这种情况下，左右端点均是单调递增的，而且是右端点先行更新、左端点随之原地不动或再自增的，此处具有单调性，这就是本问题滑动窗口的核心。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    /**
     * @param s: a string
     * @return: the length of the longest substring T that contains at most 2 distinct characters
     */
    public int lengthOfLongestSubstringTwoDistinct(String s) {
        int[] freq = new int['z' - '0' + 1];
        int diff = 0;
        int res = 0;
        int l = 0;

        for (int r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            freq[c - '0']++;

            if (freq[c - '0'] == 1) {
                diff++;
                if (diff > 2) {
                    while (true) {
                        char cc = s.charAt(l);
                        freq[cc - '0']--;
                        l++;
                        if (freq[cc - '0'] == 0) break;
                    }
                    diff = 2;
                }
            }

            res = Math.max(res, r - l + 1);
        }
        
        return res;
    }
}
```