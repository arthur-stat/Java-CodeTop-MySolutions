题目简述：

> 给你一个整数数组 `nums` 和一个整数 `k` ，如果 `nums` 有一个 **好的子数组** 返回 `true` ，否则返回 `false`：
>
> 一个 **好的子数组** 是：
>
> - 长度 **至少为 2** ，且
> - 子数组元素总和为 `k` 的倍数。
>
> **注意**：
>
> - **子数组** 是数组中 **连续** 的部分。
> - 如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` **始终** 视为 `k` 的一个倍数。
>
> **提示：**
>
> - `1 <= nums.length <= 10^5`
> - `0 <= nums[i] <= 10^9`
> - `0 <= sum(nums[i]) <= 2^31 - 1`
> - `1 <= k <= 2^31 - 1`

题目链接：[523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)

# 思路

对于这个问题，我首先看了数据范围，发现 $O(n^2)$ 的时间复杂度极大概率会超时，但 $O(n\log n)$ 不会，这让我想到 binary indexed tree。但考虑到力扣的题目一般并不需要——至少并不必要高级数据结构，因为这些问题通常都是开发职位面试时会考察的题目，所以我猜测，或许可以利用别的条件与问题的特性，实现 $O(n)$ 的复杂度。

我再次查看数据范围，发现元素均非负，但该条件似乎意义不大。随即，我又想到可以把前缀和数组做反向的哈希表映射，让对 $k$ 取模后的前缀和的值作为 key 映射到索引，取索引为 value。而且，对于重复的 key，value 只取首个扫描到的索引。

然后，问题就变为了类似 “两数之和” 的问题。遍历对 $k$ 取模后的前缀和数组，考虑 `prefix[i]`，找哈希表中是否存在这样一个索引 `j`：`j` 小于等于 `i - 1`，并且使得 `(prefix[i] - prefix[j]) % k == 0`。如果是，那么我们就找到一个 “好的子数组”。

这样实现的算法时间复杂度就是 $O(n)$ 了，效率很高。 

总结：（取模后的）前缀和数组 + 哈希表

题目规定元素均非负，应该是为了避免类 C 语言中 `%` 的行为与数论中的模运算针对负数情况的行为不一致而带来的小麻烦。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

由于 `k` 是已知的，因此 `HashSet` 可以被进一步替换为 `int[]`，算法的性能更高。

此外，三次扫描也可以合并为一次：可以在一次扫描中既构建前缀和数组、又构建哈希表，还能判断是否已经存在连续子数组和。下面的实现依然进行了三次扫描，按照我最初的思路一比一实现。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int n = nums.length;
        int[] prefix = new int[n];
        prefix[0] = nums[0] % k;
        for (int i = 1; i < n; i++) {
            long tmp = prefix[i - 1] + nums[i];
            prefix[i] = (int) (tmp % k);
            if (prefix[i] == 0) return true;
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            map.putIfAbsent(prefix[i], i);
        }

        for (int i = 1; i < n; i++) {
            if (i - map.getOrDefault(prefix[i], i) >= 2) {
                return true;
            }
        }

        return false;
    }
}
```

