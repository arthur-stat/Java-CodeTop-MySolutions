题目简述：

> 给你一个整数 `n` ，请你在无限的整数序列 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]` 中找出并返回第 `n` 位上的数字。

题目链接：[400. 第 N 位数字](https://leetcode.cn/problems/nth-digit/)

# O(n) 枚举方案

## 思路

这是最原始的思路，即直接从 1 开始逐个数字枚举，直到计数器变量 `count` 的值等于 `n`。算法的时间复杂度为 $O(n)$。

这样的代码实现在逻辑上正确，可测试时会超时。需要进行一些优化。

## 代码

```java
class Solution {

    private static final int[] exp10 = {
        1, 10, 100, 1000, 10000,
        100000, 1000000, 10000000, 100000000, 1000000000
    };

    public int findNthDigit(int n) {
        int num = 0;
        int count = 0;

        while (true) {
            num++;
            count += getWidth(num);

            if (count >= n) {
                count -= getWidth(num);

                while (true) {
                    int high = num / getPow10(getWidth(num) - 1);
                    count++;
                    if (count == n) return high;
                    num -= high * getPow10(getWidth(num) - 1);
                }
            }
        }
    }

    // num 应为 32 位有符号正整数
    private int getWidth(int num) {
        if (num < 10) {
            return 1;
        } else if (num < 100) {
            return 2;
        } else if (num < 1000) {
            return 3;
        } else if (num < 10000) {
            return 4;
        } else if (num < 100000) {
            return 5;
        } else if (num < 1000000) {
            return 6;
        } else if (num < 10000000) {
            return 7;
        } else if (num < 100000000) {
            return 8;
        } else if (num < 1000000000) {
            return 9;
        } else {
            return 10;
        }
    }

    // exp 范围为 [0, 9]
    private int getPow10(int exp) {
        return exp10[exp];
    }
}
```

# O(log n) 改进方案

## 思路

上面的方案在理论上是正确的，我们的目的是进行优化。

实际上，$[10^k,\ 10^{k+1}-1]$ 范围内的整数一共有多少位（即对 `count` 的贡献）我们是事先可直接算出的，对于$[10^k,\ 10^{k-1}-1]$ 范围内的整数来说，他们的位数 $\mathrm{totalWidth}$ 为
$$
\mathrm{totalWidth}(10^k,\ 10^{k+1}-1)=\underbrace{(10^{k+1}-10^k)}_{\text{amount}}\times\underbrace{(k+1)}_{\text{width}}
$$
因此我们可以计算出（这一步可以定义一个函数事先计算结果并硬编码，也可以写在方法初始化步骤中再进行判断）：

- $[0,9]$ 共占 $9$ 位
- $[10,99]$ 共占 $180$ 位
- $[100,999]$ 共占 $2700$ 位
- $[1000,9999]$ 共占 $36000$ 位
- $[10000,99999]$ 共占 $450000$ 位
- $[100000,999999]$ 共占 $5400000$ 位
- $[1000000,9999999]$ 共占 $63000000$ 位
- $[10000000,99999999]$ 共占 $720000000$ 位
- $[100000000,999999999]$ 共占 $8100000000$ 位
- $[1000000000,9999999999]$ 共占 $90000000000$ 位，但 $90000000000$ 溢出，因此实际区间为 $[1000000000,4294967295]$，即 $[1000000000,2^{32}-1]$

将这些结果逐级累加，边得到

- $[0,9]$ 共占 $9$ 位
- $[0,99]$ 共占 $189$ 位
- $[0,999]$ 共占 $2889$ 位
- $[0,9999]$ 共占 $38889$ 位
- $[0,99999]$ 共占 $488889$ 位
- $[0,999999]$ 共占 $5888889$ 位
- $[0,9999999]$ 共占 $68888889$ 位
- $[0,99999999]$ 共占 $788888889$ 位
- $[0,999999999]$ 共占 $8888888889$ 位，但 $8888888889$ 溢出

这样，我们根据输入的 `n` 便能直接判断 $k$ 以确认可以从 $10^k$ 开始遍历——而不必一律从 1 开始。

---

但这只是小优化，仅仅这样子是不足够的，因为算法时间复杂度依然为 $O(n)$——只不过常数因子更小且划分出了区间。我们需要利用已划分的区间继续进行优化。

在确认了输入 `n` 对应的数字位于何种区间后，为了在区间内进行高效搜索，我们可以利用以下两个式子进行二分搜索，
$$
\mathrm{totalWidth}(\mathrm{num})\geqslant n
$$

$$
\mathrm{totalWidth}(\mathrm{num}-1)<n
$$

有了该公式，便可以二分搜索以在 $O(\log n)$ 的时间复杂度内快速定位 $\mathrm{num}$，并且可以知道 $\mathrm{num}$ 在所属区间内是第 $\frac{\mathrm{totalWidth}(\mathrm{num})-\mathrm{totalWidth}(10^k-1)-1}{\mathrm{width}(\mathrm{num})}$ 个元素（0-based），进而计算出 `count` 以精确至 $\mathrm{num}$ 的具体数码。

# O(1) 改进方案

## 思路

二分查找的思路还是繁琐化了，因为当我们已经划分出了宽度均匀的区间后，可以直接算出 $\mathrm{num}$，时间复杂度为 $O(1)$ 而不必要进行二分查找。在 $O(\log n)$ 改进方案的基础上，在已确认 $\mathrm{num}$ 位于何种区间后，$\mathrm{num}$ 在所属区间内的位置 $\frac{\mathrm{totalWidth}(\mathrm{num})-\mathrm{totalWidth}(10^k-1)-1}{\mathrm{width}(\mathrm{num})}$ 可以直接通过 $\displaystyle\bigg\lfloor\frac{n-\mathrm{totalWidth}(10^k-1)-1}{\mathrm{width}}\bigg\rfloor$ 算出来，那么自然的
$$
\mathrm{num}=\mathrm{base}+\bigg\lfloor\frac{n-\mathrm{totalWidth}(10^k-1)-1}{\mathrm{width}}\bigg\rfloor+1
$$

相应地，
$$
\mathrm{countForNum}=\mathrm{totalWidth}(10^k-1)+(\mathrm{num}-\mathrm{base})\times\mathrm{width}
$$

## 代码

```java
class Solution {

    private static final int[] exp10 = {
        1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
    };

    public int findNthDigit(int n) {
        int[] res = initNum(n);
        int base = res[0];
        int baseCount = res[1];
        int width = res[2];

        int num = base + ((n - baseCount - 1) / width) + 1;
        long countForNum = (long) baseCount + (num - base) * width;

        int count = (int) (countForNum - width);

        while (true) {
            int high = num / pow10(width - 1);
            count++;
            if (count == n) return high;
            num -= high * pow10(width - 1);
            width--;
        }
    }

    // 返回数组中，第一个值为初始 num，第二个值为初始 count，第三个值为 width
    private int[] initNum(int n) {
        if (n <= 9) {
            return new int[]{0, 0, 1};
        } else if (n <= 189) {
            return new int[]{9, 9, 2};
        } else if (n <= 2889) {
            return new int[]{99, 189, 3};
        } else if (n <= 38889) {
            return new int[]{999, 2889, 4};
        } else if (n <= 488889) {
            return new int[]{9999, 38889, 5};
        } else if (n <= 5888889) {
            return new int[]{99999, 488889, 6};
        } else if (n <= 68888889) {
            return new int[]{999999, 5888889, 7};
        } else if (n <= 788888889) {
            return new int[]{9999999, 68888889, 8};
        } else {
            return new int[]{99999999, 788888889, 9};
        }
    }

    // exp 范围为 [0, 9]
    private int pow10(int exp) {
        return exp10[exp];
    }
}
```

