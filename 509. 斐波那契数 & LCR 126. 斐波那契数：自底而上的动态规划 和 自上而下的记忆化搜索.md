题目简述：

> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> > `F(0) = 0，F(1) = 1`
> >
> > `F(n) = F(n - 1) + F(n - 2)，其中 n > 1`
>
> 给定 `n` ，请计算 `F(n)` 。
>
> 答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

题目链接：[LCR 126. 斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

[LCR 126. 斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/) 在 [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/) 的基础上额外要求对溢出的数字取模，这里一并讨论。

# 自底而上的动态规划

时间复杂度为 $O(n)$，空间复杂度为 $O(1)$（滚动数组）。斐波那契数列问题很适合作为初学者学习研究动态规划与记忆化搜索差异的地方，毕竟其递推公式直接就是状态转移方程。

为什么直接 `return fib(n-1) + fib(n-2)` 这样递归会导致大量重复求解子问题？为什么动态规划与记忆化搜索能避免重复求解子问题？自底而上的动态规划和自上而下的记忆化搜索在避免重复求解的目的上行为的区别是什么？

```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        int dp1 = 0;
        int dp2 = 1;

        for (int i = 2; i <= n; i++) {
            int tmp = dp2;
            dp2 += dp1;
            dp1 = tmp;
            if (dp2 >= 1000000007) {
                dp2 = dp2 % 1000000007;
                dp1 = dp1 % 1000000007;
            }
        }

        return dp2;
    }
}
```

# 自上而下的记忆化搜索

时间复杂度与空间复杂度均为 $O(n)$。

```java
class Solution {

    HashMap<Integer, Integer> map;

    public int fib(int n) {
        map = new HashMap<>();
        map.put(0, 0);
        map.put(1, 1);
        return fibonacci(n);
    }

    private int fibonacci(int n) {
        if (map.containsKey(n)) return map.get(n);

        int res = fibonacci(n - 1) + fibonacci(n - 2);
        map.put(n, res % 1000000007);
        return res % 1000000007;
    }
}
```

