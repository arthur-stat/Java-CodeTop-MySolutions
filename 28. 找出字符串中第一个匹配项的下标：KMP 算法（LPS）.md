题目简述：

> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

题目链接：[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

# 前言

本文中 KMP 中计算 LPS 的原理推导部分是我在一年以前就已写好的。KMP 的原理不是本文重点，本文重点是如何实现 KMP 算法，包括实现 KMP 算法时的一些技巧。

LPS 的计算原理大部分人我想都是复习过后不出一周就会再次彻底遗忘——考虑到 LPS 计算原理相对复杂但实现简洁，因此我们重点讨论如何实现。

但在本文最后一章也给出我一年前撰写的 KMP 算法原理，读者感兴趣的话可以试着推导。那里的$\text{next}$数组正是 LPS，只是称呼不同。

---

Z-算法也能做到 KMP 算法能做的事，二者的目的是一样的，区别主要是在于构造的前缀数据结构不同，但两种结构是可以一比一互相翻译的。限于篇幅，本文只介绍 KMP 算法。读者若对 Z-算法感兴趣，可以在互联网上搜索，这里只作抛砖引玉。

# KMP 算法技巧

如何计算 LPS（Longest Prefix Suffix）是实现 KMP 算法的关键。

定义 `LPS[i]` 为模式串 `p[0..i]` 同时是真前缀与真后缀的最长子串长度，然后按照下述三个口令计算 `LPS`：

1. 能扩则扩
2. 不能扩则回退
3. 退到头则置零

这三个口令的具体含义为：

（首步）蕴含 `len = LPS[i-1]`——无需显式赋值，

1. 如果 `p[i] == p[len]`，则 `LPS[i] = len + 1`，然后 `len++`、`i++`，继续 `i` 的遍历
2. 否则，
   - 若 `len > 0`，则 `len = LPS[len - 1]`，保持 `i` 不变、回到首步
   - 若 `len == 0`，则 `LPS[i] = 0`，然后 `i++`，继续 `i` 的遍历

这样就可以计算出 LPS。

初始化值：`LPS[0] = 0`，`i` 从 1 开始遍历。注意这里 LPS 的定义要求是真前缀与真后缀的长度，真前缀与真后缀的长度必须小于当前串，因此取 `LPS[0] = 0`。

---

有了 LPS 后，用双指针分别指向目标串与模式串：

1. 若 `s[i] == p[j]`，则双指针同时前进（`i++`，`j++`）
2. 否则，
   - 如果 `j > 0`，则 `j` 回退至 `LPS[j-1]`
   - 如果 `j == 0`，则 `i++`

# KMP 算法实现

算法的时间复杂度为 $O(m+n)$，空间复杂度为 $O(n)$。

```java
class Solution {

    public int strStr(String haystack, String needle) {
        return kmp(haystack, needle);
    }

    public int[] lps(String p) {
        int n = p.length();
        int[] lps = new int[n];
        // lps[0] = 0;
        int i = 1;
        int len = 0;
        while (i < n) {
            if (p.charAt(i) == p.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
        return lps;
    }

    public int kmp(String s, String p) {
        int[] lps = lps(p);
        int m = s.length();
        int n = p.length();
        int i = 0;
        int j = 0;
        while (i < m) {
            if (s.charAt(i) == p.charAt(j)) {
                i++;
                j++;
                if (j == n) {
                    return i - n;
                }
            } else if (j > 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }

        return -1;
    }
}
```

# KMP 算法原理推导

下面的内容是一年前写成的。

---

常用于字符串模式匹配的算法有很多，例如BM算法、Horspool算法、Sunday算法、KMP算法、KR算法与AC自动机算法，这里讨论基于动态规划的KMP算法——这是动态规划的一个较难的应用。

> <b>《数据结构》严蔚敏著</b>：串的模式匹配通常指子串的定位操作，是各种串处理系统中最重要得到操作之一。

在模式匹配中，称定位操作的对象为主串$S$，记$S$长度为$n$，称需要被定位的串为模式串$T$，记$T$长度为$m$。要定位子串，一个自然的想法是遍历主串的每一个元素，当在所选取主串的第一个字符与模式$T$第一个字符相同时，判断主串第一个字符的下一个字符是否与模式$T$第二个字符相同，如果相同则称匹配成功、继续判断主串第一个字符的下下一个字符是否与模式$T$第二个字符相同……直到在某次结果返回结果“不相同”（称为匹配不成功）时，回溯到主串的第二个字符，继续开始执行判断是否与模式$T$第一个字符相同……循环往复直到遍历主串$S$，或在某趟匹配时匹配到模式$T$的最后一位字符时结果返回匹配成功，返回匹配串的起始下标。实现时，可以用两个计数指针$i,j$分别表示主串$S$与模式$T$的中当前比较字符的位置，回溯时回溯指针$i_{new}$为$i+1$即可，$j$置$0$。这个算法被称为BF算法，是最简单也最“暴力”的模式匹配苏案发。

BF算法直观、易理解，且处理文本匹配这类问题时有着$O(n+m)$的近似时间复杂度，但对于01串匹配等问题时却经常出现最坏情况$O(nm)$的时间复杂度，而KMP算法是一种比BF算法更好的模式匹配算法，下面推导KMP算法。

## 模式匹配原理与流程

KMP算法于1977年由Donald E. Knuth，James H. Morris与Vaughan R. Pratt在论文[<b>《Fast Pattern Matching in Strings》</b>](https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf)中首次提出。KMP算法相较于BF算法的改进在于，在每一趟匹配过程中当出现返回结果匹配不成功（称为“失配”）的情况时，值，而是利用这趟匹配最终出现匹配不成功前已匹配成功的结果，在选择下一个进行匹配的主串中字符时 ，选择尽可能靠后的字符，这样就可以跳过不必进行的匹配。而确定具体该选择主串中哪个字符作为下一个进行匹配的字符的过程，这背后蕴含的实际上是一个动态规划的过程。

在初学时我也因为教科书上一堆抽象的数学公式而完全不能理解（即使我是半个数学系毕业的……），现在我希望从需求出发自然地引出前缀表、$\text{next}$数组，并探究如何计算整个$\text{next}$数组。

让我们先来模拟一个流程，说明为什么最初的算法效率低下，而KMP算法又需要从哪里对最初的算法进行改进，并且改进后指针$i$不会回溯的原因。记主串$S$的长度为$n$、状态串$T$的长度为$m$。

举一个具体的例子，设主串$S$为`'ABBBAAAAAAABBBA'`、模式串$T$为`'AAAABBB'`。一趟匹配定义为从上一轮匹配发生失配后的初始化到本轮匹配发生失配的过程，假设在某趟匹配开始时，$i=4$，$j=0$：
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,i=4\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\downarrow \\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
A&B&B&B&A&A&A&A&A&A&A&B&B&B&A\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\ \ \ \ \ \,\,\,\ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&A&A&A&B&B&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,j=0
\end{align}
$$
在BF算法中，由于此时$S[i]=T[j]$，所以匹配成功，继续匹配，因此`i++`、`j++`。这里就不重复匹配成功情况下的过程了，我们观察到当$i=8,\ j=4$时会出现失配现象而导致这趟匹配终止，让我们从这里继续：
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{brute force algorithm}\\
\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,i=8\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\downarrow \\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
A&B&B&B&A&A&A&A&A&A&A&B&B&B&A\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,\,\,\ \ \ \ \ \,\,\,\ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&A&A&A&B&B&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,\uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,j=4
\end{align}
$$
在BF算法中，这时应当回溯指针$i_{new}$为$i-j+1$，在我们的例子中，$i_{new}=8-4+1=5$，也可以看作回溯到在这趟匹配开始时的$i=4$并进行`i++`操作，而$j$则被重新赋为$0$，然后再重新开始下一趟匹配。初始化后如下图所示，注意这里为方便表示匹配、将一趟匹配开始时对比的字符$S[i]$与$T[0]$对准，将$T$随着$u=4$的`i++`操作整体向右移了一位。
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{brute force algorithm}\\
\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,i=5\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\downarrow \\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
A&B&B&B&A&A&A&A&A&A&A&B&B&B&A\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \,\ \ \ \ \ \ \ \ \ \,\ \ \ \ \ \ \,\,\,\,\,\ \ \ \ \ \ \ \ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&A&A&A&B&B&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\uparrow\\
&\ \ \ \ \ \ \ \,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,j=0
\end{align}
$$
然而，这样就产生了一些不必要的重复匹配，可以看出其实从$S[4]$到$S[10]$的字符均为`'A'`，而$T[0]$到$T[3]$的字符也均为`'A'`，所以其实$j$不必赋$0$，因为在上一趟匹配的结果中已经蕴含了下一趟匹配中前若干次字符匹配必然返回匹配成功。这个例子很好地说明了实际上$i$不必回溯，而$j$也不需要在每趟匹配开始时赋$0$——可以利用到上一趟匹配结果这一BF算法并未利用的信息，跳过一些BF算法中的重复匹配，这就是KMP算法的核心思路。

---

那么KMP算法会怎么做呢？KMP算法中的指针$i$不会回溯，$i,j$会随着匹配的进行指向下一对匹配字符，这个操作可以通过对$i,j$分别自增一完成，或者说更新`i++`、`j++`，直到发生失配。直到这一步，KMP算法与BF算法还没有太大差别。

注：利用后文中的$\text{next}$数组，这种情况等价于$\textcolor[RGB]{102,0,204}{\boldsymbol{S[i]=T[j]}}$
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{KMP algorithm}\\
\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,i=5\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\downarrow \\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
A&B&B&B&A&A&A&A&A&A&A&B&B&B&A\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\ \ \ \ \ \ \ \ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&A&A&A&B&B&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,j=1\\
\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\cdots\ \cdots\\
\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,i=8\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\downarrow \\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
A&B&B&B&A&A&A&A&A&A&A&B&B&B&A\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\ \ \ \ \ \ \ \ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&A&A&A&B&B&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,\uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,j=4
\end{align}
$$

发生失配后，$i$仍指向下一个字符（而不会回溯），而$j$则会通过某种方式，直接指向当`i++`时模式中有必要从某处开始匹配的位置——$j$被新赋的值会比$j$更小，$j$被更新后状态$T$的位于$T[j]$前的字符则是没必要参与匹配的，因为当$j$指向$T[j]$就意味着我们已经通过上一趟匹配知道了$T[j]$以前的字符不可能匹配失败，从而避开了重复比对。为保持$i,j$指向的字符位于同一列，这里将状态$T$右移两位，最终得到下图。
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{KMP algorithm}\\
\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,i=9\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\downarrow \\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
A&B&B&B&A&A&A&A&A&A&A&B&B&B&A\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,\ \ \ \ \ \ \ \ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&A&A&A&B&B&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,\uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,j=3
\end{align}
$$
这部分就是KMP算法有别于BF算法的处理，我们现在的目标就是找到如何寻找$j$在每趟匹配开始时的初始化值，所以先从仅有的信息开始——$S$与$T$在上一趟匹配中的结构关系。

---

知道了要解决的问题，就可以来一步步分析了。记主串$S$长为$n$、模式串$T$长为$m$，假设在上一趟匹配中发生了失配且匹配失败前正在匹配的字符为$S[i]$与$T[j]$，同时令$i_0$、$j_0$分别表示上一趟匹配开始时的初$i,j$的始化值，则从$S[i_0]$与$T[j_0]$开始直至$S[i]$与$T[j]$以前的字符一定是均返回匹配成功的，否则在$S[i_0]$与$T[j_0]$及其后、$S[i]$与$𝑇[𝑗]$以前的某一对字符返回匹配失败时就已经发生了失配并结束上一趟匹配，而不会等到匹配$S[i]$与$T[j]$才失配。

从$S[i_0]$与$T[j_0]$开始直至$S[i]$与$T[j]$之前的字符全部返回匹配成功，意味着$S[i_0+k]=T[j_0+k],\ k=0,1,\cdots,i-i_0$，也就是说
$$
\Big[S\big[i_0\big],\ S\big[i_0+1\big],\ \cdots,\ S\big[i\big]\Big]=\Big[T\big[j_0\big],\ T\big[jj_0+1\big],\ \cdots,\ T\big[j\big]\Big]\tag{$\heartsuit$}
$$
所以要研究$S$与$T$在上一趟匹配中的关系并尝试由此找到$j$在下一趟匹配的初始化值，只需要研究$T$的结构即可，这是因为从$T[j_0]$到$T_[j]$就包含了上一趟匹配中匹配成功的字符的全部信息。

既然只需要研究状态$T$的结构，我们这里更换一个更典型的模式$T$的例子。在新的例子中，模式$T$为`ABBABAB`，暂时不必考虑$i$与整个主串的具体值。设在$j=5$时发生失配：
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \,i\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \,\downarrow\\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|}\hline
...&\textcolor[RGB]{102,102,255}{\boldsymbol{A}}&\textcolor[RGB]{102,102,255}{\boldsymbol{B}}&B&\textcolor[RGB]{102,102,255}{\boldsymbol{A}}&\textcolor[RGB]{102,102,255}{\boldsymbol{B}}&\textcolor[RGB]{102,0,102}{\boldsymbol{B}}&A&...\\\hline
\end{array}\\
&T:\ \ \ \ \ \,\,\,\,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
\textcolor[RGB]{255,30,30}{\boldsymbol{A}}&\textcolor[RGB]{255,30,30}{\boldsymbol{B}}&\textcolor[RGB]{102,0,102}{\boldsymbol{B}}&\textcolor[RGB]{255,30,30}{\boldsymbol{A}}&\textcolor[RGB]{255,30,30}{\boldsymbol{B}}&\textcolor[RGB]{102,0,102}{\boldsymbol{A}}&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ j=5
\end{align}
$$
我们发现$\big[T[0],\ T[1]\big]=\big[T[3],\ T[4]\big]$且有$S[i]=T[2]$，这意味着当指针$i$自增一后（即$i_{new}=i+1$），有
$$
\begin{align}&\ \ \ \ \,\,\Big[S[i_{new}-2],\ S[i_{new}-1],\ S[i_{new}]\Big]\\
&=\Big[T[3],\ T[4],\ T[2]\Big]\\
&=\Big[T[0],\ T[1],\ T[2]\Big]
\end{align}
$$

注：利用后文中的$\text{next}$数组，这种情况等价于$S[i]\neq T[j]$但$\textcolor[RGB]{102,0,204}{\boldsymbol{S[i]=T\big[\text{next}[j-1]\big]}}$

所以令$j=3$即可，也就是$\big[T[0],T[1]\big].\text{size}()+1$（后文中会提到，其实是$\text{next}[j-1]+1$），这是因为从上文的推导中可以看出，当指针$𝑖$自增一后，包括$i_{new}$在内起向前数的三个字符与$T$的前三个字符均是相匹配的，所以我们不需要令$j=0$重新将每一对字符都匹配一遍，只要从未知是否相匹配的字符开始匹配就好。KMP算法就是通过这样的办法，避免$i$的回溯（$i_{new}>i$）与重复匹配（通过对$j$的动态初始化）的。不难分析出，本例中状态$T$右移的距离就等于$[A,B]$的长度加$1$再减去本趟匹配开始前$j$的初始化值，在这里为$2+1-0=3$。
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \,i_{new}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \,\downarrow\\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|}\hline
...&A&B&B&\textcolor[RGB]{102,204,255}{\boldsymbol{A}}&\textcolor[RGB]{102,204,255}{\boldsymbol{B}}&\textcolor[RGB]{102,204,255}{\boldsymbol{B}}&A&...\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
\textcolor[RGB]{102,204,255}{\boldsymbol{A}}&\textcolor[RGB]{102,204,255}{\boldsymbol{B}}&\textcolor[RGB]{102,204,255}{\boldsymbol{B}}&A&B&A&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ j=3
\end{align}
$$
尽管上图中的$\textcolor[RGB]{102,204,255}{\boldsymbol{[A,B,B]}}$对应了$S$与$T$中的子串，但实际上位于末位的$\textcolor[RGB]{102,204,255}{\boldsymbol{B}}$是我们单独判断的，而只有$\textcolor[RGB]{102,204,255}{\boldsymbol{[A,B]}}$是从上一趟匹配的结果中推导出来的。由$(\heartsuit)$式知，上图中的$S$可以替换为$T$，在不考虑子串$\textcolor[RGB]{102,204,255}{\boldsymbol{[A,B,B]}}$末位字符的情况下（换言之，只考虑能从上一趟匹配中推导出关系的字符），记$T_1$对应匹配中的主串$S$但位于$S[i]$之前子串、$T_2$对应匹配中的状态$T$但位于$T[j]$之前子串，易见有$T_1=T_2$，则上图也可以只用$T$的子串$T_1$与$T_2$表示。因为$T_1=T_2$且均为$T$的子串，因此本质上是只用到了状态$T$——这是一个主串为$T$、模式串也为$T$的模式匹配问题，特地区分$T_1,T_2$只是为了方便表示到底是哪个子串在进行右移，图示如下：
$$
\begin{align}
T_1&:\ \begin{array}{|c|c|c|c|c|}\hline
A&B&B&\textcolor[RGB]{102,102,255}{\boldsymbol{A}}&\textcolor[RGB]{102,102,255}{\boldsymbol{B}}\\\hline
\end{array}\\
T_2&:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,\,\,\,\,\,\begin{array}{|c|c|c|c|c|}\hline
\textcolor[RGB]{255,30,30}{\boldsymbol{A}}&\textcolor[RGB]{255,30,30}{\boldsymbol{B}}&B&A&B\\\hline
\end{array}\\
\end{align}
$$
现在我们来把上述分析的过程抽象一下，从特殊问题推广至一般问题。实际上，上文中的$\textcolor[RGB]{255,30,30}{\boldsymbol{[A,\ B]}}$被称为`ABBABAB`的最长相同前后缀，我们先来看看前缀与后缀的定义。

对于一个字符串`str`，以`'BABAABA'`为例，他的前缀（prefix）是不包括末位字符的所有以其首位字符为起始的子串所组成的集合，他的后缀（postfix）是不包括首位字符的所有以其末位字符为终点的子串所组成的集合。对于`'BABAABA'`而言，他的前缀与后缀为：
$$
\begin{align}&\ \ \ \ \ \ \ \ \ \ \ \ \ \,\text{BABAABA}\\
&\begin{array}{|cc|}\hline\text{prefix} &\ \ \ \text{popstfix}\\\hline
BABAAB &\ \ \ ABAABA\\
BABAA\ \ \  &\ \ \ \ \ \ BAABA\\
BABA\ \ \ \ \ \  &\ \ \ \ \ \ \ \ \ AABA\\
BAB\ \ \ \ \ \ \ \ \  &\ \ \ \ \ \ \ \ \ \ \ \ ABA\\
BA\ \ \ \ \ \ \ \ \ \ \ \  &\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BA\\
B\ \ \ \ \ \ \ \ \ \ \ \ \ \ \  &\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ A\\\hline
\end{array}
\end{align}
$$
接下来我们从这些前缀与后缀中找出所有相同的前后缀，容易想到只需要将长度相同的前缀与后缀进行对比就好了，因为长度不一样的前缀与后缀必然不相同。根据上表不难找出所有的相同的前后缀，在这个例子中只有`'BA'`是相同的前后缀，自然也是最长的相同前后缀，其长度为$2$。

通过以上定义，可以知道：前文中我们所观察到的“$\big[T[0],\ T[1]\big]=\big[T[3],\ T[4]\big]$”，实际上就是状态$T$前$5$个字符构成的子串`'ABBAB'`的一个相同前后缀，而且其恰好是最长的相同前后缀：
$$
\begin{align}&\ \ \ \ \ \ \ \ \,\,\text{ABBAB}\cdots\\
&\begin{array}{|cc|}\hline\text{prefix} &\ \ \ \text{popstfix}\\\hline
ABBA &\ \ \ BBAB\\
ABB\ \ \  &\ \ \ \ \ \ BAB\\
\boxed{AB}\ \ \ \ \ \  &\ \ \ \ \ \ \ \ \ \boxed{AB}\\
A\ \ \ \ \ \ \ \  &\ \ \ \ \ \ \ \ \ \ \ \ B\\\hline
\end{array}
\end{align}
$$
所以，只要知道了状态$T$的前$k$个字符构成的子串的最长相同前后缀的长度就可以完成更新$j$的全部流程，记为$\text{pre}_k$，其中$k=1,2,\cdots,m$，而并不需要具体的最长相同前后缀。该值只与$T$有关，而与$S$无关。注意，$\text{pre}_1$必然为$0$，因为只有一个字符的字符串的前缀与后缀均为空集，这是由前缀的定义不能包含末位元素与后缀的定义不能包含首位元素所决定的，所以最长相同前后缀的长度当然也为$0$，即不存在。特别地，当$T$中的字符均互不相同时，$\forall k,\ \text{pre}_k=0$。

数组$[\text{pre}_1,\ \text{pre}_2,\ ,\cdots,\ \text{pre}_m]$被称为前缀表$\text{prefix}$，前缀表$\text{prefix}$及其一些衍生数组也被称为$\text{next}$数组或$\pi$函数数组，这里我们将$\text{next}$数组定义为前缀表，并在后文中以$\text{next}$数组称呼前缀表。$\text{next}[k]$表示前缀表中第$k+1$位的值。由于$\text{next}$数组只与$T$有关，因此可以先将$\text{next}$数组计算出来，在匹配的过程中直接使用。

$\text{next}$数组可以由动态规划高效计算，在引出KMP算法的流程后再来深入讨论$\text{next}$数组的计算。

接下来讨论在更普遍问题中$j$应被初始化为何值及其原因。由于在失配前的匹配均是成功的，所以失配前$S$被匹配的子串等于$T$被匹配的子串，即$(\heartsuit)$式，而$(\heartsuit)$式又告诉我们，如果$T$在失配前所匹配的子串存在相同前后缀，则意味着此时$T$的后缀 = $T$的前缀 = $S$参与匹配子串的前缀 = $S$参与匹配子串的后缀。在上一轮匹配失配前，$i,j$指针分别指向$S$参与匹配子串的后缀末位与$T$的后缀末位，现在将上一趟匹配失配前$S$参与匹配子串的后缀当作本趟匹配开始时$S$参与匹配子串的前缀、将上一趟匹配失配前$T$的后缀视为本趟匹配开始时$T$的前缀，根据等式“$T$的后缀 = $𝑇$的前缀 = $𝑆$参与匹配子串的前缀 = $𝑆$参与匹配子串的后缀”，在本趟匹配开始时$S$参与匹配子串的前缀与$T$的前缀是处处相等的——因为他们对应的前缀子串在上一趟匹配中其实就已经作为后缀被匹配过了，这时只需要对比本趟匹配开始时$S,T$参与匹配的前缀的下一位即可，所以指针$i_{new}=i+1$、$j_{new}=\text{next}[j-1]$是一对可行的初始化值。在图像上的表现为将$T$右移至$S$中对于后缀之处。

当$i_{new}=i+1$，为什么可行的初始化$j_{new}=\text{next}[j-1]$同时也是$j_{new}$所有可能的更新值中的最大者呢？在前文的分析中，只有存在相同前后缀时才可能避开对相同前缀与后缀的重复匹配，并尽可能使$j$初始化为最大的值。根据推导，对于一个长为$j'$的相同前后缀，则$j=j'$；而$\text{next}[j-1]$正是最大的可能的$j'$，所以$\text{next}[j-1]$就是$j_{new}$——尽可能初始化$j$为最大的值。不可能在任何情况下都存在$j''>\text{next}[j-1]$且能保证匹配中的不重不漏。

总结：当$T[j]\neq S[i]=T\big[\text{next}[j-1]\big]$：`i++`，$j_{new}=\text{next}[j-1]$。

- 为什么令$j_{new}=\text{next}[j-1]$而不是$j_{new}=\text{next}[j]$？之所以令$j_{new}=\text{next}[j-1]$而不是$j_{new}=\text{next}[j]$，是因为我们利用的是失配前的那些匹配成功的信息。对于很多模式匹配问题，主串与状态的字符集中都不止两种字符，这种情况下如果发生失配，则我们不可能仅从失配时的$i,j$推断出$S[i]$与$T[j]$的具体值与他们同$S,T$中其他字符的关系，除非回到主串$S$与模式串$T$中进行查找与比对。所以我们在寻找如何最大初始化$j$的过程中，其实对信息的利用主要都是从上一位开始向首位进行的。


---

对于模式$T$为`ABBABAB`的例子，上文中只分析了$S[i]=T[2]$的情况，可如果$S[i]\neq T[2]$，也就是说$\textcolor[RGB]{102,0,204}{\boldsymbol{T[j]\neq S[i]\neq T\big[\text{next}[j-1]\big]}}$呢？不妨将例子中的$S[i-3]$与$T[2]$更改为`'A'`，构造一种$S[i]\neq T[2]$的情况，如下图所示：
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \,i\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \,\downarrow\\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|}\hline
...&\textcolor[RGB]{102,102,255}{\boldsymbol{A}}&\textcolor[RGB]{102,102,255}{\boldsymbol{B}}&A&\textcolor[RGB]{102,102,255}{\boldsymbol{A}}&\textcolor[RGB]{102,102,255}{\boldsymbol{B}}&\textcolor[RGB]{102,0,102}{\boldsymbol{B}}&A&...\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
\textcolor[RGB]{255,30,30}{\boldsymbol{A}}&\textcolor[RGB]{255,30,30}{\boldsymbol{B}}&\textcolor[RGB]{102,0,102}{\boldsymbol{A}}&\textcolor[RGB]{255,30,30}{\boldsymbol{A}}&\textcolor[RGB]{255,30,30}{\boldsymbol{B}}&\textcolor[RGB]{102,0,102}{\boldsymbol{A}}&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ j=5
\end{align}
$$
计算后得知$\text{next}[5]$仍为$2$，但$S[i]\neq T[2]$，这时若仍令`i++`、$j_{new}=\text{next}[j-1]=3$，会发现
$$
\begin{align}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\;\,\,\,\,\,\,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\,\,i+1\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \,\downarrow\\
&S:\ \begin{array}{|c|c|c|c|c|c|c|c|c|}\hline
...&A&B&A&A&B&B&A&...\\\hline
\end{array}\\
&T:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\;\,\,\,\,\,\,\begin{array}{|c|c|c|c|c|c|c|}\hline
A&B&A&A&B&A&B\\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \uparrow\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\ \ \ \ \ \ \ \ \ \ \ \ \ \,\,\ \ \ \ \ \ \ \ \ \ \ \ \ j_{new}?
\end{align}
$$
如果这样操作是合理的，那么当前正匹配的字符串为$S[i+1]$与$T[3]$，但$S[i]\neq T[2]$——可如果$S[i]\neq T[2]$，那么在这里就应该失配了，又怎么去讨论$S[i+1]$是否等于$T[3]$呢？因为无论$𝑆[𝑖+1]$是等于$𝑇[3]$还是不等于，在前一位就已经发生失配了，那么这一趟匹配绝无可能正确地匹配到整个模式$T$，而我们从$𝑆[𝑖+1]$与$𝑇[3]$开始匹配时就已经默认了$S[i]=T[2]$、$S[i-1]=T[1]$与$S[i-2]=T[0]$，这与事实$S[i]\neq T[2]$背道而驰。

究其根本，发生这种错误的根本原因是因为我们应该在匹配前进行某种操作，保证有$S[i]=T[j_{new}-1]$，否则就有可能出现这样的问题。为什么我们确定需要通过将$j$初始化为其他的值以期解决问题？因为$i$总会随着匹配的进行自而增一，故只能从$j_{new}$入手。

先暂时回到$T[j]\neq S[i]=T\big[\text{next}[j-1]\big]$的情况，我们为什么会考虑初始化$j_{new}=\text{next}[j-1]$呢？是因为$\text{next}[j-1]$是$T$的前$j$个字符构成的子串的最长相同前后缀的长度，记为$j_1$。既然赋$j_{new}$为$T$的前$j$个字符构成的子串的最长相同前后缀的长度$j_1$不可行，那么我们就应该转而寻找第二长的相同前后缀的长度，此时第二长的相同前后缀的长度才有可能对应最大可行的$j_{new}$，记为$j_2$，再继续判断$j_2$是否可行，即是否有$S[i]=T\big[\text{next}[j_2-1]\big]$，如果成立则赋$j_{new}=j_2$，否则继续寻找第三长的相同前后缀的长度，记为$j_3$，判断$j_3$是否可行、是否有$S[i]=T\big[\text{next}[j_3-1]\big]$，如果成立则赋$𝑗_{𝑛𝑒𝑤}=𝑗_3$，否则继续寻找第四长的相同前后缀的长度$j_4$……直到某次有$S[i]=T\big[\text{next}[j_n-1]\big]$成立、赋$j_{new}=j_n$，或直到$y_n=0$时也无法更新$j_{new}$，这时回到了类似BF算法的情景，应赋$j_{new}=y_n=0$。

到这里，在已知$\text{next}$数组的情况下就可以写出KMP算法的匹配代码了。

```python
# strings = 'AGCATAATAATTAA'
# T = 'ATAATA'

next = [0, 0, 1, 1, 2, 3]
    
def kmp(strings, T, loc=0):
    S = strings[loc:]
    n = len(S)
    m = len(T)
    j = 0
        
    for i in range(n):
        while j and S[i] != T[j]:
            j = next[j-1]
        if S[i] == T[j]:
            j += 1
        if j == m:
            return i
    return -1
```

## 前缀表的动态规划

现在让我们讨论怎么快速地计算$\text{next}$数组吧。注意到“$\text{next}[j]=\text{pre}_{j+1}$就是$T$的前$j$个字符组成的子串的最长相同前后缀的长度”中的关键词：“最长”、“前后缀”、“长度”，这意味着我们或许可以像前文中在最长公共子串问题中的分析那样，用**动态规划**方法高效求解——只不过加上“纳入考虑的公共子串必须同时也是两字符串的前后缀”的条件限制。

按这类问题动态规划的“套路”，定义状态$DP[j]$等于$\text{next}[j]$、也等于$\text{pre}_{j+1}$，注意到$DP[j]$实际上表示$T$的前$j$个字符所组成的子串的最长相同前后缀之长度，这是一个重要信息，所以计算$\text{next}[j]$不仅是一个动态规划问题，也是一个模式匹配问题，且主串与状态串均为$T$。又观察知$DP[j]$对应的最长相同前后缀相较于$DP[j-1]$对应的最长相同前后缀均在末位新增了一个字符，且新增的字符分别为$T\big[DP[j-1]\big]$与$T\big[j-1\big]$，我们需要讨论这两个字符以找到状态转移；同时，假设$\big\{DP[i]\big\}^{j-1}_{i=0}$已知，则根据已知的$DP[j-1]$，有
$$
\scriptsize{\Big[T\big[0\big],\ T\big[1\big],\ \cdots,\ T\big[DP[j-1]-1\big]\Big]=\Big[T\big[j-DP[j-1]-1\big],\ T\big[j-DP[j-1]\big],\ \cdots,\ T\big[j-2\big]\Big]}\tag{$\heartsuit$}
$$
下面进行状态转移分析：

- $\text{next}[0]=0$

- 当$T\big[DP[j-1]\big]=T\big[j-1\big]$，意味着
  $$
  \scriptsize{\Big[T\big[0\big],\ T\big[1\big],\ \cdots,\ T\big[DP[j-1]\big]\Big]=\Big[T\big[j-DP[j-1]-1\big],\ T\big[j-DP[j-1]\big],\ \cdots,\ T\big[j-1\big]\Big]}
  $$
  可见$DP[j]$代表的最长相同前后缀长度一定恰比$DP[j-1]$大一，所以有$DP[j]=DP[j-1]+1$。

- 当$T\big[DP[j-1]\big]\neq T\big[j-1\big]$，记$DP[j-1]$所对应的$(\heartsuit)$式等号左边的前缀为$\text{left}_{j-1}$、等号右边的后缀为$\text{right}_{j-1}$，则$\text{left}_{j-1}$与$\text{right}_{j-1}$在$T$中的排列为：
  $$
  \begin{align}
  &T:\ \begin{array}{|c|c|c|c|c|c|c|c|c|}\hline
  \scriptsize T\big[0\big]&\scriptsize T\big[1\big]&\cdots&\tiny T\big[DP[j-1]-1\big]&\cdots&\tiny T\big[j-DP[j-1]-1\big]&\tiny T\big[j-DP[j-1]\big]&\cdots&\scriptsize T\big[j-2\big]\\\hline
  \end{array}\\
  &\ \ \ \ \ \ \ \ \underbrace{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,}_{\text{left}_{j-1}}\ \ \ \ \ \ \ \ \ \,\,\underbrace{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,}_{\text{right}_{j-1}}
  \end{align}
  $$

  注：注意，当 $\text{let}_{j-1}$ 足够长，$\tiny T\big[DP[j-1]-1\big]$ 是有可能位于$\tiny T\big[j-DP[j-1]-1\big]$左边的

  现分析$\forall k,\ DP[k]$对应的最长相同前后缀的情况：

  - 对于前缀$\text{left}_k$，如果存在$DP[k]=DP[k']+a$，其中$k'\neq k$且$a\in\mathbb{Z}$，则一定有
    $$
    \begin{align}
    &\text{left}_k=\Big[T\big[0\big],\ T\big[1\big],\ \cdots,\ T\big[DP[k]-1\big]\Big]\\
    &\text{left}_{k'}=\Big[T\big[0\big],\ T\big[1\big],\ \cdots,\ T\big[DP[k']-1\big]\Big]
    \end{align}
    $$
    可见$DP[k]$与$DP[k']$中的较小值对应的$\text{left}$一定是较大值对应$\text{left}$的前缀，并且可以确认这一前缀是几级前缀，除非$a=0$，则两个$\text{left}$相等，互为子串（因为前缀不包括最后一个元素，所以这时不能说是前缀）。

  - 前提同上，但后缀$\text{right}_k$与$\text{right}_{k'}$间就不存在这样的关系。
    $$
    \begin{align}
    &\text{right}_k=\Big[T\big[k-DP[k]\big],\ T\big[k-DP[k]+1\big],\ \cdots,\ T\big[k-1\big]\Big]\\
    &\text{right}_{k'}=\Big[T\big[k'-DP[k']\big],\ T\big[k'-DP[k']+1\big],\ \cdots,\ T\big[k'-1\big]\Big]
    \end{align}
    $$
    如果不利用$T$找出两个后缀具体的值并通过模式匹配对字符逐个比对，这时根本无法找出二者更进一步的对应关系，他们也有可能完全不同，也有可能部分相同，还有可能完全相同，而且即使部分相同，也找不出所有相同字符在$\text{right}_k$与$\text{right}_{k'}$中的位置。

  所以不能通过具体的前后缀寻找$DP[j]$，因为$\text{next}$的实现中只记录了$T$的长度为$j$的子串的最长相同前后缀的长度，但并没有具体找出并记录这些最长相同前后缀的具体值，根据上文中对$DP[k]$与$DP[k']$相应最长相同前后缀关系的分析，我们无法近通过长度找到$DP[k]$与$DP[k']$对应最长相同前后缀的关系 $\Rightarrow$ 我们无法通过已知的$\big\{DP[i]\big\}^{j-1}_{i=0}$找出所有具体的$\big\{\text{left}_i\big\}^{j-1}_{i=0}$与$\big\{\text{right}_i\big\}^{j-1}_{i=0}$，再根据他们找出$DP[j]$对应的最长相同前后缀$\text{left}_{j}$与$\text{right}_{j}$，从而计算出$DP[j]$。

  既然最直观的想法——计算出所有具体的$\big\{\text{left}_i\big\}^{j-1}_{i=0}$与$\big\{\text{right}_i\big\}^{j-1}_{i=0}$并根据他们与$\text{left}_{j}$、$\text{right}_{j}$的关系找到$\text{left}_{j}$、$\text{right}_{j}$的办法行不通，则只能考虑从$\big\{DP[i]\big\}^{j-1}_{i=0}$本身入手。仔细分析后发现，实际上我们也并不需要所有具体的$\big\{\text{left}_i\big\}^{j-1}_{i=0}$与$\big\{\text{right}_i\big\}^{j-1}_{i=0}$，我们首先只需要$T$的长度为$DP[j-1]$且满足$T[j-1]=T\big[DP[DP[j-1]]\big]$的子串并找到该子串的最长相同前后缀长度——这里解释一下为什么需要该子串满足这两点要求，这是计算$\text{next}$最核心的一点。究其根本，是因为$DP[j]$对应子串的前后缀要成为最长相同前后缀，首先必须满足前缀的前$DP[j]-1$个字符与对应的后缀前$DP[j]-1$个字符必须是全部匹配成功（前$DP[j]-1$个对应位置的字符应全部相同，保证除最后一个字符外二者是相同公共前后缀）的、同时后缀的前$DP[j]-1$个字符组成的子串必须是$\text{right}_{j-1}$的后缀（该要求源自于在$T\big[DP[j-1]\big]\neq T\big[j-1\big]$的大前提下可以推导出$DP[j]$一定不大于$DP[j-1]$，而$\text{right}_{j-1}$不能作为$\text{right}_j$的最长前缀只是因为$T\big[DP[j-1]\big]\neq T\big[j-1\big]$，所以这样限制就可以保证要找的后缀有可能且是仅有可能的成为$\text{right}_j$最大前缀的字符串）。记$y$是某个小于$DP[j-1]$的非负整数、表示除开最后一位字符外的相同前后缀长度，则只需要找出满足下式的$y$，于是$y$就是符合前述限制的相同前后缀的长度：
  $$
  \left\{\begin{align}&\scriptsize \Big[T\big[0\big],\ T\big[1\big],\ \cdots,\ T\big[DP[j]-2\big]\Big]=\Big[T\big[y-DP[j]\big],\ T\big[y-DP[j]+1\big],\ \cdots,\ T\big[y-2\big]\Big]\\&\scriptsize \Big[T\big[y-DP[j]\big],\ T\big[y-DP[j]+1\big],\ \cdots,\ T\big[y-2\big]\Big] = \Big[T\big[DP[j-1]-,\ T\big[DP[j-1]-,\ \cdots,\ T\big[j-3\big]\Big]\end{align}\right.\tag{$\diamondsuit$}
  $$
  在具体的计算过程中，注意到$DP[j-1]$正是满足条件的最大的$y$——$T$的长度为$DP[j-1]$且满足$T[j-1]=T\big[DP[DP[j-1]]\big]$的子串的最长相同前后缀长度，记为$y_1$，也就是$T$的前$j-1$个字符所组成的子串的最长相同前后缀之长度，

  - 当$T\big[DP[j-1]\big]\neq T\big[j-1\big]$，先赋$y_1=DP[j-1]$，然后判断是否有$T\big[y_1-1\big]=T\big[j-1\big]$成立，若等式成立则赋值$DP[j]=DP[j-1]+1$，若等式不成立则寻找满足$(\diamondsuit)$式的第二大的$y$，记为$y_2$
  - 类似对$y_1$的分析，这时$y_2$实际上正是$T$的长度为$DP[y_1]$且满足$T[j-1]=T\big[DP[y_2]\big]$的子串的最长相同前后缀长度，根据结果$y_2=DP[y_1-1]$再次判断是否有$T\big[y_2-1\big]=T\big[j-1\big]$成立，如果成立则赋值$DP[j]=y_2+1$，等式不成立则寻找满足$(\diamondsuit)$式的第三大的$y$，记为$y_3$
  - 令$y_3=DP[y_2-1]$，判断是否有$T\big[y_3-1\big]=T\big[j-1\big]$成立，若成立则赋值$DP[j]=y_3+1$，不成立则寻找满足$(\diamondsuit)$式的第四大的$y$，记为$y_4$
  - … …
  - 直到在$y_u=DP[y_{u-1}-1]$时第一次有$T\big[y_u-1\big]=T\big[j-1\big]$成立、令$DP[j]=y_u+1$，这时无需再判断是否有$T\big[y_{u+1}-1\big]=T\big[j-1\big]$成立，或直到判断到最小的$y$，记为$y_{\text{min}}$，仍没有$T\big[y_{\text{min}}-1\big]=T\big[j-1\big]$成立，说明不存在公共前后缀，视最长公共前后缀长度为$0$，这时赋$DP[j]=0$。

  以上就是状态转移的具体描述了。为什么说$y_1=DP[j-1]$、$y_2=DP[y_1-1]$、$y_3=DP[y_2-1]$等，而不说$y_1=DP[j]$、$y_2=DP[y_1]$、$y_3=DP[y_2]$等等呢？原因和第二、三、四点中对$f$的分析类似，因为在匹配不成功时导致匹配不成功的这对字符我们没有也没有必要讨论他们具体值，因为在实际问题中字符集可能很大，我们只要知道他俩不相等即可（所以将他俩排除，“不相等”难以被利用），最关键的信息来自于这对字符之前那些相等的字符们，故只考虑匹配不成功字符以前的字符，他们的长度为$y_{n-1}$减一。

  综上所述，现在可以按分析编写计算$\text{next}$数组的程序了。$T\big[DP[j-1]\big]=T\big[j-1\big]$其实可以被放入循环中进行判断，也就是说其实可以将所有的判断均放入循环之中，这包括了第一步对$T\big[DP[j-1]\big]=T\big[j-1\big]$的判断，令$y_0=j$即可。

  ```python
  T = 'abaabcac'
  m = len(T)
  next = [0 for _ in range(m)]
  
  for j in range(1, m):  # j+1为T正在匹配字符的位置，T[j]为最长后缀尾部
      y = next[j-1]  # 初始化y为next[j-1]，next[j-1]+1是next[j]可能的最大值；T[y]为最长前缀尾部
      while y > 0 and T[y] != T[j]:  # 若满足条件则next[j]向左滑，y被更新为所有y中第n大的y
          y = next[y-1]  # 左滑的过程同时也是状态转移的过程，有next[next[next[...next[y-1]]]]
      if T[y] == T[j]:
          y += 1  # 除了y <= 0，结果均加1，因为另外两种情况都有T[y] == T[j]，需要加1才能得到正确结果
      next[j] = y
  
  print(next)
  ```

  输出：

  <pre><div style="font-family: Consolas, 'Courier New', monospace;">[0, 0, 1, 1, 2, 0, 1, 0]</div></pre>

补充KMP算法可视化：[KMP 学一遍忘一遍？ACM 金牌选手用可视化直击本质，理解了内核后想忘记都难！](https://www.bilibili.com/video/BV1Er421K7kF/?vd_source=0f853ad8be7f63b6ea5ac7fe4a6e3c1d)

## 基本的实现

在实际的实现中，输入参数除了需要匹配的字符串$\text{strings}$与模式$T$以外，增加一个参数$\text{loc}$，将由从$\text{strings}$第$\text{loc}+1$个字符起始直到$\text{strings}$最后一个字符构成的子串作为主串$S$，因为根据前文的分析，我们只返回了第一个匹配到的字符串的起始下标，所以这样定义的好处是进行多轮KMP算法以找出所有的匹配字符串下标时，将上一轮KMP算法返回的下标减去$T$的长度加一后作为本轮KMP算法的$\text{loc}$即可。

```python
# 输入参数
strings = 'AGCATAATAATTAA'
T = 'ATAATA'

class Algorithm:
    def perfix(self, T):
        m = len(T)
        p = [0 for _ in range(m)]
        
        for j in range(1, m):
            y = p[j-1]
            while y > 0 and T[y] != T[j]:
                y = p[y-1]
            if T[y] == T[j]:
                y += 1
            p[j] = y
            
        return p
    
    # 模式匹配KMP算法
    def kmp(self, strings, T, loc=0):
        S = strings[loc:]
        next = self.perfix(T)
        n = len(S)
        m = len(T)
        j = 0
        
        for i in range(n):
            while j and S[i] != T[j]:
                j = next[j-1]
            if S[i] == T[j]:
                j += 1
            if j == m:
                return i
        return -1
            
kmp = Algorithm()
print(kmp.kmp(strings, T))
```

输出：

<pre><div style="font-family: Consolas, 'Courier New', monospace;">8</div></pre>

其中计算$\text{next}$数组的时间复杂度为$O(m)$，遍历$S$的时间复杂度为$O(n)$，所以KMP算法的时间复杂度为$O(n+m)$（由于$n>m$，所以说$O(n)$也没问题）；如果允许原地修改$\text{strings}$则空间复杂度为$O(1)$，在我们的实现中空间复杂度为$O(n)$。