题目简述：

> 待传输文件被切分成多个部分，按照原排列顺序，每部分文件编号均为一个 **正整数**（至少含有两个文件）。传输要求为：连续文件编号总和为接收方指定数字 `target` 的所有文件。请返回所有符合该要求的文件传输组合列表。
>
> **注意**，返回时需遵循以下规则：
>
> - 每种组合按照文件编号 **升序** 排列；
> - 不同组合按照第一个文件编号 **升序** 排列。
>
>  
>
> **示例 1：**
>
> > 输入：target = 12
> > 输出：[[3, 4, 5]]
> > 解释：在上述示例中，存在一个连续正整数序列的和为 12，为 [3, 4, 5]。
>
> **示例 2：**
>
> > 输入：target = 18
> > 输出：[[3,4,5,6], [5,6,7]]
> > 解释：在上述示例中，存在两个连续正整数序列的和分别为 18，分别为 [3, 4, 5, 6] 和 [5, 6, 7]。

题目链接：[LCR 180. 文件组合](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

# 二次方程判别式枚举

## 思路

众所周知，等差数列 $\{a,a+1,\dots,a+k\}$ 的数列和为
$$
\frac{(k+1)(2a+k)}{2}
$$
我们要做的就是找出所有的 $(a,k)$。

不难知道 $a<\lceil\frac{n}{2}\rceil$，对于一个确定的 $k$，应当使 $k$ 在成立 $\frac{(k+1)(2a+k)}{2}\leqslant n$ 的前提下尽可能地大，同时当且仅当恰满足 $\frac{(k+1)(2a+k)}{2}=n$ 时被视为一个合法的解。

令
$$
\frac{(k+1)(2a+k)}{2}=n
$$
解得
$$
k=\frac{\pm\sqrt{8n+4a^2-4a+1}-2a-1}{2}
$$
只要 $k\in N^{+}$，我们就可以肯定这是一个合法的解。

于是，我们遍历每一个满足 $1\leqslant a<\lceil\frac{n}{2}\rceil$ 的 $a'$，计算其对应的 $k'$，如果 $k'=\frac{\sqrt{8n+4a^2-4a+1}-2a-1}{2}\in N^{+}$，我们就可以断言我们找到了一组合法解，并且最终能够找出所有合法解。

## 代码

算法的时间复杂度为 $O(target)$，不考虑输出数组时空间复杂度为 $O(1)$。


```java
class Solution {
    public int[][] fileCombination(int target) {
        List<int[]> res = new ArrayList<>(target / 2);

        for (int a = 1; a <= target / 2; a++) {
            int k = getK(a, target);
            if (k > 0) {
                int[] answer = new int[(int) Math.round(k) + 1];
                for (int i = 0; i < answer.length; i++) {
                    answer[i] = a + i;
                }
                res.add(answer);
            }
        }

        return res.toArray(new int[0][]);
    }

    public int getK(int a, int target) {
        long sqrting = 8L * target + 4L * a * a - 4L * a + 1L;  // 必须使用 long，否则中间结果可能溢出
        long sqrted = (long) Math.sqrt(sqrting);  // 只要编程语言实现了 IEEE-754 规范，那么平方数开根号必然是精确 double 结果
        if (sqrted * sqrted != sqrting) return 0;
        long numerator = sqrted - 2 * a - 1;
        if ((numerator & 1) == 1) return 0;
        return (int) (numerator / 2);
    }
}
```

# 滑动窗口

这应该是最不数学、最偏向软件实现的方案了。

## 思路

维护一个滑动窗口，初始化滑动窗口左端点于 $1$、右端点为 $1$，维护窗口内元素和的变量 $sum$，然后尽可能地扩展右端点。当右端点位于某点时若有 $sum=n$，意味着我们找到了一组解。当右端点位于某点时若有 $sum\geqslant n$，意味着此时再扩展右端点无论如何也不会找到合法的解，于是收缩左端点并更新 $sum$，直到再次有 $sum\leqslant n$。

当左端点大于等于 $\lceil\frac{n}{2}\rceil$，此时如论如何收缩左端点、扩展右端点也无法再得到合法的解，于是可以终止算法。

## 代码

算法的时间复杂度为 $O(target)$，不考虑输出数组时空间复杂度为 $O(1)$。

```java
class Solution {
    public int[][] fileCombination(int target) {
        List<int[]> res = new ArrayList<>(target / 2);
        int l = 1;
        int r = 1;
        int sum = 1;

        while (l <= target / 2) {
            if (sum == target) {
                int[] answer = new int[r - l + 1];
                for (int i = 0; i < answer.length; i++) {
                    answer[i] = l + i;
                }
                res.add(answer);
            }

            r++;
            sum += r;

            while (sum > target) {
                sum -= l;
                l++;
            }
        }

        return res.toArray(new int[0][]);
    }
}
```

# 数论分解（因子生成）

## 思路

证明并使用下述引理：将 $n$ 表示成若干个连续正整数之和的方案数等于 $n$ 的奇数质因子数目。

这样可以实现时间复杂度为 $O(\sqrt{target})$ 的算法。