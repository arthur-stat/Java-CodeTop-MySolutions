题目简述：

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组**是数组中的一个连续部分。

题目链接：[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

# Kadane 算法

Kadane 算法实际上是一个动态规划算法。

设 $dp[i]$ 表示以 `nums[i]` 结尾的最大和连续子数组的和，那么
$$
dp[i]=\max\{dp[i-1]+\mathrm{nums}[i],\,\mathrm{nums}[i]\}
$$
然后取 $dp$ 的最大值即可。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int sumOld = nums[0];
        int sumNew;
        int maxSumValue = nums[0];

        for (int i = 1; i < nums.length; i++) {
            if (sumOld > 0) {
                sumNew = sumOld + nums[i];
            } else {
                sumNew = nums[i];
            }
            if (maxSumValue < sumNew) maxSumValue = sumNew;
            sumOld = sumNew;
        }
        return maxSumValue;
    }
}
```

其实说是贪心也可以，都没问题。时间复杂度 $O(n)$，空间复杂度 $O(1)$。

这就是所谓的 Kadane 算法。

# 前缀和数组

既然是子数组和，那么显然也可以往前缀和数组的方向思考。

如果一次性构建好整个前缀和数组然后再计算所有可能的前缀和，这样时间复杂度会来到 $O(n^2)$，这是不可接受的。

正确的做法是在计算前缀和数组时就动态地维护已知的最小前缀和，然后用当前正遍历的索引对应的前缀和减去已知的最小前缀和，这样我们就会得到以该索引为结束位置的最大子数组和。当我们遍历所有索引，就可以得到全局最大子数组和。

实际上我们也不必存储全部的前缀和，因为并不要求我们给出最大和子数组的起始与结束位置，所以类似滚动数组的做法，我们只需要存储当前前缀和和已知最小前缀和两个值就可以了，这样可以节省内存开销。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        long sum = 0;
        long minSum = 0;
        long res = Long.MIN_VALUE;

        for (int num : nums) {
            sum += num;
            res = Math.max(res, sum - minSum);
            minSum = Math.min(minSum, sum);
        }

        return (int) res;
    }
}
```

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

# 分治算法

这个问题用分治解决其实性能没有另外两种方法好的，但该方法蕴含着线段树算法的思想。

最长子数组是一个连续的数组，我们把数组分成两块 left 和 right。最长子数组要么完全在 left，要么完全在 right，要么同时占据 left 和 right 的一部分，因此我们取 left 里的最长子数组、right 里的最长子数组以及同时占据 left 与 right 一部分的最长子数组中部分和最大的那一个，他就是全局最长子数组。对于 left 和 right，我们再这样拆分；不断拆分一直进行下去，直到只剩一个元素，这时这一个元素构成的最长子数组长度是 1，递归到这里就可以开始返回了。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 1) return nums[0];

        int mid = nums.length / 2;  // mid 属于 right 哦
        int[] left = new int[mid];
        int[] right = new int[nums.length - mid];
        System.arraycopy(nums, 0, left, 0, mid);
        System.arraycopy(nums, mid, right, 0, nums.length - mid);
        int maxLeft = maxSubArray(left);
        int maxRight = maxSubArray(right);
        int maxMiddle = middleMaxSum(nums, mid);

        return Math.max(Math.max(maxLeft, maxRight), maxMiddle);
    }

    private int middleMaxSum(int[] nums, int mid) {
        // 向左延展找最大子数组和
        int leftSum = Integer.MIN_VALUE;
        int leftAccu = 0;
        for (int i = mid - 1; i >= 0; i--) {
            leftAccu += nums[i];
            leftSum = Math.max(leftSum, leftAccu);
        }

        // 向右延展找最大子数组和
        int rightSum = Integer.MIN_VALUE;
        int rightAccu = 0;
        for (int j = mid; j < nums.length; j++) {
            rightAccu += nums[j];
            rightSum = Math.max(rightSum, rightAccu);
        }

        return leftSum + rightSum;
    }
}
```

分治算法的时间复杂度是 $O(n\log n)$ 。