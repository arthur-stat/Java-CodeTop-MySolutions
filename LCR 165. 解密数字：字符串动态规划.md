题目简述：

> 现有一串神秘的密文 `ciphertext`，经调查，密文的特点和规则如下：
>
> - 密文由非负整数组成
> - 数字 0-25 分别对应字母 a-z
>
> 请根据上述规则将密文 `ciphertext` 解密为字母，并返回共有多少种解密结果。

题目链接：[LCR 165. 解密数字](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

# 思路

本问题和 [91. 解码方法](https://leetcode.cn/problems/decode-ways/) 几乎是一样的，只是具体编码上不同，这里是 0-based 编码。

与 [91. 解码方法](https://leetcode.cn/problems/decode-ways/) 一样，都是显然的动态规划问题，只不过 0-based 编码会使状态转移方程较之 [91. 解码方法](https://leetcode.cn/problems/decode-ways/) 有些变化。

定义 $dp[i]$ 表示 `ciphertext[0]` 至 `ciphertext[i]` 的解密结果种数，那么
$$
dp[i]=
\left\{\begin{align}
&dp[i-2]+dp[i-1],&&ciphertext[i-1]=1\\\\
&dp[i-2]+dp[i-1],&&ciphertext[i-1]=2\,\text{ and }\,0\leqslant ciphertext[i]\leqslant 5\\\\
&dp[i-1],&&\text{Otherwise}
\end{align}\right.
$$

---

本问题中由于允许任何单字符被解释为一个字母，因此状态转移比 [91. 解码方法](https://leetcode.cn/problems/decode-ways/) 更简单。在 [91. 解码方法](https://leetcode.cn/problems/decode-ways/) 中，编码是 1-based 的，因此 `'0'` 不允许单独存在，这导致状态转移需要更多的分类讨论，稍微复杂一些。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度通过滚动数组优化至 $O(1)$。

```java
class Solution {
    public int crackNumber(int ciphertext) {
        String s = String.valueOf(ciphertext);
        int n = s.length();
        if (n <= 1) return n;

        int dp1 = 1;
        int dp2 = 1;
        int dp3 = 1;
        
        for (int i = 1; i < n; i++) {
            dp3 = (s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' && s.charAt(i) <= '5')) ? dp1 + dp2 : dp2;
            dp1 = dp2;
            dp2 = dp3;
        }

        return dp3;
    }
}
```

