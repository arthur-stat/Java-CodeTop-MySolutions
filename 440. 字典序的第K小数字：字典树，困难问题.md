题目简述：

> 给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。

题目链接：[440. 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)

# 思路

最直观的方案是回溯算法暴力搜索，因为字典序就是字典树先序遍历的顺序，但在 `1 <= k <= n <= 10^9` 的数据范围下会超时。

```java
class Solution {

    private int n;
    private int k;
    private int count;

    public int findKthNumber(int n, int k) {
        this.n = n;
        this.k = k;
        count = 0;
        for (int d = 1; d <= 9; d++) {
            int res = dfs(d);
            if(res != -1) return res;
        }
        return 666;
    }

    private int dfs(int num) {
        if (num > n) return -1;

        count++;
        if (count == k) return num;

        for (int d = 0; d <= 9; d++) {
            int res = dfs(num * 10 + d);
            if(res != -1) return res;
        }

        return -1;
    }
}
```

需要想办法解决。字典树的大部分前缀作为根节点时，子树是满十叉树，只有接近 $n$ 的路径上存在截断。我们可以利用这个性质。

想象一棵字典树，树的大部分子树是十叉树，除了虚拟根节点与被 $n$ 的限制而截断的子树。我们站在这棵字典树的其中一个节点上，在已知当前节点的字典序的情况下，如果还能知道当前节点作为根的子树有多少个节点，那么我们就能够知道要寻找目标字典序节点应当向下探索子树还是向右探索相邻节点——这里相邻节点是指节点的值上恰等于当前节点的值加一的节点。

接下来的部分是关键，因为难点就是在于如何高效算出当前节点作为根的子树一共有多少个节点。我们考虑一个定义在字典树某层上的左闭右开区间 $[l,r)$，假设当前我们正在一个值为 $prefix$ 的节点上，那么该节点的相邻节点为 $prefix+1$。在节点 $prefix$ 所在的层上，我们令 $l=prefix$、$r=prefix+1$，于是我们的区间为 $[prefix,prefix+1)$，该区间内恰好包含一个节点，即我们所在的当前值为 $prefix$ 的节点。

为计算当前节点作为根节点的子树一共有多少节点，我们沿着子树向下走。当我们走向下一层时，下一层有多少个节点呢？如果树在下一层不会被 $n$ 的限制截断，那么更新 $l$ 为子树下一层的起点、更新 $r$ 为邻居的子树的下一层的起点。由于二者均为某个节点的子树的起点，根据字典序的定义，起点应为层中最小的字典序，表现为给上一层中的 $l$ 与 $r$ 代表的节点的值加上后缀零，那么结果就是

- $l:=l\times10$
- $r:=r\times10$

因此，我们可以知道，如果当我们向下走了 $m$ 层而子树仍未被 $n$ 的限制截断，那么子树在当前层内节点的取值范围为
$$
[l\times10^m,r\times10^m)\Leftrightarrow\big[prefix\times10^m,(prefix+1)\times10^m\big)
$$
现在我们考虑向下走过 $m$ 层后发现子树被 $n$ 的限制截断的情况。不难知道被截断的子树必然位于整棵字典树的最右侧，由于字典序的定义是字典树的先序遍历顺序，因此对于某一层而言，截断只会影响靠右侧的部分节点，而不会影响靠左侧的部分节点。因此，假设向下走过 $m$ 层后发现子树被 $n$ 的限制截断，我们只需要取其中的有效值交集即可，即
$$
[l\times10^m,r\times10^m)\cap[1,n]
$$
换句话说，如果 $[l\times10^m,r\times10^m)\cap[1,n]=[l\times10^m,r\times10^m)$，则我们继续向下沿着子树走记录子树每层节点个数即可，而如果发现直到某一层有 $[l\times10^m,r\times10^m)\cap[1,n]\neq[l\times10^m,r\times10^m)$，那么意味着子树被截断，对于这一层我们只记录其中有效的节点个数即可。而且，由于现在我们只对有效节点计树，因此允许层中 $r$ 节点的值大于 $n$——只要 $l$ 节点的值仍小于等于 $n$，子树便会继续生长。这是因为与先序遍历顺序等价的字典序决定了某一节点的邻居节点被截断不会影响该节点的子节点字典序；而对于被截断的节点，它本身不会拥有继续生长的子节点，所以我们可以忽略掉它。

不断向下前进并记录每一层的有效节点数，直到在某一层发现 $l>n$，于是可以确定已经到达了子树的底，结算子树中的有效节点。

所以，我们可以设计下述算法：

```python
def subtree(prefix):
    l = prefix
    r = prefix + 1
    size = 0

    while l <= n:
        size += max(0, min(n + 1, r) - l)  # 截断有可能发生在 l 的左侧，因此应保证结果至少为 0
        l *= 10
        r *= 10
    return size
```

本问题最大的难点就在于如何设计出 `subtree()` 方法。

实现了 `subtree()` 方法后，按下述描述设计算法：从 `prefix = 1` 出发（最小字典序），每次决定向下探索子树还是向右探索邻居。当我们决定向下走时计数加一，然后 `prefix *= 10`，意味着我们走过了一个节点；当我们决定向右走时新增计数 `prefix` 子树的节点数量，然后 `prefix++`，意味着我们一次性走过了整个子数的节点。

这里有一个小细节，那就是应当将 `k` 理解为已经走过的节点数量，因此在算法开始时令 `k--`（因为我们的起始位置就是 `1`），当 `k == 0` 时终止算法，返回结果。

# 代码

算法的时间复杂度为 $O\big((\log n)^2\big)$，空间复杂度为 $O(1)$。

```java
class Solution {

    private long n;

    public int findKthNumber(int n, int k) {
        this.n = n;
        long prefix = 1;
        k--;  // 将 k 理解为已经走过的节点数

        while (k > 0) {
            // 向右走
            long nodes = subtree(prefix);
            if (nodes <= k) {
                prefix++;
                k -= nodes;
            } else {
                // 向下走
                prefix *= 10;
                k--;
            }
        }

        return (int) prefix;
    }

    private long subtree(long prefix) {
        long l = prefix;
        long r = prefix + 1;
        long size = 0;
        while (l <= n) {
            size += Math.max(0, Math.min(n + 1, r) - l);
            l *= 10;
            r *= 10;
        }
        return size;
    }
}
```

