题目简述：

> 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。
>
> 假设每一种面额的硬币有无限个。 
>
> 题目数据保证结果符合 32 位带符号整数。

题目连接：[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

# 二维 DP 思路

和 [322. 零钱兑换](https://leetcode.cn/problems/coin-change/) 不同的是，本问题中要计算的是凑成总金额的硬币组合数，而 [322. 零钱兑换](https://leetcode.cn/problems/coin-change/) 要计算的是凑成总金额所需的最少的硬币数。看起来可以考虑回溯算法，但似乎用回溯算法无法通过某些测试用例，将会超时。

既然是完全背包模型，那么我们尝试一下动态规划吧。

在明确考虑动态规划的前提下，我的第一反应是按照背包问题常见思路定义状态 $dp[i]$ 表示前 $i+1$ 种面额的硬币凑出目标金额 `amount` 的硬币组合数——但很快我就意识到这应该不可行，这样定义状态似是无法找出状态转移的，因为信息过少，$dp[i]$ 与 $dp[i+1]$ 之间不存在任何必然联系（但是，可以只定义一维状态，后文将提到如何状态压缩）。

尝试定义 $dp[i][j]$ 为前 $i+1$ 种面额的硬币凑出金额 $j$ 的硬币组合数，设 `coins` 的长度为 $n$，则问题的解为 $dp[n-1][\mathrm{amount}]$。尝试寻找状态转移。

显然，
$$
\begin{align}
dp[i][j]\ \ \ \ &=\sum_{\begin{array}{c}j-k\times\mathrm{coins}[i-1]\geqslant0\\k\geqslant0\end{array}}dp[i-1]\big[j-k\times\mathrm{coins}[i-1]\big]\\
&\\
&=\left\{\begin{aligned}&dp[i]\big[j-\mathrm{coins}[i]\big]+dp[i-1][j],&&j-\mathrm{coins}[i]\geqslant0\\\\&dp[i-1][j],&&\text{Otherwise}\end{aligned}\right.
\end{align}
$$
初始化条件一：当 $j\neq0$，
$$
dp[0][j]=1,\ \ \ \text{if }\ \ j\equiv0\pmod{\mathrm{coins}[0]}
$$
特别地，$dp[0][0]=0$

***初始化条件二：这也是关键！***
$$
\forall i,\ \ dp[i][0]=1
$$

# 二维 DP 代码

使用滚动数组优化空间开销，最终时间复杂度为 $O(n\times\mathrm{amount})$，空间复杂度为 $O(\mathrm{amount})$。

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp1 = new int[amount + 1];
        int[] dp2 = new int[amount + 1];
        dp1[0] = 1;
        dp2[0] = 1;

        for (int j = 1; j * coins[0] <= amount; j++) {
            dp1[j * coins[0]] = 1;
        }

        for (int i = 1; i < coins.length; i++) {
            for (int j = 1; j <= amount; j++) {
                dp2[j] = j - coins[i] >= 0 ? dp1[j] + dp2[j - coins[i]] : dp1[j];
            }
            dp1 = dp2;
        }

        return dp1[amount];
    }
}
```

# 状态压缩思路

我们此前考虑了变量 $i$ 表示考虑前 $i+1$​ 种硬币，这是许多背包问题的常见思路。但注意到，状态转移方程中的
$$
\left\{\begin{aligned}&dp[i]\big[j-\mathrm{coins}[i]\big]+dp[i-1][j],&&j-\mathrm{coins}[i]\geqslant0\\\\&dp[i-1][j],&&\text{Otherwise}\end{aligned}\right.
$$
分支条件 $j-\mathrm{coins}[i]\geqslant0$ 的含义正是是否使用 `coins[i]`。

那么，有没有可能我们抛开 “前 $i+1$ 种硬币” 的思路，直接定义一个一维状态呢？

我们将凑金额视为状态，直接定义 $dp[i]$ 表示所有硬币种类凑出金额 $i$ 的硬币组合数。那么，不难推导
$$
dp[i]=dp[i]+dp\big[i-\mathrm{coins}[j]\big],\ \ \text{if }i-\mathrm{coins}[j]\geqslant0
$$

枚举 $j$，最终 $dp[\mathrm{amount}]$ 即为问题的解——凑出金额 `amount` 的硬币组合数。

初始化条件：
$$
dp[0]=1
$$


---

题外话：

如果这样写状态转移方程，
$$
dp[i]=\sum_{i-\mathrm{coins}[j]\geqslant0}dp\big[i-\mathrm{coins}[j]\big]
$$
那么最终计算的就是排列数，因为隐含了任意的硬币选取顺序。

对应的代码实现为

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int i = 1; i < dp.length; i++) {  // 顺序不同的路径都被算了一次
            for (int coin : coins) {           // 外层循环为 coin 时才是计算组合数
                if (i - coin >= 0) dp[i] += dp[i - coin];
            }
        }

        return dp[amount];
    }
}
```

虽然和稍后的组合数计算代码看上去很相近，但这其实计算的是排列数。

***请务必重视并厘清！***

# 状态压缩代码

时间复杂度为 $O(n\times\mathrm{amount})$，空间复杂度为 $O(\mathrm{amount})$。

和二维 DP 算法在复杂度上是一样的，只是常数因子更小，为二维 DP 算法的一半，毕竟怎么说也是少了一维呢。

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int coin : coins) {                    // 循环嵌套顺序不能交换！
            for (int i = coin; i <= amount; i++) {  // 见上文，如果 coin 在内层循环实则计算排列数
                dp[i] += dp[i - coin];
            }
        }

        return dp[amount];
    }
}
```

尽管两份算法在复杂度上相同，但这份算法的实际时间开销和空间开销上比起第一份算法要低上几倍。
