题目简述：

> 给你一个满足下述两条属性的 `m x n` 整数矩阵：
>
> - 每行中的整数从左到右按非严格递增顺序排列。
> - 每行的第一个整数大于前一行的最后一个整数。
>
> 给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

题目链接：[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

# 思路

如果我们把这个矩阵每行拼接起来、将其展为一维向量（$1$ 行 $m\times n$ 列矩阵），那么显然该一维向量就可以视为一个单调递增数组，要判断 `target` 是否在单调数组中则直接二分搜索即可。

现在的问题是该数组被压成了多个行的矩阵，这时又如何二分搜索呢？

我们可以转变思路，首先确定出 `target` 在哪个行，即对第一列数据应用二分查找——因为每行的第一个整数严格大于前一行的最后一个整数（这意味着可以唯一确定一个 `target` 可能存在的行），确定了行以后再在该行上按列应用二分查找。这样也能做到很高效率的二分查找，而且适应特殊矩阵这一数据结构。

# 代码

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        
        // 首先在第一列上二分查找确定 target 可能所在的行
        int up = 0;
        int down = matrix.length - 1;
        while (up <= down) {
            int mid = up + (down - up) / 2;
            if (matrix[mid][0] <= target) {
                up = mid + 1;
            } else {
                down = mid - 1;
            }
        }

        // 接着在该行上再次二分查找以寻找可能的 target
        int row = down;
        if (row < 0) return false;

        int left = 0;
        int right = matrix[0].length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (matrix[row][mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        if (left >= matrix[0].length) return false;
        return matrix[row][left] == target;
    }
}
```

其中，如果不是非常熟悉下文的二分查找黄金模板及其变种中 `left` 和 `right` 的最终含义，`if (row < 0) return false;` 与 `if (left >= matrix[0].length) return false;` 是很难推导出来的，绕来绕去会把人绕晕。

# 二分查找黄金模板

- 循环条件：$\mathrm{left}\leqslant\mathrm{right}$

- 指针更新条件：`if nums[mid] < target` 时，`left = mid + 1`；否则 `right = mid - 1`

  注 1：`mid = left + (right - left) / 2`

  注 2：也可以等价地将指针更新条件细化为若 `if nums[mid] < target`，则 `left = mid + 1`；若 `if nums[mid] > target`，则 `right = mid - 1`；否则 `if nums[mid] == target`，则直接返回 `mid`。这一指针更新条件更符合直接的逻辑，实际上没有本质区别。

- 指针更新动作：都至少移动 $1$ 位！即 `left = mid + 1` 与 `right = mid - 1`

最终，当循环退出时，

- ***保证 `left` 停留在首个大于等于 `target` 的位置，即顺序动态数组中 `target` 的插入位置***；
- ***保证 `right` 停留在最后一个小于 `target` 的位置***。

按该模板实现二分查找的好处是终于不用在每次写二分查找时绞尽脑汁纠结到底是该让 `left` 至少移动一位还是让 `right` 至少移动一位以避免整数除法导致的死循环了——通通移动吧！

同时注意指针更新动作为 `left = mid + 1` 与 `right = mid - 1`，即都至少移动一位时，循环条件为 $\mathrm{left}\leqslant\mathrm{right}$；如果改为 $\mathrm{left}<\mathrm{right}$ 则 `left` 最终不会停留在首个不小于 `target` 的位置。

---

一个重要变种：

- 将指针更新条件改为：`if nums[mid] <= target` 时，`left = mid + 1` 

最终，当循环退出时，

- ***保证 `left` 停留在首个大于 `target` 的位置***；
- ***保证 `right` 停留在最后一个小于等于 `target` 的位置***。

---

另一个特殊变种：

若需要计算旋转数组最小值的索引，则将 `if nums[mid] <= target` 改为 `if nums[mid] >= nums[0]` 即可。

这里引用我在 [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 题解中给出的原理：

> 其实只要修改 “黄金模板” 中的 if-else 条件就可以直接变成旋转数组寻找最小值的模板：
>
> ```java
>  if (nums[0] <= nums[nums.length - 1]) {
>      min = 0;
>  } else {
>      while (left <= right) {
>          int mid = left + (right - left) / 2;
>          // mid 位于左半侧
>          if (nums[mid] >= nums[0]) {
>              left = mid + 1;
>          } else {
>              // mid 位于右半侧
>              right = mid - 1;
>          }
>      }
>      min = left;
>  }
> ```
>
> 原因是这里的 `if (nums[mid] >= nums[0])` 条件在 “黄金模板” 中对应 `if nums[mid] < target`。之所以直接改这一处就能直接生效，是因为他们背后的语义都是一样的：判断条件表达了目标元素（`target` 或旋转数组最小值）是否严格在 `mid` 的右侧（相对地，`mid` 严格在目标元素左侧），从而指导区间收缩方向。

# 从不变式角度系统分析二分查找

“黄金模板” 只是给出了一个标准二分查找的可以直接使用的套路，节省脑力。对于更多的二分查找变种，就需要我们进行系统性的分析，寻找算法中的不变式（invariant）了。

---

我们先来看 “黄金模板” 中的不变式，大名鼎鼎的黑皮书《算法导论》中所介绍的二分查找算法实际上就是从不变式的角度系统分析出了我所总结的 “黄金模板”，二者等价，都是考虑闭区间查找的情况，考虑的同一种不变式。

“黄金模板” 中 `left` 与 `right` 作为端点构成的区间的语义为 “搜索范围为 `left` 至 `right` 的闭区间，目标只可能存在于 `left` 至 `right` 的闭区间”，不变式蕴含于此：“在每一次循环开始时，`target` 只可能蕴含于 `left` 至 `right` 的闭区间”。

因此，在 “黄金模板” 中，循环的条件为 `while (left <= right)`，这是因为 `left == right` 时闭区间内尚存在一个元素，应当继续循环。这就是这一不变式对应的循环条件并非 `while (left < right)` 的原因。

同时，也是因为不变式的原因，当 `if nums[mid] < target` 时应更新 `left = mid + 1`，否则更新 `right = mid - 1`，而不是更新 `left = mid` 或 `right = mid`，这是因为搜索范围为闭区间，既然 `mid` 已经可以确认不满足条件，则下一轮的区间中可以排除 `mid`，这便是 “黄金模板” 中更新区间时直接令 `left = mid + 1` 或 `right = mid - 1` 的原因。

这种情况下，可以保证区间每次都是收缩的——至少收缩一个单位。

---

在同一不变式下，代码也可以有不一样的写法。比如，“黄金模板” 中循环的条件完全可以改为 `while (left < right)`，含义为搜索的闭区间内还剩一个元素时就停止，同时配套地将 `right = mid - 1` 改为 `right = mid`。

这里解释一下为什么配套的改动是必要的，当不满足 `if nums[mid] < target`，意味着存在 `if nums[mid] == target` 的可能性，此时直接令 `right = mid - 1` 就漏掉了解 `mid`。因此，如果愿意区分 `if nums[mid] < target`、`if nums[mid] > target` 以及 `if nums[mid] == target` 这三种情况，那么在 `if nums[mid] > target` 时更新 `right = mid - 1` 是正确的。若坚持二分——只判断是否有 `if nums[mid] < target`，则当不满足条件时便只能令 `right = mid`。

> 为什么在 “黄金模板” 中的写法就不怕漏掉解 `mid`？
>
> 因为 “黄金模板” 不要求解必须留在搜索区间内作为候选，仅依赖于不变式本身。换言之，这种写法依赖的是边界不变式，而不是候选解。也就是说，它只保证「`< l` 的数一定小于 target，`> r` 的数一定大于等于 target」，最后通过 `l`、`r` 的边界位置来推出答案。既然答案由边界决定，就不需要在循环过程中把等于 target 的 `mid` 留下来，只要保证不变式成立，解就一定不会丢。
>
> 而这一写法的的语义是「搜索区间本身就是候选解所在的范围」。循环在只剩一个元素时停下，而不会再去检查这个元素，所以必须保证真正的解一直留在 `[l, r]` 中。正因为如此，更新的时候如果遇到可能是解的 `mid`，就不能用 `r = mid - 1` 把它排除，只能用 `r = mid` 保留它，直到最后区间收缩到唯一的候选点。

也就是说：取条件 `while (left <= right)` 还是 `while (left < right)`，根本区别在于我们**是要靠 “边界不变式” 来锁定解，还是靠 “候选区间收敛到单点” 来得到解**。
