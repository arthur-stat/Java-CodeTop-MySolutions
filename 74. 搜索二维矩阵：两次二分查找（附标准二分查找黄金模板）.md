题目简述：

> 给你一个满足下述两条属性的 `m x n` 整数矩阵：
>
> - 每行中的整数从左到右按非严格递增顺序排列。
> - 每行的第一个整数大于前一行的最后一个整数。
>
> 给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

题目链接：[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

# 思路

如果我们把这个矩阵每行拼接起来、将其展为一维向量（$1$ 行 $m\times n$ 列矩阵），那么显然该一维向量就可以视为一个单调递增数组，要判断 `target` 是否在单调数组中则直接二分搜索即可。

现在的问题是该数组被压成了多个行的矩阵，这时又如何二分搜索呢？

我们可以转变思路，首先确定出 `target` 在哪个行，即对第一列数据应用二分查找——因为每行的第一个整数严格大于前一行的最后一个整数（这意味着可以唯一确定一个 `target` 可能存在的行），确定了行以后再在该行上按列应用二分查找。这样也能做到很高效率的二分查找，而且适应特殊矩阵这一数据结构。

# 二分查找黄金模板

- 循环条件：$\mathrm{left}\leqslant\mathrm{right}$

- 指针更新条件：`if nums[mid] < target` 时，`left = mid + 1`

  注：`mid = left + (left - right) / 2`

- 指针更新动作：都至少移动 $1$ 位！即 `left = mid + 1` 与 `right = mid - 1`

最终，当循环退出时，

- ***保证 `left` 停留在首个大于等于 `target` 的位置，即顺序动态数组中 `target` 的插入位置***；
- ***保证 `right` 停留在最后一个小于 `target` 的位置***。

按该模板实现二分查找的好处是终于不用在每次写二分查找时绞尽脑汁纠结到底是该让 `left` 至少移动一位还是让 `right` 至少移动一位以避免整数除法导致的死循环了——通通移动吧！

同时注意指针更新动作为 `left = mid + 1` 与 `right = mid - 1`，即都至少移动一位时，循环条件为 $\mathrm{left}\leqslant\mathrm{right}$；如果改为 $\mathrm{left}<\mathrm{right}$ 则 `left` 最终不会停留在首个不小于 `target` 的位置。

---

一个重要变种：

- 将指针更新条件改为：`if nums[mid] <= target` 时，`left = mid + 1` 

最终，当循环退出时，

- ***保证 `left` 停留在首个大于 `target` 的位置***；
- ***保证 `right` 停留在最后一个小于等于 `target` 的位置***。

---

另一个特殊变种：

若需要计算旋转数组最小值的索引，则将 `if nums[mid] <= target` 改为 `if nums[mid] >= nums[0]` 即可。

这里引用我在 [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 题解中给出的原理：

> 其实只要修改 “黄金模板” 中的 if-else 条件就可以直接变成旋转数组寻找最小值的模板：
>
> ```java
>     if (nums[0] <= nums[nums.length - 1]) {
>         min = 0;
>     } else {
>         while (left <= right) {
>             int mid = left + (right - left) / 2;
>             // mid 位于左半侧
>             if (nums[mid] >= nums[0]) {
>                 left = mid + 1;
>             } else {
>                 // mid 位于右半侧
>                 right = mid - 1;
>             }
>         }
>         min = left;
>     }
> ```
>
> 原因是这里的 `if (nums[mid] >= nums[0])` 条件在 “黄金模板” 中对应 `if nums[mid] < target`。之所以直接改这一处就能直接生效，是因为他们背后的语义都是一样的：判断条件表达了目标元素（`target` 或旋转数组最小值）是否严格在 `mid` 的右侧（相对地，`mid` 严格在目标元素左侧），从而指导区间收缩方向。

# 代码

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        
        // 首先在第一列上二分查找确定 target 可能所在的行
        int up = 0;
        int down = matrix.length - 1;
        while (up <= down) {
            int mid = up + (down - up) / 2;
            if (matrix[mid][0] <= target) {
                up = mid + 1;
            } else {
                down = mid - 1;
            }
        }

        // 接着在该行上再次二分查找以寻找可能的 target
        int row = down;
        if (row < 0) return false;

        int left = 0;
        int right = matrix[0].length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (matrix[row][mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        if (left >= matrix[0].length) return false;
        return matrix[row][left] == target;
    }
}
```

其中，如果不是非常熟悉二分查找黄金模板及其变种中 `left` 和 `right` 的最终含义，`if (row < 0) return false;` 与 `if (left >= matrix[0].length) return false;` 是很难推导出来的，绕来绕去会把人绕晕。
