题目简述：

> 给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。

题目链接：[[编程题]二叉树的下一个结点](https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e)

# 笨办法，但有效甚至高效

## 思路

既然给了父节点，那么最简单的方案当然就是先不断先上寻找祖宗节点，直到某个节点不再存在父节点，那么该节点即为根节点。然后，我们从根节点开始进行中序遍历的搜索，就可以找到目标节点的中序遍历下的下一个节点了。

## 代码

算法的时间复杂度为 $O(n)$，不过稍微多做了一些 $O(\log n)$ 级别时间复杂度的祖宗节点搜索。

```java
import java.util.*;
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {

    private TreeLinkNode prev;
    private TreeLinkNode pointer;
    private TreeLinkNode target;

    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        prev = null;
        pointer = null;
        target = pNode;
        TreeLinkNode root = pNode;
        while (root.next != null) root = root.next;
        return dfs(root);
    }

    private TreeLinkNode dfs(TreeLinkNode node) {
        if (node.left != null) {
            TreeLinkNode l = dfs(node.left);
            if (l != null) return l;
        }

        prev = pointer;
        pointer = node;
        if (prev == target) return pointer;

        if (node.right != null) {
            TreeLinkNode l = dfs(node.right);
            if (l != null) return l;
        }

        return null;
    }
}
```

# 更「优雅」的方案

## 思路

众所周知，二叉树的中序遍历顺序是「左 → 中 → 右」。

- 将输入节点 `pNode` 视为「中」节点，那么他的下一个节点必然位于「右」子树——如果「右」子树非空的话。按照「左 → 中 → 右」的顺序，当「右」子树存在时，下一个节点必然是「右」子树中最「左子树」的那个节点；

- 也要考虑到「右」子树不存在的情况，此时按照「左 → 中 → 右」的中序遍历顺序，我们需要判断当前节点是其父节点的左子节点还是右子节点。
  - 如果是左子节点，那么父节点就是下一个节点——按照「左 → 中 → 右」的顺序；
  - 如果是右子节点，那么我们需要继续向父节点的父节点进行探索，然后继续重复此前的判断——总之不断向上寻找祖宗节点，直到某个节点是其父节点的左子节点，那么该节点的父节点就是 `pNode` 的下一个节点。

因此，我们只需要对目标节点的右子树进行中序遍历就可以了，并不需要像第一个方案那样先找到根节点。

## 代码

算法的时间复杂度也为 $O(n)$，但大多数情况下会比第一种方案更高效，常树因子的时间开销更少。

```java
import java.util.*;
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        if (pNode.right != null) {
            Deque<TreeLinkNode> stack = new ArrayDeque<>();
            pNode = pNode.right;
            while (pNode != null || !stack.isEmpty()) {
                while (pNode != null) {
                    stack.push(pNode);
                    pNode = pNode.left;
                    continue;
                }

                return stack.pop();
            }
            return null;
        } else {
            while (pNode.next != null && pNode.next.left != pNode) {
                pNode = pNode.next;
            }
            return pNode.next;
        }
    }
}
```

