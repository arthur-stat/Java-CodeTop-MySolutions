题目简述：

> 给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。
>
> 如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。
>
> **提示：**
>
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^4`
> - `1 <= x <= 10^9`

题目链接：[1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

# 滑动窗口

## 思路

这个问题很容易联想到他应该与区间有关系，毕竟对于一个数组，我们如果选择其中一段连续的子数组保留、将剩余的左部分与右部分删除，那么这就对应了一种的操作结果。也就是说，区间与操作结果是可以一一映射的；更进一步讲，我们只需要两个指针表示区间的起始，就可以唯一双射到一种操作结果。

但如果我们遍历所有可能的两个指针的话时间复杂度为 $O(n^2)$，这在 `1 <= nums.length <= 10^5` 的数据范围下是不可接受的。

仔细思考，动态规划（区间 DP）也不可行，因为对于本问题这与遍历所有合法区间是等价的。对于本问题，子问题的解无法被高效利用，问题不存在能够加以利用的良好最优子结构。

我也尝试过贪心算法，尝试了一些贪心策略，但都失败了，无法通过全部的测试用例。

---

经过提示，知道了本问题的正确思路是考虑滑动窗口，于是豁然开朗。再仔细一看数据范围——原来解就藏在数组内元素数据范围 `1 <= nums[i] <= 10^4` 的条件中！这使得部分和具有单调性，因此我们可以考虑滑动窗口。如此重要的关键条件却没有在题干中提供以说明 `nums` 内元素均为正数，而仅仅是在数据范围中一笔带过……

依然考虑两个指针唯一确定一个区间，但我们不暴力遍历所有可能的指针，我们仅遍历右指针，将右指针初始化为指向数组的最后一个元素，然后在「在保证删除元素的总和小于 `x` 的情况下尽可能使左指针接近右指针」的规则下设置左指针。因为 `nums` 内的元素均为正数，故当右指针左移后，属于右边剩余元素的部分和将会增大，那么在我们的规则下属于左边剩余元素的部分和必然或维持不变、或减小，我们可以利用这一单调性实现滑动窗口算法，显然这样实现的算法能够保证线性时间复杂度。所花费的操作数由区间长度唯一确定，即由两个指针的位置唯一确定。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        if (x == 0) return 0;

        int i = 0;
        int sum = 0;

        // init
        while (i < nums.length && sum + nums[i] <= x) {
            sum += nums[i];
            i++;
        }

        int op = i;
        int res = Integer.MAX_VALUE;

        if (sum == x) {
            res = Math.min(res, op);
        }

        for (int j = nums.length - 2; j >= 0; j--) {
            sum += nums[j + 1];
            op++;
            while ((i > 0 && sum > x) || i > j) {
                sum -= nums[i - 1];
                i--;
                op--;
            }

            if (sum == x) {
                res = Math.min(res, op);
            }
        }

        return (res == Integer.MAX_VALUE) ? -1 : res;
    }
}
```

## 更直白的思路

可以考虑为计算满足条件 `sum(subnums) = x` 的最长子数组长度。

这样设计算法时思路会更顺畅，但两种算法在本质上是相同的，因此就不重复给出代码实现了。

# 前缀和 + 哈希表

## 思路

和滑动窗口思路类似，但我们先计算前缀和数组，然后类似「 两数之和」那样，对前缀和数组的每个元素 `presum[j]` 寻找在 `i < j` 条件下使得 `presum[j] - presum[i] = sum - x` 成立的最小 `i`（实现时我们可以对于 `presum` 值域里的每个值都只映射该值至首次出现的索引，即 `putIfAbsent`，这样就能保证 `i` 如果合法就是最小的），然后当我们遍历 `j` 时，全局 `j - i` 最大值就是区间的最大长度，那么区间外的元素数量就等于最小操作数。

上文的分析中我们有提到实际上限制就是区间的部分和——这正是前缀和数组擅长的问题。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int n = nums.length;
        int res = Integer.MAX_VALUE; 
        int sum = 0;
        for (int num : nums) sum += num;

        int[] presum = new int[n + 1];
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 0);

        for (int j = 1; j <= n; j++) {
            presum[j] = presum[j - 1] + nums[j - 1];
            map.putIfAbsent(presum[j], j);
            Integer i = map.get(presum[j] - sum + x);
            if (i != null) res = Math.min(res, n - (j - i));
        }

        return (res == Integer.MAX_VALUE) ? -1 : res;
    }
}
```

这里有一个小细节就是如果将代码中的 `for` 循环内代码调整为下面的顺序：

```java
        for (int j = 1; j <= n; j++) {
            presum[j] = presum[j - 1] + nums[j - 1];
            Integer i = map.get(presum[j] - sum + x);
            if (i != null) res = Math.min(res, n - (j - i));
            map.putIfAbsent(presum[j], j);
        }
```

那么算法在某些情况下就会漏解。必须先将值放到哈希表中再去哈希表中寻找 key，而不能反过来——除非在循环结束后为可能发生漏解的最后一次循环单独补一次 key 查询。
