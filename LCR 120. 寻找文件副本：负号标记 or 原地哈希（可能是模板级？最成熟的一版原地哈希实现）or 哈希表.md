题目简述：

> 设备中存有 `n` 个文件，文件 `id` 记于数组 `documents`。若文件 `id` 相同，则定义为该文件存在副本。请返回任一存在副本的文件 `id`。
>
> **提示：**
>
> - `0 ≤ documents[i] ≤ n-1`
> - `2 <= n <= 100000`

题目链接：[LCR 120. 寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

# 负号标记

## 思路

注意到 `0 ≤ documents[i] ≤ n-1`，那直接负数标记法或原地哈希就完了。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        int n = documents.length;

        for (int i = 0; i < n; i++) {
            int index = documents[i] >= 0 ? documents[i] : -documents[i] - 1;
            if (documents[index] >= 0) {
                documents[index] = -documents[index] - 1;
            } else {
                return index;
            }
        }

        return 666;
    }
}
```

# 原地哈希

## 思路

同样由于 `0 ≤ documents[i] ≤ n-1`，因此直接原地哈希也是可以的。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        int n = documents.length;
        int i = 0;

        while (true) {
            if (documents[i] == i) {
                i++;
                continue;
            }
            if (documents[documents[i]] == documents[i]) return documents[i];

            swap(documents, i, documents[i]);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

# 不在乎空间开销直接哈希！

## 思路

直接哈希当然也可以了，就是空间开销大点。毕竟重复值检测 / 计数本来就是哈希表擅长的。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

用 HashSet 也可以，没有本质区别。

```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        int n = documents.length;
        boolean[] visited = new boolean[n];

        for (int val : documents) {
            if (!visited[val]) {
                visited[val] = true;
            } else {
                return val;
            }
        }

        return 666;
    }
}
```

