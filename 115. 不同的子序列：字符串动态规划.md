题目简述：

> 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数。
>
> 测试用例保证结果在 32 位有符号整数范围内。

题目链接：[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

# 思路

这是一个字符串动态规划问题。但如果还要求给出结果集合，则可能回溯算法更合适。

设 $dp[i][j]$ 表示在 `s[0]` 至 `s[i]` 子串的子序列中 `t[0]` 至 `t[j]` 子串中出现的个数，则有状态转移
$$
dp[i][j]=\left\{\begin{align}&dp[i-1][j],&&s[i]\neq t[j]\\\\&dp[i-1][j]+dp[i-1][j-1],&&s[i]=t[j]\end{align}\right.
$$
我想或许不需要太多解释，看状态转移方程你一定能懂！一个很典型的字符串动态规划的状态转移。

# 代码

算法的时间复杂度为 $O(mn)$，使用滚动数组降低空间开销，空间复杂度为 $O(n)$。

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        // 滚动数组
        int[] dp1 = new int[n + 1];
        int[] dp2 = new int[n + 1];
        dp1[0] = 1;
        dp2[0] = 1;
        
        for (int i = 1; i <= m; i++) {

            for (int j = 1; j <= n; j++) {
                dp2[j] = s.charAt(i - 1) != t.charAt(j - 1) ? dp1[j] : dp1[j] + dp1[j - 1];
            }

            int[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
        }

        return dp1[n];
    }
}
```

