题目简述：

> 给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。
>
>  `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。
>
> - 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。
>
> 返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

题目链接：[30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

# 定长滑动窗口

我首先想到 AC 自动机。经提示，注意到了 `words` 中所有字符串长度均相同这一关键信息，那么就不需要 AC 自动机这样相对复杂的方案了，可以直接考虑滑动窗口。因为 `words` 内字符长度是一样的，假设均为 `n`，那一个合法的串联子串总长度是可以确定的，为 `n * m`，其中 `m` 为数组 `words` 的大小，因此我们可以设计一个尺寸为 `mn` 的滑动窗口。

可以考虑遍历所有窗口的起点，因为窗口长度是固定的，所以对于一个确定的起点，窗口的终点也能确定，然后再判断窗口内字符是否为 `words` 的串联——这可以通过分割定长子字符串然后统计子字符串的频率来实现，但这显然不是一个好办法！至多算一个可行的方案。记每个单词 `word` 的长度为 $n$、`words` 中一共有 $m$ 个单词、字符串 `s` 的长度为 $t$，则算法的时间复杂度为 $O\big(t(mn+m)\big)$。

之所以效率如此之低，是因为对每个窗口内的所有定长字符串都重新进行了分割并进行哈希统计词频，存在大量重复运算。

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int n = words[0].length();
        int m = words.length;

        int len = m * n;
        List<Integer> res = new ArrayList<>();
        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) freq.merge(word, 1, Integer::sum);
        
        for (int l  = 0; l + len <= s.length(); l++) {
            int r = l + len - 1;

            Map<String, Integer> count = new HashMap<>();
            for (int i = 0; i < m; i++) {
                count.merge(s.substring(l + i * n, l + (i + 1) * n), 1, Integer::sum);
            }

            if (count.equals(freq)) res.add(l);
        }

        return res;
    }
}
```

这时间复杂度太大了，如何改进算法呢？

# 对齐定长滑动窗口

改进的方案就是考虑对齐的滑动窗口，避免不必要的匹配。

既然窗口是定长的，那么我们可以这样做：

1. 以 `s[0]` 为起点、步长为 `n` 的窗口，
   - 先考虑窗口起点为 `s[0]`、窗口终点为 `s[mn-1]`，统计窗口内分割定长子字符串后的子字符串词频，观察是否是所希望的频数分布；
   - 然后对起点与终点分别加上 `n`，即考虑起点为 `s[n]`、终点为 `s[n+mn-1]` 的窗口，此时不需要对子字符串重新分割并全部重新统计，只需要在频数统计中移除 `s[0:n]` 的频数、加上 `s[mn:n+mn]` 的频数；
   - ……
2. 以 `s[1]` 为起点、步长为 `n` 的窗口，
   - 先考虑窗口起点为 `s[1]`、窗口终点为 `s[mn]`，统计窗口内分割定长子字符串后的子字符串词频，观察是否是所希望的频数分布；
   - 然后对起点与终点分别加上 `n`，即考虑起点为 `s[n+1]`、终点为 `s[n+mn]` 的窗口，此时不需要对子字符串重新分割并全部重新统计，只需要在频数统计中移除 `s[1:n+1]` 的频数、加上 `s[mn+1:n+mn+1]` 的频数；
   - ……
3. 以 `s[2]` 为起点、步长为 `n` 的窗口……

虽然这个描述有点简陋，但我想你能 get 到我的意思，这种滑动窗口就叫对齐滑动窗口，能够避免大量对窗口内重复元素的扫描。所谓对齐，就是靠步长对齐：窗口在这里与最初的分析没有本质上的区别，依然是宽 `mn` 的定长滑动窗口，只不过窗口不再是以步长 1 递增的，而是每次递增对齐后的值 `n`，然后再通过多个起点开始扫描，最终做到避免重复扫描的同时也能够覆盖所有情况。

算法的时间复杂度为 $\Theta\big(t(m+n)+mn^2\big)$。

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int n = words[0].length();
        int m = words.length;

        List<Integer> res = new ArrayList<>();
        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) freq.merge(word, 1, Integer::sum);

        for (int start = 0; start < n; start++) {
            int l = start;
            int r = start + m * n;
            if (r > s.length()) continue;
            Map<String, Integer> count = new HashMap<>();
            for (int i = 0; i < m; i++) {
                count.merge(s.substring(l + i * n, l + (i + 1) * n), 1, Integer::sum);
            }
            if (count.equals(freq)) res.add(l);

            while (r + n <= s.length()) {
                l += n;
                r += n;
                String prev = s.substring(l - n, l);
                if (count.merge(prev, -1, Integer::sum) == 0) count.remove(prev);
                count.merge(s.substring(r - n, r), 1, Integer::sum);
                if (count.equals(freq)) res.add(l);
            }
        }

        return res;
    }
}
```

