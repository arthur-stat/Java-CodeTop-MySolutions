题目简述：

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

题目链接：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

# 滑动窗口 + HashSet

## 思路

考虑滑动窗口（双指针的特殊情况），保证窗口内的元素不重复，尽可能使窗口更大。例如，设窗口的左端点索引为 $i$、窗口的右端点索引为 $j$，那么固定 $j$，尽可能让 $i$ 在窗口内元素不重复的情况下窗口尺寸最大，于是就可以得到每个元素作为窗口右端点时窗口的最大长度。其中，判断当前 $i$ 是否可能导致滑动窗口内元素重复的数据结构可以考虑 HashSet，用于判断某个元素在当前窗口内是否已存在。

当我们令 $j$ 遍历了每个元素后，便能覆盖所有情况——因为任何窗口一定以某个元素作为右端点，最长的窗口也不例外，进而可以得到全局最大窗口的尺寸。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(k)$，其中 $k$ 为可能出现的不同种类的字符数量。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        Set<Character> set = new HashSet<>();
        int i = 0;
        int maxSize = 0;

        for (int j = 0; j < n; j++) {
            char c = s.charAt(j);

            if (!set.contains(c)) {
                set.add(c);
                maxSize = Math.max(maxSize, j - i + 1);
            } else {
                while (true) {
                    i++;
                    char cc = s.charAt(i - 1);
                    if (cc == c) break;
                    set.remove(cc);
                }
            }
        }
        return maxSize;
    }
}
```

# 滑动窗口 + HashMap 改进

## 思路

在上一个实现方案中，当 $j$ 自增后发现当前窗口内存在重复元素时，我们是让 $i$ 也逐个递增并寻找重复元素的。

实际上，尽管 $i,j$ 均为严格单调递增的，但我们可以改 Set 为 Map，让 $i$ 的自增一步到位——用 Map 记录该字符上一次出现的位置即可，然后下次更新时让 $i$ 跳跃至该位置的下一个位置。

并且，该方案更加高效，因为我们记录的是一个元素上一次出现的位置，那么在一步到位更新 $i$ 后就不必再回头更新哈希表——因为我们所记录的是一个元素上一次出现的位置，而不再是在当前窗口内是否存在。

## 代码

这份代码在理论上常数时间开销更小i。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        Map<Character, Integer> map = new HashMap<>();
        int i = 0;
        int maxSize = 0;

        for (int j = 0; j < n; j++) {
            char c = s.charAt(j);

            if (!map.containsKey(c) || map.get(c) < i) {
                maxSize = Math.max(maxSize, j - i + 1);
            } else {
                i = map.get(c) + 1;
            }
            map.put(c, j);
        }
        return maxSize;
    }
}
```

