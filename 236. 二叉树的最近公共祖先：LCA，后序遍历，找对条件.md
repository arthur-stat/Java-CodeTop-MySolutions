题目简述：

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
> 
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

题目链接：[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

> Note: 本问题属于最近公共祖先（LCA）问题，给定了二叉树的根节点与两个目标节点作为输入，树的定义符合标准二叉树，即每个节点包含两个子节点指针、不包含父节点指针，区别于节点包含父节点指针但输入未给出根节点的 [1650. 二叉树的最近公共祖先 III](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/description/)。在 2025/11/27 的字节日常实习一面里考察了我后一个问题，我起初一度以为是本问题——毕竟在 CodeTop 上，本问题恰位于按频率降序题单的首页（Top 19），截止至 2025/11/28 在 CodeTop 上记录在案的考察频数是 254 次，而后者有记录的考察频数却是 1……虽然我截止至今天已经解决了接近 500 道力扣算法，但考这样一道冷门题（至少在 Top 1000+）还是让我几乎没有任何准备，没有想出来正确解法。当然，在读到题目感到部分条件有些陌生却依然尝试按照印象里的题目求解（中途被面试官指出并纠正）是一个问题，同时有一两个月没有复习算法了也是一个重要原因，这是我的问题

# 思路

本问题有标准的最佳解决方案，考虑后序遍历：

- 如果后序遍历顺序下发现了首个左右子树同时存在目标节点的节点，则该节点为 LCA；
- 如果其中一棵子树存在目标节点、另一树不存在目标节点，
  - 若当前节点恰为另一个目标节点，则该节点为 LCA；
  - 若当前节点非目标节点，则只能肯定当前节点不是 LCA，需要继续进行后序遍历。

其中，判断子树是否存在目标节点的信息可以通过递归返回值（或迭代显式栈）传递：

- 如果当前节点为 LCA，返回 LCA；
- 如果子搜索传递了 LCA，返回 LCA；
- 如果当前节点非 LCA 但其中一个子搜索从一棵子树中发现了目标节点，返回目标节点；
- 否则返回空值，表示子搜索与当前节点中均未发现 LCA。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(\log n)$，其中空间复杂度主要来自于递归栈的开销。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return dfs(root, p, q);
    }

    /**
     * 后序遍历：
     *  - 如果左右子树中分别存在一个目标节点，则（后续遍历中的首个）该节点即为 LCA；
     *  - 如果其中一个子树存在一个目标节点且当前节点为另一个目标节点，则该节点为 LCA。
     */
    private TreeNode dfs(TreeNode node, TreeNode p, TreeNode q) {
        // case 0: p == q -> 直接返回
        if (p == q) return p;
        if (node == null) return null;

        TreeNode l = dfs(node.left, p, q);
        TreeNode r = dfs(node.right, p, q);

        // case 1: 如果左右子树同时返回了目标节点 p 与 q，则当前节点即为 LCA，返回当前节点
        if ((l == p && r == q) || (l == q && r == p)) return node;

        // case 2: 如果其中一棵子树的递归搜索返回值非空且既不是 p 亦不是 q，意味着该返回值即 LCA（传递 case 1）
        if (l != null && l != p && l != q) return l;
        if (r != null && r != p && r != q) return r;

        // case 3: 如果有且仅有其中一个递归搜索子树返回了目标节点 p 或 q，考察当前节点是否可能为 LCA
        if (l == p || l == q || r == p || r == q) {
            // case 3-1: 如果当前节点为其中一个目标节点，意味着当前节点即为 LCA
            if (node == p || node == q) return node;
            // case 3-2: 否则，只有一棵子树搜索到了一个目标节点，返回该目标节点
            if (l != null) return l;
            else return r;
        }

        // case 4: 子树的递归搜索均未查询到目标节点，但当前节点为目标节点，返回当前节点
        if (node == p || node == q) return node;
        
        // case 5: 否则返回 null，意味着没有后序遍历截至至此没有找到目标节点
        return null;
    }
}
```