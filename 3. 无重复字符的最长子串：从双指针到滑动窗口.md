题目简述：

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

题目连接：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

# 哈希表 + 双指针（初见想法）

## 思考

最初我的想法是利用哈希表和双指针。

设置 $i$、$j$ 两个指针，$j$ 作为主循环指针，$i$ 作为当子串以 $s[j]$ 结尾的最长重复子串的首字符索引。为了记录全局最长无重复子串，设置 $n2$、$n1$，分别对应全局最长无重复子串的 $i$、$j$。

这样，只需要维护一个哈希表：哈希表初始化全为 $0$，当 $j$ 自增一时，

- 如果 $s[j]$ 作为键在表中的值为 $0$，则说明以 $s[j]$ 结尾的最长无重复子串长度是以 $s[j-1]$ 结尾的最长无重复子串长度加一，让哈希表中该值为 $1$ 表示该字符在目前子串中已存在，并判断是否需要更新 $n1$、$n2$；
- 如果 $s[j]$ 作为键在表中的值为 $1$，则说明以 $s[i]$ 起始、以 $s[j]$ 结束的子串存在重复，$s[j]$ 的字面量一定重复，与 $s[j]$ 字面量重复的那个字符的索引可能是 $i$ 至 $j-1$ 中的任何一个，这时倒序遍历，直到找出那个重复字符。遍历前先重置哈希表，并在遍历时重新维护哈希表，把非重复元素作为键对应的值赋为 $1$ 表示该元素在以 $s[j]$ 结尾的最长无重复子串中已存在。

这个做法的内存开销很小，空间复杂度是 $O(1)$，主要就一个哈希表，考虑到字符串只由英文字母、数字、符号和空格构成，其实还可以再缩短哈希表的长度，但没必要。问题是时间开销相对较大，重复不多或者分散没有明显规律情况下时间复杂度是 $O(n)$，但最坏情况时间复杂度有 $O(n^2)$。

以下为错误思路，我起初就这样被绕进去了，注意比较和正确思路的不同并避坑：

>s设置 i、j 两个指针，j 作为主循环指针，i 作为当子串以 s[j] 结尾的最长无重复子串的首字符索引。为了记录全局最长无重复子串，设置 n2、n1，分别对应全局最长无重复子串的 i、j。
>
>这样，只需要维护一个哈希表：哈希表初始化全为 0，当 j 自增一时，
>
>- 如果 s[j] 作为键在表中的值为 0，则说明以 s[j] 结尾的最长无重复子串长度是以 s[j-1] 结尾的最长无重复子串长度加一，让哈希表中该值为 1 表示该字符在目前子串中已存在，并判断是否需要更新 n1、n2；
>- 如果 s[j] 作为键在表中的值为 1，则说明以 s[i] 起始、以 s[j] 结束的子串存在重复，而且重复的字符必然是 s[i] 和 s[j]，为了保证 i 的意义仍然是无重复以 s[j] 结尾的最长无重复子串的首字符索引，需要让 i 自增一。

## Java代码

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {return 0;}
        int[] table = new int[128];
        int i = 0, n1 = 0, n2 = 0;

        for (int j = 0; j < s.length(); j++) {
            if (table[(int) s.charAt(j)] == 0) {
                table[(int) s.charAt(j)] = 1;
                if (j - i > n1 - n2) {
                    n1 = j;
                    n2 = i;
                }
            } else {
                Arrays.fill(table, 0);
                table[(int) s.charAt(j)] = 1;
                int k;
                for (k = j - 1; s.charAt(k) != s.charAt(j); k--) {
                    table[(int) s.charAt(k)] = 1;

                }

                if (s.charAt(j-1) == s.charAt(j) ) {
                    i = j;
                } else {
                    i = k + 1;
                }
            }
        }

        return n1 - n2 + 1;
    }
}
```

# 经典滑动窗口

前解法中的哈希表是二值的，要么是 $0$ 要么是 $1$，而且一直在不断重置哈希表再从 $j$  开始倒序遍历以维护重置后的哈希表，这是导致算法慢吞吞的罪魁祸首。

经典的滑动窗口时间复杂度是 $O(1)$ 的，应该利用好哈希表（而不只是利用二值），直接记录元素最后出现的位置，这样不需要倒序遍历可以直接让 $i$ 跳转。而且这样也不需要一直重置数组了，因为这时哈希表表示的不仅仅是当前以 $s[j]$ 结尾的最长无重复子串的信息，而是随着 $j$ 增大不断更新的整个字符串的信息。其实我想到了这一点，但最后实现时没做，我还以为是我想复杂了。现在看来还是经验太少。

而且，看了别人的解答，就算是要遍历，也是从 $i$ 开始顺序遍历维护哈希表更合乎直观一点，虽然这样跟倒序遍历没本质区别，都嵌套了 `for` 循环。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) return 0;

        Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        int left = 0; // 窗口左边界

        for (int right = 0; right < s.length(); right++) {
            char ch = s.charAt(right);
            // 当遇到重复字符，且该字符的位置在窗口内时，更新左边界
            if (map.containsKey(ch) && map.get(ch) >= left) {
                left = map.get(ch) + 1; // 直接跳到重复字符的下一个位置
            }
            map.put(ch, right); // 更新字符的最新位置
            maxLen = Math.max(maxLen, right - left + 1); // 计算当前窗口长度
        }
        return maxLen;
    }
}
```

