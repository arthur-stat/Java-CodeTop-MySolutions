题目简述：

> 给定两个由一些 **闭区间** 组成的列表，`firstList` 和 `secondList` ，其中 `firstList[i] = [starti, endi]` 而 `secondList[j] = [startj, endj]` 。每个区间列表都是成对 **不相交** 的，并且 **已经排序** 。
>
> 返回这 **两个区间列表的交集** 。
>
> 形式上，**闭区间** `[a, b]`（其中 `a <= b`）表示实数 `x` 的集合，而 `a <= x <= b` 。
>
> 两个闭区间的 **交集** 是一组实数，要么为空集，要么为闭区间。例如，`[1, 3]` 和 `[2, 4]` 的交集为 `[2, 3]` 。

题目链接：[986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)

# 思路

考虑双指针。

预先保证 `A`、`B` 的区间均按左端点排序（题目已确保了这点），然后用两个指针指向 `A`、`B` 的两个区间，接着判定两区间知否相交：如果最晚开始的区间起点大于最早结束区间的终点，那么两区间就不可能相交，而且最早结束的区间不可能与剩余的所有区间相交，因此指向该区间的指针向后移动一位以指向下一个区间。

否则，如果两区间相交，则相交区间的起始点就是最晚开始区间的起点、相交区间的终点就是最早结束区间的终点。然后更新指针，最早结束的区间已经不可能与剩余所有区间相交，所以指向该区间的指针向后移动一位以指向下一个区间。

# 代码

算法的时间复杂度为 $O(m+n)$，抛开结果数组的开销空间复杂度为 $O(1)$。

代码可以写得很简洁，例如：

```java
class Solution {
    public int[][] intervalIntersection(int[][] A, int[][] B) {
        List<int[]> res = new ArrayList<>();
        int i = 0, j = 0;
        while (i < A.length && j < B.length) {
            int lo = Math.max(A[i][0], B[j][0]);
            int hi = Math.min(A[i][1], B[j][1]);
            if (lo <= hi) res.add(new int[]{lo, hi});
            if (A[i][1] < B[j][1]) i++;
            else j++;
        }
        return res.toArray(new int[res.size()][]);
    }
}
```

只是像下面这样分类讨论的写法更不用脑子。

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List<int[]> res = new ArrayList<>();
        int m = firstList.length;
        int n = secondList.length;
        int i = 0;
        int j = 0;

        while (i < m && j < n) {
            // firstList 的区间起始点更靠近左侧
            if (firstList[i][0] < secondList[j][0]) {
                // 无相交
                if (secondList[j][0] > firstList[i][1]) {
                    i++;
                    continue;
                }

                // firstList 的区间比 secondList 的区间更早结束
                if (firstList[i][1] < secondList[j][1]) {
                    res.add(new int[]{secondList[j][0], firstList[i][1]});
                    i++;
                } else {
                    // secondList 的区间比 firstList 的区间更早结束
                    res.add(new int[]{secondList[j][0], secondList[j][1]});
                    j++;
                }
            // secondList 的区间起始点更靠近左侧
            } else {
                // 无相交
                if (firstList[i][0] > secondList[j][1]) {
                    j++;
                    continue;
                }

                // secondList 的区间比 firstList 的区间更早结束
                if (secondList[j][1] < firstList[i][1]) {
                    res.add(new int[]{firstList[i][0], secondList[j][1]});
                    j++;
                } else {
                    // firstList 的区间比 secondList 的区间更早结束
                    res.add(new int[]{firstList[i][0], firstList[i][1]});
                    i++;
                }
            }
        }

        return res.toArray(new int[res.size()][]);
    }
}
```

