题目简述：

> 给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **最多两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。
>
> 你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间（不包括存储输出所需的空间）的算法解决此问题。

题目链接：[442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

# 原地哈希

更推荐标记法！只是说这个问题也可以考虑原地哈希，而且这样很有趣。

## 思路

如果考虑哈希问题，那么其姊妹问题为 [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)。由于 `nums` 里的元素存在取值范围，因此可以直接把 `nums` 当哈希表用。

具体而言，我们让元素的值与其索引相对应，索引上存在元素者赋值 0（因为所有元素的值均为正数）。然后我们设计一个 `hash` 原地哈希映射，该映射保证：

- 如果元素的值恰与索引对应，例如元素 [2, 1, 3, 1] 中元素 3 恰位于相应的索引 3 - 1 上，则无需任何动作；
- 如果元素的值未与索引对应，则我们希望进行哈希映射，使得元素的值恰与索引对应。
  - 假设与元素的值相对应的索引上已经存在一个元素，且该元素的值恰与索引对应，意味着我们当前研究的元素不是该字面量的首个元素，根据题意即出现第二次的整数，因此我们在记录结果后对该元素所在的索引赋 0，表示移除该元素；
  - 假设与元素的值相对应的索引上不存在任何元素，即值为 0，则直接将该元素映射过去即可，为目标索引赋值当前元素的值，再为该元素原本的索引赋 0 表示移除元素，这里实际上体现的是交换（swap）的逻辑；
  - 否则，意味着我们可以先交换该元素与目标索引上的元素，这样该元素就被映射到了正确的位置上，但我们必须继续着手处理被交换的元素，因为他可能不在正确的索引位置上。这里蕴含了状态机的思想，即下文代码中的 `hash(x)`。

最终，每个元素至多被处理两次。

但原地哈希分析起来有点繁复，我面向测试用例 debug 编程数次后才让代码 AC。对于这个问题，其实也有更简单的办法，我们在下文介绍。无论如何，原地哈希的思路还是挺有趣且巧妙的。

## 代码

算法的时间复杂度为 $O(n)$，抛开递归栈以外空间复杂度为 $O(1)$。由于递归栈的开销，可以考虑迭代实现，但这样就更麻烦了。

```java
class Solution {

    int[] nums;
    List<Integer> res;

    public List<Integer> findDuplicates(int[] nums) {
        this.nums = nums;
        res = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            hash(i);
        }
        return res;
    }

    private void hash(int x) {
        int y = nums[x];

        if (y == x + 1) return;
        
        if (nums[y - 1] == y) {
            res.add(y);
            nums[x] = 0;
        } else if (nums[y - 1] == 0) {
            nums[y - 1] = y;
            nums[x] = 0;
        } else {
            int tmp = nums[y - 1];
            nums[y - 1] = y;
            nums[x] = tmp;
            hash(x);
        }
    }
}
```

# 负号标记法（更推荐！）

## 思路

标记法也会巧妙地利用数组内元素范围的条件，更重要的是巧妙利用了重复元素的字面量值相同，因此映射后也相同。从性能上来说，标记法不存在递归栈的空间开销，严格符合要求 “仅使用常量额外空间”。

标记法的核心是：对于数组中的重复的两个值，将他们的值作为索引再次映射到数组中，得到的一定是同一个索引；而数组中不同的两个值，将他们的值作为索引再次映射到数组中，得到的一定不是同一个索引。虽然这听上去可能是废话——关键是将值作为索引的有映射是一一映射，构成双射关系。

因此，每当我们访问到一个新的值 $a$ 时，首先为这个值取绝对值 $|a|$（至于为什么要取绝对值，是因为稍后我们用负号标记访问），然后将该绝对值作为索引，寻找映射到的索引对应的元素 $b$。如果元素 $b$ 为正数，则认为这是首次访问到 $a$，于是令 $b$ 取其相反数以表示我们访问了一次 $a$ 的字面量；否则，如果元素 $b$ 为负数，则认为这是第二次访问到 $a$，于是将 $a$ 加入到结果集中。

该方法利用值与索引的一一映射巧妙地解耦了值与索引，通过将值作为索引，能够判断我们是否已访问过该值，但又不影响后续该值继续作为值或是直接作为索引被使用（这就是此前取绝对值的意义）。相反，反观我们此前的原地哈希算法，虽然非常精妙，但没有做到这样的解耦合，导致逻辑相对复杂。看——这样多简单？

## 代码

看，比起原地哈希算法复杂的状态机模型，逻辑上是不是非常简单？

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();

        for (int num : nums) {
            int index = Math.abs(num) - 1;

            if (nums[index] < 0) {
                res.add(Math.abs(num));
            } else {
                nums[index] *= -1;
            }
        }

        return res;
    }
}
```

