题目简述：

> 给定两个长度相等的数组 `nums1` 和 `nums2`，`nums1` 相对于 `nums2` 的*优势*可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述。
>
> 返回 `nums1` 的 **任意** 排列，使其相对于 `nums2` 的优势最大化。

题目链接：[870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)

# 思路

像田忌赛马那样考虑贪心算法，我们遍历 `nums2` 来填充对应位置的 `nums1`：

1. 贪心策略一：如果 `nums1` 中未使用元素已经不存在比 `nums2[i]` 更大的元素了，我们就使用 `nums1` 的未使用元素中的最小元素填充当前位置；

2. 贪心策略二：否则，我们使用恰比 `nums2[i]` 更大的最小未使用元素填充 `nums1` 的当前位置。

一个核心思想，就是 “尽可能用更小的成本、为未来保留更多选择的情况下，增大 `nums1` 的优势”，有一些田忌赛马的感觉。

# 红黑树实现

按上述逻辑，比较直观的实现是考虑自平衡二叉查找树。在 Java 中，`TreeSet` 的底层是红黑树的实现，这能够让我们以 $O(1)$ 的时间复杂度找到最大元素与最小元素（对应贪心策略一），同时也能帮助我们以 $O(\log n)$ 的时间复杂度找到首个大于 `nums2[i]` 的 `nums1` 中的未使用元素（对应贪心策略二）。同样重要的是，红黑树的底层实现使得我们能够以 $O(\log n)$ 的时间复杂度删除一个树中的元素以表示「该元素以在 `nums1` 的再填充中被使用」，那么树中的元素自然也就是「`nums1` 中的未使用元素」了。

以上三点是我们可以考虑 `TreeSet` 的底层逻辑。

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
record Pair(int val, int index) {}

class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        TreeSet<Pair> tree = new TreeSet<>((a, b) -> {
            int res = Integer.compare(a.val(), b.val());
            if (res != 0) return res;
            return Integer.compare(a.index(), b.index());
        });

        for (int i = 0; i < n; i++) tree.add(new Pair(nums1[i], i));
        
        for (int i = 0; i < n; i++) {
            if (tree.last().val() <= nums2[i]) {
                nums1[i] = tree.removeFirst().val();
            } else {
                Pair p = tree.higher(new Pair(nums2[i], n));
                tree.remove(p);
                nums1[i] = p.val();
            }
        }

        return nums1;
    }
}
```

# 双指针实现

`TreeSet` 当然也不错，但他显得太「重」了，对于这样相对较「轻」的一个算法问题，我们一定还有其他的方案——这一方案就是双指针。

要改为双指针的实现，针对上文的直接逻辑，我们需要进行一些修改。

双指针的关键是有序性，我们需要对 `nums1` 与 `nums2` 排序，但我们在洗牌过程中是依赖于 `nums2` 的原有顺序的（因为要尽可能使原有位置对应的洗牌后数组 `res` 相比原 `nums2` 保持优势），因此可以考虑对 `nums2` 的索引数组 `idx` 按值排序。然后置两个指针 `i`、`j` 分别于排序后 `nums1` 的首位置与排序后 `nums2` 的索引数组 `idx` 上，在 `i` 循环内遍历填充结果数组 `res`，考虑下述流程：

- 如果 `nums1[i] > nums2[idx[j]]`，则直接令 `res[idx[j]] = nums1[i]` 即可，`i++`、`j++`；
- 如果 `nums1[i] <= nums2[idx[j]]`，那么我们就让 `nums1[i]` 去匹配 `nums2` 的最大值，即 `idx[len-1]`，令 `res[idx[len-1]] = nums1[i]`，然后 `idx` 逻辑长度 `len--`、`i++`，而 `j` 保持不变。

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$，其中时间复杂度主要来自于排序算法。

```java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        Integer[] idx = new Integer[n];
        Arrays.setAll(idx, i -> i);
        Arrays.sort(idx, (i, j) -> Integer.compare(nums2[i], nums2[j]));
        Arrays.sort(nums1);
        int[] res = new int[n];
        int idxLen = n;

        int j = 0;
        for (int i = 0; i < n; i++) {
            if (nums1[i] > nums2[idx[j]]) {
                res[idx[j]] = nums1[i];
                j++;
            } else {
                res[idx[idxLen - 1]] = nums1[i];
                idxLen--;
            }
        }

        return res;
    }
}
```