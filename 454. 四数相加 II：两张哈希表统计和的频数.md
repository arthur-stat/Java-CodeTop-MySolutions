题目简述：

> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
>
> - `0 <= i, j, k, l < n`
> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

题目链接：[454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

# 思路

本问题比起 [18. 四数之和](https://leetcode.cn/problems/4sum/)，不同点在于四数之和分别是不同数组上的，而不是同一个数组上的。

如果是 [18. 四数之和](https://leetcode.cn/problems/4sum/) 这样四个数在同一个数组上的情况，考虑双指针，通过固定其中一个指针降维成 [15. 三数之和](https://leetcode.cn/problems/3sum/)，而三数之和的解法就是经典的双指针了。

直接暴力求解的时间复杂度为 $O(n^4)$。对于本问题，由于四个数字分别在不同数组上，我们知道固定了和时，三个数字能够唯一确定第四个数字，因此可以对 `nums4` 的值域用哈希表计数，然后再针对剩下的三个数组考虑遍历所有可能的解，这样算法的时间复杂度为 $O(n^3)$——在测试平台给定的数据范围 `1 <= n <= 200` 下这似乎并不是很好的方案。

我们能给出 $O(n^2)$ 时间复杂度的算法吗？

---

能的兄弟，能的。

我们分别用一张哈希表存储 `nums1` 的所有元素与 `nums2` 的所有元素组合的和（并映射至和的频数），再用一张哈希表存储 `nums3` 的所有元素与 `nums4` 的所有元素组合的和（并映射至和的的频数），然后遍历其中一个哈希表，判断 key 的相反数是否存在于另一张哈希表中，如果存在则两个频数的乘积就是满足 `nums1[a] + nums2[b] = key`、`nums3[c] + nums4[d] = -key`（从而满足 `nums1[a] + nums2[b] + nums3[c] + nums4[d] = 0`）的不同四元组 `(a, b, c, d)` 的数量。

这样的话，我们分别遍历 `nums1` 与 `nums2` 内所有元素的组合以及遍历 `nums3` 与 `nums4` 内所有元素的组合的时间复杂度为 $O(n^2)$，对两张结果哈希表再遍历的时间复杂度为 $O(n)$，于是总的时间复杂度为 $O(n^2)$。

# 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int n = nums1.length;
        Map<Integer, Integer> count1 = new HashMap<>();
        Map<Integer, Integer> count2 = new HashMap<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                count1.merge(nums1[i] + nums2[j], 1, Integer::sum);
                count2.merge(nums3[i] + nums4[j], 1, Integer::sum);
            }
        }

        int res = 0;
        for (var e1 : count1.entrySet()) {
            Integer f2 = count2.get(-e1.getKey());
            if (f2 != null) res += e1.getValue() * f2;
        }

        return res;
    }
}
```

