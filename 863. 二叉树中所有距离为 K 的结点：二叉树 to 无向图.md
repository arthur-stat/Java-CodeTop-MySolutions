题目简述：

> 给定一个二叉树（具有根结点 `root`）， 一个目标结点 `target` ，和一个整数值 `k` ，返回到目标结点 `target` 距离为 `k` 的所有结点的值的数组。
>
> 答案可以以 **任何顺序** 返回。
>
> **提示:**
>
> - `Node.val` 中所有值 **不同**

题目链接：[863. 二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)

# 无向图（BFS）

## 思路

考虑前序遍历，对于不同的 `target`，除了 `k = 0` 以外，只可能有两种情况：

1. 符合条件的节属于 `target` 作为根节点的子树；
2. 符合条件的节不属于 `target` 作为根节点的子树。

针对第一种情况，前序遍历 DFS 即可，由于 DFS 会先找到 `target`，因此记录层数，当前节点层数减去 `target` 的层数，得到的就是当前节点到 `target` 的距离。

针对第二种情况该怎么办呢？This is a question.

---

一个简单且直观的思路是构建图，为每个子节点绑定其父节点——这样就构成一个无向图，父子节点地位平等，然后进行 BFS 即可。

由于这里的无向图并不复杂，因此可以不建邻接表，仅用一个哈希表存储各节点的父指针。

要注意的是，为了保证不走回头路，需要一个办法记忆访问状态，可以考虑 HashSet。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        if (root == null) return null;
        Map<TreeNode, TreeNode> parents = new HashMap<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        TreeNode targetNode = null;

        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();

            if (node.right != null) {
                parents.put(node.right, node);
                stack.push(node.right);
            }

            if (node == target) targetNode = node;

            if (node.left != null) {
                parents.put(node.left, node);
                stack.push(node.left);
            }
        }

        // BFS
        Deque<TreeNode> queue = new ArrayDeque<>();
        Set<TreeNode> visited = new HashSet<>();
        queue.offer(targetNode);
        visited.add(targetNode);
        int layerNum = 1;
        int order = 0;

        while (!queue.isEmpty() && order < k) {
            TreeNode node = queue.poll();
            layerNum--;
            if (node.left != null && !visited.contains(node.left)) {
                queue.offer(node.left);
                visited.add(node.left);
            }
            if (node.right != null && !visited.contains(node.right)) {
                queue.offer(node.right);
                visited.add(node.right);
            }
            TreeNode parent = parents.get(node);
            if (parent != null && !visited.contains(parent)) {
                queue.offer(parent);
                visited.add(parent);
            }

            if (layerNum == 0) {
                layerNum = queue.size();
                order++;
            }
        }

        return queue.stream().map(node -> node.val).toList();
    }
}
```

# 隐式无向图（DFS）

这个方法理解上要苦难一点。

## 思路

先显式构建无向图再 BFS 是非常直观的方案，但实际上也可以利用 DFS 的深度优先性质与二叉树的特性隐式地构建无向图，至多一次遍历即可找出所有与 `target` 距离为 `k` 的结点。

前文有分析到，如果符合条件的节点是 `target` 的子节点，那么这是很容易实现的，搜索时记录深度即可。

我们需要重点关注的是如何解决符合条件的节点并非 `target` 的子节点的情况。针对此情形，可以让递归 DFS 在回溯返回值中携带与目标节点距离的信息，具体这样设计：

- DFS 方法的返回值为当前节点到 `target` 的距离；
- 在 DFS 的回溯方法内，分别判定当前节点是否为 `target`、`target` 是否在左子树以及 `target` 是否在右子树；
  - 若 `target` 为当前节点，直接返回 `0`；
  - 若 `target` 位于左子树，则返回左子节点递归调用返回值加一，且左子节点递归调用返回值等于 `k` 时记录当前节点；
  - 若 `target` 位于右子树，则返回右子节点递归调用返回值加一，且右子节点递归调用返回值等于 `k` 时记录当前节点；
  - 若 `target` 不位于当前节点的任何一颗子树内，则暂时不做处理，可以返回一个无效值，例如 `-1` 或 `Integer.MAX_VALUE`;
  - 注意，我们不在此处处理符合条件的子节点情况，我们将在另一个方法中单独执行这一逻辑。
- 对于回溯路径上的节点，当返回值有效时，开始向下进行*附属 DFS*，具体来说：若 `target` 位于当前节点左子树，则探索右子树中可能满足条件的节点，并且记右子节点到 `target` 的距离为 `target` 到当前节点的距离加一；若 `target` 位于当前节点右子树，则探索左子树中可能满足条件的节点，并且记左子节点到 `target` 的距离为 `target` 到当前节点的距离加一。当*附属 DFS* 探索过程中确认了 `target` 到某节点距离为 `k`，则记录该节点，同时不再继续向下探索。

这是一个典型的递归方法设计。当然，既然可以递归实现，那么理论上也可以改为显式栈，不过这里就只以递归实现为例了。

## 代码

```java
class Solution {

    private List<Integer> res;
    private TreeNode target;
    private int k;

    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        res = new ArrayList<>();
        this.target = target;
        this.k = k;

        dfs1(root);
        dfs3(target, 0);
        return res;
    }

    // dfs1：找出所有符合条件的非子节点
    private int dfs1(TreeNode node) {
        if (node == target) return 0;

        int distanceLeft = -1;
        if (node.left != null) {
            distanceLeft = dfs1(node.left);
            if (distanceLeft != -1) distanceLeft++;
        }
        if (distanceLeft != -1) {
            if (distanceLeft == k) res.add(node.val);
            if (node.right != null) dfs2(node.right, distanceLeft + 1);
            return distanceLeft;
        }

        int distanceRight = -1;
        if (node.right != null) {
            distanceRight = dfs1(node.right);
            if (distanceRight != -1) distanceRight++;
        }
        if (distanceRight != -1) {
            
            if (distanceRight == k) res.add(node.val);
            if (node.left != null) dfs2(node.left, distanceRight + 1);
            return distanceRight;
        }


        return -1;
    }

    // dfs2：dfs1 的附属 dfs
    private void dfs2(TreeNode node, int distance) {
        if (distance == k) {
            res.add(node.val);
            return;
        }

        if (node.left != null) {
            dfs2(node.left, distance + 1);
        }

        if (node.right != null) {
            dfs2(node.right, distance + 1);
        }
    }

    // dfs3：找出所有符合条件的子节点
    private void dfs3(TreeNode node, int depth) {
        if (depth == k) {
            res.add(node.val);
            return;
        }

        if (node.left != null) {
            dfs3(node.left, depth + 1);
        }

        if (node.right != null) {
            dfs3(node.right, depth + 1);
        }
    }
}
```

