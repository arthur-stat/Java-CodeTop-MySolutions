题目简述：

> 有两个水壶，容量分别为 `x` 和 `y` 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 `target` 升。
>
> 你可以：
>
> - 装满任意一个水壶
> - 清空任意一个水壶
> - 将水从一个水壶倒入另一个水壶，直到接水壶已满，或倒水壶已空。

题目链接：[365. 水壶问题](https://leetcode.cn/problems/water-and-jug-problem/)

# 无权有向图的遍历搜索

## 思路

定义当前两个两个水壶内盛有的水容积分别为 $(v1,v2)$，将 $(v1,v2)$ 视为状态，那么 $(v1,v2)$ 的下一个状态至多可能有 6 种，分别为：

1. 装满第一个水壶，$(x,v2)$
2. 装满第二个水壶，$(v1,y)$
3. 清空第一个水壶，$(0,v2)$
4. 清空第二个水壶，$(v1,0)$
5. 将第一个水壶的水倒入第二个水壶，$\big(v1-\min(v1,y-v2),v2+\min(v1,y-v2)\big)$
6. 将第二个水壶的水倒入第一个水壶，$\big(v1+\min(v2,x-v1),v2-\min(v2,x-v1)\big)$

于是，显然所有的状态构成一张有向图。我们只需要遍历该有向图以搜索是否存在满足解的节点。

只不过在这一过程中需要避免循环路径，我们可以使用一张哈希表存储已访问过的节点。这是因为该有向图本身是完全被允许也很可能存在循环路径的，但我们的目的仅仅是遍历所有节点，所以如果发现访问到了一个此前已访问过的节点时直接结束这一探索分支即可。

就算从该节点出发能够搜索到一个解节点，那到达解节点的路径也不可能是这条路径，因为该路径已经能够确认是循环路径且路径上不存在解了，因此解节点必然存在于自该节点出发的其他路径上——而在上一次到达该节点时，我们一定会访问其所有可能的下一个状态，因此再次到达该节点时，我们就可以安心地剪枝了，可以保证这不会造成漏解。

针对本问题，可以考虑 DFS，也可以考虑 BFS——只要能遍历搜索有向图中的所有节点即可。如果还要求给出最少操作次数，那么这就是一个有向图的无权最短路问题了，此时最好考虑 BFS。

## 代码

这是 DFS 的实现，算法的时间复杂度为 $O(xy)$，空间复杂度为 $O(xy)$。

```java
class Solution {

    private Set<Long> visited;
    private int target;
    private int x;
    private int y;

    public boolean canMeasureWater(int x, int y, int target) {
        visited = new HashSet<>();
        this.target = target;
        this.x = x;
        this.y = y;
        return dfs(0, 0);
    }

    private boolean dfs(int v1, int v2) {
        if (v1 + v2 == target) return true;
        if (visited.contains(zip(v1, v2))) return false;
        visited.add(zip(v1, v2));

        // 装满第一个水壶
        if (dfs(x, v2)) return true;

        // 装满第二个水壶
        if (dfs(v1, y)) return true;

        // 清空第一个水壶
        if (dfs(0, v2)) return true;

        // 清空第二个水壶
        if (dfs(v1, 0)) return true;

        // 将第一个水壶的水倒入第二个水壶
        int diff1 = Math.min(y - v2, v1);
        if (dfs(v1 - diff1, v2 + diff1)) return true;

        // 将第二个水壶的水倒入第一个水壶
        int diff2 = Math.min(x - v1, v2);
        if (dfs(v1 + diff2, v2 - diff2)) return true;

        return false;
    }

    private long zip(int a, int b) {
        return ((long) a << 32) | (b & 0xffffffffL);
    }
}
```

# 裴蜀定理

## 思路

裴蜀定理（Bézout’s identity）告诉我们：

> 对于任意整数 $x,y$，存在整数 $m,n$，使得 $mx+ny=\gcd(x,y)$

即，所有能通过 $x$ 与 $y$ 线性组合得到的数，必然都是 $\gcd(x,y)$ 的倍数。

而本问题对应的六种操作所能获得分别的盛水量 $a,b$，实际上都能被 $x,y$ 的线性组合表示，这是不难证明的。

因此，本问题实际上等价为我们能够确认 $target$ 是 $\gcd(x,y)$ 的倍数。

而如何在程序中计算 $\gcd(x,y)$ 也是一个经典且老生常谈的话题了，考虑辗转相除法，有
$$
\gcd(x,y)=\gcd(y,x\%y)
$$
利用该公式不断递归或循环计算，直到其中一个数为 $0$，那么另一个元素就是 $\gcd(x,y)$。

## 代码

算法的时间复杂度为 $O(1)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean canMeasureWater(int x, int y, int target) {
        return target <= x + y && target % gcd(x, y) == 0;
    }

    private int gcd(int x, int y) {
        if (y == 0) return x;
        return gcd(y, x % y);
    }
}
```
