题目简述：

> 给你一棵二叉树的根节点，返回该树的 **直径** 。
>
> 二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。
>
> 两节点之间路径的 **长度** 由它们之间边数表示。

题目链接：[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

# 初步分析：后序遍历与树型DP

解决这个问题的思路是考虑***后序遍历***，那么一个大问题就拆解为了两个小的子问题。

具体而言，因为后序遍历的顺序是 `左子树 -> 右子树 -> 根节点`，这天然适合用来求树的高度或直径——因为：

- 以某个节点作为根的（子）树的高度等于取左子树高度与右子树高度最大值加一；
- 以某个节点作为根的（子）树，也存在父问题完全依赖子问题的情况，这点我们在后文再解释。

后序遍历可以帮我们先计算出 $f(\text{left)}$ 与 $f(\text{right})$，进而在这基础上可以直接计算出当前节点的 $f(\text{this node})$，这里 $f$ 可以是直径，也可以是高度，可以是任何父问题完全依赖子问题的函数。前序遍历与中序遍历是做不到这一点的，如果不希望重复遍历、重复解决子问题，我们必须自下而上先解决子问题再通过子问题解决父问题。

可以看到，这其实就是一种***树型DP***，父问题完全依赖于子问题的解，父问题与子问题具有相同的结构，并且问题具有最优子结构。

# 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

 
class Solution {
    int maxWidth;

    // 基于 DFS 后序遍历的数型 DP
    public int diameterOfBinaryTree(TreeNode root) {
        maxWidth = 0;
        dfs(root);
        return maxWidth;
    }

    // 同时用上左右子树的直径更新最大直径记录，但只向上返回左右子树直径中的最大值
    private int dfs(TreeNode root) {
        if (root == null || (root.left == null && root.right == null)) return 0;

        int leftWidth = 0, rightWidth = 0;
        if (root.left != null) leftWidth = dfs(root.left) + 1;
        if (root.right != null) rightWidth = dfs(root.right) + 1;

        if (leftWidth + rightWidth > maxWidth) maxWidth = leftWidth + rightWidth;  // 更新 maxWidth

        return Math.max(leftWidth, rightWidth);  // 向上返回最大的子树直径，即“链”的长度
    }
}
```

下文中的分析是基于引用而不是这份代码的，下文的分析与代码没有直接联系，因为在写代码时我还没有清晰地意识到“链”。

# DP返回值“链”与更新记录“直径”不同

这里要注意，`dfs` 向上返回的是其左右子树直径中的最大值，但以本节点为根的树的直径却不是其左右子树直径的最大值，而是左子树直径加右子树直径（再根据左右子树存在情况加上0、1或2的边长）。也就是说，向上返回的值与更新 `maxWidth` 记录时所比较的值是不一样的。

造成这个现象的原因我总感觉我不能很清晰地描述、总结出来，尽管我一开始就意识到我应该这样做。这里我直接引用[灵茶山艾府](https://leetcode.cn/problems/diameter-of-binary-tree/solutions/2227017/shi-pin-che-di-zhang-wo-zhi-jing-dpcong-taqma/)写的内容：

> 本题有两个关键概念：
>
> 链：从子树中的叶子节点到当前节点的路径。把最长链的长度，作为 dfs 的返回值。根据这一定义，空节点的链长是 −1，叶子节点的链长是 0。
>
> 直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的叶子节点到 node 的链的节点值之和，去更新答案的最大值。
>
> ⚠注意：直径可能在下面的某个节点拐弯，不一定经过树根 root。
>
> ⚠注意：dfs 返回的是链的长度，不是直径的长度。如果返回直径，那么上面与其他的链继续拼接，得到的就不是直径了。
>
> ⚠注意：dfs 返回的是当前子树的最大链长（也可以理解为子树的高度），不包含当前节点和其父节点的这条边。
>

直径的定义是（无限制）最长路径，他这里额外提出了“链”的概念，“链”被定义为必须从根节点出发（因此不能“拐弯”）限制条件下的最长路径。

我这里再尝试总结一下：本树型DP的“父问题”、“子问题”并不是直接是树和子树直径，而是树和子树经过根节点的“最长链”长度，但我们可以通过“最长链”计算出树的直径。直径本身是不具有最优子结构性质的，因为直径对应的最长路径可以不经过根节点，所以无法根据左右子树的直径直接计算出整棵树的直径，只有通过限制经过特定节点的“链”才具备这一点，从而使我们能够计算出直径。

- **经过根节点的最长路径（候选直径） = 左链长 + 右链长**，如果子树不存在则计相应链长为0；
- **树直径 = 最长路径**，任何路径都一定拥有一个拐点，<u>最长路径的拐点作为子树的根时对应的候选直径等于全局直径</u>，**因此树直径 = 所有候选路径中的最大值**；
- **链长 = max(左链长, 右链长) + 1**；
- **链是构建直径的素材**：每个节点的直径候选值由其左右链组合而成；
- **链向上传递，直径全局维护**：递归时返回链长给父节点，同时用左右链之和更新全局最大直径。

以上要素缺一不可。
