题目简述：

> 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。
>
> 你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

题目链接：[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

# 思路

进行两次二分查找即可，第一次二分查找搜索左边界，第二次二分查找搜索右边界。首先明确语义：

- 左边界：首个大于等于 $target$ 的索引，即插入位置；
- 右边界：最后一个小于等于 $target$ 的索引。

两个边界分别对应了两次独立的二分查找，这样即使在最坏的情况下（数组中所有元素字面量均为 $target$），算法也不会退化为 $O(n)$ 的时间复杂度。时间复杂度固定为 $O(\log n)$。

两次二分查找的原理请参见我为二分查找专门撰写的文档 [74. 搜索二维矩阵：两次二分查找（附标准二分查找黄金模板）.md](https://github.com/arthur-stat/Java-CodeTop-MySolutions/blob/321ca118bcfa0d8707bca8b3dddeae8a47ef24d4/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%EF%BC%9A%E4%B8%A4%E6%AC%A1%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E9%99%84%E6%A0%87%E5%87%86%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%BB%84%E9%87%91%E6%A8%A1%E6%9D%BF%EF%BC%89.md#L4)，这里就不再赘述了。二分查找是非常基本、务必熟练掌握的基础算法，必须要能够根据语义实现所要求的二分查找算法。

# 代码

算法的时间复杂度为 $O(\log n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int l = 0;
        int r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        if (l == nums.length || nums[l] > target) return new int[]{-1, -1};
        int left = l;

        l = 0;
        r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] <= target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        int right = r;
        return new int[]{left, right};
    }
}
```