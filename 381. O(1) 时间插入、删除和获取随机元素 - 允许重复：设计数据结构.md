题目简述：

> `RandomizedCollection` 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。
>
> 实现 `RandomizedCollection` 类:
>
> - `RandomizedCollection()`初始化空的 `RandomizedCollection` 对象。
> - `bool insert(int val)` 将一个 `val` 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 `true` ，否则返回 `false` 。
> - `bool remove(int val)` 如果存在，从集合中移除一个 `val` 项。如果该项存在，则返回 `true` ，否则返回 `false` 。注意，如果 `val` 在集合中出现多次，我们只删除其中一个。
> - `int getRandom()` 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 **线性相关** 。
>
> 您必须实现类的函数，使每个函数的 **平均** 时间复杂度为 `O(1)` 。
>
> **注意：**生成测试用例时，只有在 `RandomizedCollection` 中 **至少有一项** 时，才会调用 `getRandom` 。

题目链接：[381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/)

# 思路

本问题与 [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/) 非常相似，区别只是在于本问题允许重复元素。

因此思路上是一样的，同样考虑用哈希表实现 $O(1)$ 时间复杂度的存在性查询，同时用数组实现 $O(1)$ 时间复杂度的随机化选取（通过索引）。只不过这里是允许重复元素的，所以哈希表应考虑值到索引集合的映射。之所以考虑索引集合而不是索引数组，是为了通过 `swap` 删除数组上某个元素时能够以 $O(1)$ 的时间复杂度找到被交换元素的旧索引以便更新其索引。

# 代码

该数据结构的使每个函数的平均时间复杂度均为 $O(1)$ 。

```java
class RandomizedCollection {

    private Map<Integer, Set<Integer>> valToIndex;
    private List<Integer> arr;
    private Random rand;

    public RandomizedCollection() {
        valToIndex = new HashMap<>();
        arr = new ArrayList<>();
        rand = new Random("tenma_saki".hashCode());
    }
    
    public boolean insert(int val) {
        arr.addLast(val);
        boolean exist = false;
        Set<Integer> set = valToIndex.get(val);
        if (set == null) {
            set = new HashSet<>();
            valToIndex.put(val, set);
            exist = true;
        }
        set.add(arr.size() - 1);
        return exist;
    }
    
    public boolean remove(int val) {
        Set<Integer> set = valToIndex.get(val);
        if (set == null) return false;

        int tmp = arr.get(arr.size() - 1);
        if (tmp == val) {
            set.remove(arr.size() - 1);
            if (set.isEmpty()) valToIndex.remove(val);
            arr.removeLast();
            return true;
        }

        int index = set.iterator().next();
        set.remove(index);
        if (set.isEmpty()) valToIndex.remove(val);
        arr.set(index, tmp);
        Set<Integer> tmpSet = valToIndex.get(tmp);
        tmpSet.remove(arr.size() - 1);
        tmpSet.add(index);
        arr.removeLast();
        return true;
    }
    
    public int getRandom() {
        return arr.get(rand.nextInt(arr.size()));
    }
}

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection obj = new RandomizedCollection();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

