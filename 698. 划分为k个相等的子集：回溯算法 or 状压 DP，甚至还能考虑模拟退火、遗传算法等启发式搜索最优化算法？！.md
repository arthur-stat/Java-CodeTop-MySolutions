题目简述：

> 给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。
>
> **提示：**
>
> - `1 <= k <= len(nums) <= 16`
> - `0 < nums[i] < 10000`
> - 每个元素的频率在 `[1,4]` 范围内

题目链接：[698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

# 回溯算法

## 思路

本问题的数据范围很关键，看到 `1 <= k <= len(nums) <= 16` 我们就可以肯定解决本问题必然可以先考虑回溯算法。同时，这属于典型的子集问题，本身也就是回溯算法的经典应用之一。

分出 `k` 个桶，对 `nums` 中的每个元素考虑放入第 `j` 个桶（`0 <= j < k`）。当某个桶的总和已经大于 `sum / k` 时提前剪枝——因为元素总和 `sum` 是固定的，那么分为 `k` 个总和相等的非空子集后，可以确认每个子集的总和均为 `sum / k`。

我们需要一些剪枝策略，例如当 `nums = [1, 1, 1]` 时，桶集合 `[[1], [1, 1]]` 与 `[[1, 1], [1]]` 显然是等价的，我们最好有办法避免重复求解。

可以在排序 `nums` 使之有序后考虑搜索树的同层剪枝，如果当前元素与上一个元素有相同值，则当前元素在回溯时只能考虑编号不小于上一个元素所在桶的桶。这是对等元素的对称性消解（value-symmetry breaking）的常见做法，通过顺序去掉一些等价排列组合，我们暂且将其称为重复值剪枝。

还可以进一步地从桶的角度进行剪枝，即对于一个元素如果当前考虑的桶与上一个桶内元素是相同的，由于我们划分的是集合——对应组合的逻辑而非排列，因此便也可以跳过当前桶。桶剪枝策略实际上是对于具有轮换对称性的等价桶仅处理一次。

事实上，我们也根本不需要真的实例化出桶，对于每个桶只要维护桶内元素总和即可，因为问题不要求给出具体分桶方案、只询问是否可以找出一个合理的分桶，本身对每个元素考虑放入哪个桶就避免了同一元素重复入同一个桶，我们还不关心桶内到底有多少个元素，所以维护桶内元素和就好。这样桶剪枝也更好做了，只需要判断桶内元素和是否相同。

重复值剪枝与重复桶剪枝可以两两结合，实现 “强强联合”，并不冲突。

即使要求给出具体的分桶，回溯算法依然能胜任，不过此时就需要真的实例化出桶以存储桶内元素了。

## 代码

力扣的测试用例上必须至少考虑下面三种剪枝策略才能避免超时：

1. 重复值剪枝
2. 等价桶剪枝
3. 非法桶剪枝（桶内总和已经大于被允许的最大值）
4. 解不存在剪枝（如果所有元素总和不能恰整除 `k`，那么问题不存在解）

即使如此 AC 时也花费了 1047ms。

为进一步降低时间开销，我们需要继续优化。所有优化中最为关键的一个是降序排序数组：**搜索树的规模往往由大数决定，如果先放较小的数，它们几乎什么桶都能塞进去，会产生非常多的分支；而如果先放较大的数，较大的数很快就会触发非法桶剪枝，从而剪掉大量不可能分支**。再结合等价桶剪枝，能够减掉海量分支。事实上也只需要降序排序这一个优化就足以保证算法的实际时间开销可接受了。

降序排序后，AC 时实际时间开销骤降至 1ms。

```java
class Solution {

    private int k;
    private int n;
    private int validBucketSum;
    private int[] nums;
    private int[] bucketsSum;

    public boolean canPartitionKSubsets(int[] nums, int k) {
        Arrays.sort(nums);
        reverse(nums);
        this.nums = nums;
        validBucketSum = 0;
        for (int num : nums) validBucketSum += num;
        /* 解不存在剪枝 */
        if (validBucketSum % k != 0) return false;
        validBucketSum /= k;
        this.k = k;
        n = nums.length;
        bucketsSum = new int[k];
        return dfs(0, -1);
    }

    private boolean dfs(int i, int prevBucket) {
        // if (i == n) {
        //     for (int sumOfBucket : bucketsSum) {
        //         if (sumOfBucket != validBucketSum) return false;
        //     }
        //     return true;
        // }
        if (i == n) return true;  // 非法桶剪枝保证了到达叶子节点 i = n 时必然是解

        /* 重复值剪枝 */
        int start = (i > 0 && nums[i] == nums[i - 1]) ? prevBucket : 0;
        for (int j = start; j < k; j++) {
            /* 等价桶剪枝 */
            if (j > start && bucketsSum[j] == bucketsSum[j - 1]) continue;
            /* 非法桶剪枝 */
            if (bucketsSum[j] + nums[i] > validBucketSum) continue;
            bucketsSum[j] += nums[i];
            if (dfs(i + 1, j)) return true;
            bucketsSum[j] -= nums[i];
        }

        return false;
    }

    private void reverse(int[] nums) {
        int i = 0;
        int j = nums.length - 1;
        while (i < j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
            i++;
            j--;
        }
    }
}
```

# 状压 DP

## 思路

本问题也可以考虑状压 DP，相比回溯算法更加稳定，不依赖于剪枝策略。参考自 [『 状态压缩 』记忆化搜索 + 动态规划](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solutions/1533869/by-flix-xh36/)。

定义状态 $state$ 为长 $n$ 的二进制位图，第 $i$ 位取 $0$ 时表示该元素尚未使用，取 $1$ 时表示该元素已使用。因此一共有 $2^n$ 种状态，我们使用位图进行状态压缩。

定义 $dp[state]$ 表示在当前状态下我们顺序装填各桶，如果我们已经尽可能地装满了前 $k'$ 个桶，那么第 $k'$ 个桶内的元素和为多少——如果不可能做到装满前 $k'$ 个桶，则补充定义 $dp[state]=-1$。注意，这里的 $k$ 具体是多少我们并不关心，我们只关心顺序装填时能否填满前几个桶，只关心填满前几个桶后的首个未填满桶内元素和的大小。

在该定义下，最终问题的解取决于 $dp[111\cdots11_2]$ 的值，如果该值为 $0$，则我们可以确定能够划分出 $k$ 个和相同的子集，否则不可能划分出 $k$ 个和相同的子集。

于是可以考虑状态转移，从一个合法的状态 $this$ 出发，假设桶内允许的元素和最大值为 $ceiling$，那么我们考虑状态转移：将一个未使用的元素考虑加入桶中，如果加入后桶内元素和非法，即 $dp[this]+unused>ceiling$ 则认为在状态 $this$ 上使用该元素（将对应元素的位置从 $0$ 更新至 $1$）得到的新状态不合法；否则认为新状态合法，且 $dp[new\_state]=dp[this]+unused$。

如果一个状态是合法的且存在正确的划分，那么从该状态出发最后一定有某个路径能够到达正确的划分；如果不存在正确的划分，那么从任何状态出发自然也无法得到合理合法的划分。因此，我们需要记录每种状态（即每个不一样的位图），在每个合法的状态尝试进行下一次转移，观察是否最终有路径到达 $111\cdots11_2$ 后 $dp[111\cdots11_2]$ 的值为多少。

表示位图时，Java 语言不要使用 `BitSet`，这只能存储布尔值，应考虑使用 `int[]`，数组大小为 $2^n$，将每个 32 位有符号整数 `int` 解释为二进制位图。

在计算具体的状态转移时，对于状态压缩 DP 常见的做法是按状态中位为 $1$ 的个数进行枚举遍历。显然地有初始状态 $dp[000\cdots00_2]=0$，对应零个位为 $1$ 的状态，接着再遍历 $dp[100\cdots00_2]$、$dp[010\cdots00_2]$、$dp[001\cdots00_2]$ 等枚举出全部仅一个位为 $1$ 的状态——这些状态均由 $000\cdots00_2$ 转移而来，然后对其中每个仅一个位为 $1$ 的状态考虑转移至共两个位为 $1$ 的状态，重复此过程，直到枚举至 $dp[111\cdots11_2]$。显然，具有 $m$ 个位为 $1$ 的状态应当从具有 $m-1$ 个位为 $1$ 的状态转移而来。

当然，也可以考虑 BFS / DFS 显式维护所有合法状态，也是可以的。无论采用哪种方式，本质上我们都是在一张无环状态图上遍历。只不过考虑 BFS / DFS 时，需要再定义一种状态的 $dp$ 值表示未探索，以区分已探索，避免重复求解。

更多细节请查看代码的具体实现。

## 代码

算法的时间复杂度为 $O(n2^n)$，空间为 $O(2^n)$。

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int n = nums.length;
        int len = 1 << n;  // int len = (int) Math.pow(2, n);
        int[] dp = new int[len];
        Arrays.fill(dp, -1);
        dp[0] = 0;

        int sum = 0;
        for (int num : nums) sum += num;
        if (sum % k != 0) return false;
        int ceiling = sum / k;

        for (int state = 0; state < len; state++) {
            if (dp[state] == -1) continue;

            for (int loc = 0; loc < n; loc++) {
                if (isUsed(state, loc)) continue;

                int used = setUsed(state, loc);
                if (dp[state] + nums[loc] > ceiling) {
                    continue;
                } else if (dp[state] + nums[loc] == ceiling) {
                    dp[used] = 0;
                } else {
                    dp[used] = dp[state] + nums[loc];
                }
            }
        }

        return dp[len - 1] == 0;
    }

    private boolean isUsed(int state, int loc) {
        return (state >>> loc & 1) == 1;
    }

    private int setUsed(int state, int loc) {
        return state | 1 << loc;
    }
}
```

# 模拟退火、遗传算法等

## 感叹

太抽象了，居然还能用上启发式搜索的最优化算法，参见题解 [【宫水三叶の相信科学系列】一题双解 :「搜索 + 剪枝」&「模拟退火」](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solutions/1835857/by-ac_oier-mryw/)
