题目简述：

> 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。
>
> 实现 `Solution` 类：
>
> - `Solution(ListNode head)` 使用整数数组初始化对象。
> - `int getRandom()` 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。
>
> **提示：**
>
> - 链表中的节点数在范围 `[1, 10^4]` 内
> - `-10^4 <= Node.val <= 10^4`
> - 至多调用 `getRandom` 方法 `10^4` 次
>
> **进阶：**
>
> - 如果链表非常大且长度未知，该怎么处理？
> - 你能否在不使用额外空间的情况下解决此问题？

题目链接：[382. 链表随机节点](https://leetcode.cn/problems/linked-list-random-node/)

# 链表转数组

这是最简单暴力且有效的方案，不过空间复杂度高了点。只要转为了数组，那么就支持 $O(1)$ 时间复杂度的随机访问，同时也能拿到链表的长度，自然就可以方便且高效地以均等的概率得到任一元素了。

缺点是空间开销较大，初始化的时间复杂度为 $O(n)$、空间复杂度为 $O(n)$，`getRandom` 的时间复杂度为 $O(1)$。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {

    private ArrayList<Integer> arr;
    private static Random rand = new Random("SAKI!".hashCode());

    public Solution(ListNode head) {
        arr = new ArrayList<>();
        while (head != null) {
            arr.add(head.val);
            head = head.next;
        }
    }
    
    public int getRandom() {
        return arr.get(rand.nextInt(arr.size()));
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
```

# 随机移动 k 步指针

我们可以不使用额外的空间，只需要知道链表的长度 $n$ 即可。每次我们在 $[0,n)$ 范围内得到一个随机数 $k$，然后让链表上的指针前进 $k$ 步，当走到链表尽头时再重新置于 `head`（类似循环链表）。这样就不再需要额外的空间，但需要事先知道链表的长度。

该方案初始化的时间复杂度为 $O(n)$、空间复杂度为 $O(1)$，`getRandom` 的时间复杂度为 $O(n)$。

```java
class Solution {

    private ListNode head;
    private ListNode pointer;
    private int len;
    private static Random rand = new Random("SAKI!".hashCode());

    public Solution(ListNode head) {
        this.head = head;
        pointer = head;
        len = 0;
        while (head != null) {
            len++;
            head = head.next;
        }
    }
    
    public int getRandom() {
        int k = rand.nextInt(len);
        for (int i = 0; i < k; i++) {
            pointer = pointer.next;
            if (pointer == null) pointer = head;
        }
        return pointer.val;
    }
}
```

# 蓄水池抽样算法

上面的方法都不适用于数据流。对于数据流，实际上就对应题干中的下一条限制：

> **进阶：**
>
> - 如果链表非常大且长度未知，该怎么处理？

即我们无法一次性获取到全部的链表，那么上面两个方案就都不适用了。对于方案一，我们无法拿到全部的节点；对于方案二，我们无法知道链表的总长度。针对该情况，我们需要想一种新的方案。

因为不知道链表的长度，所以随机索引的办法不可行（方案二本质上也是随机索引，只不过不是通过索引结果随机访问，而是控制链表指针的前进步数）。那我们如何实现随机化选取节点呢？答案是所谓的蓄水池抽样。

蓄水池抽样算法的分析建议直接阅读题解 [蓄水池抽样算法](https://leetcode.cn/problems/linked-list-random-node/solutions/135440/xu-shui-chi-chou-yang-suan-fa-by-jackwener/)，这篇题解不光写得很好、有充分的证明过程，而且给出了该算法更广义（每次读取 $m$ 个数）的分析与实现。

对于本问题（每次只读取一个数），简而言之就是从表头开始遍历，并且有一个动态维护的变量 $x$，假设我们遍历访问到了第 $i$ 个数，那么我们以 $\frac1{i}$ 的概率将 $x$ 更新为该数、以 $1-\frac1{i}$ 的概率维持 $x$ 不变，那么当我们遍历完整个链表后如果将 $x$ 视为抽样结果，则平均下来链表中每个元素被采样到的概率就是 $1/n$ 的。这一点需要经过严密的数学证明，这里给出简要证明，对于更一般的分析与结论请参考 [蓄水池抽样算法](https://leetcode.cn/problems/linked-list-random-node/solutions/135440/xu-shui-chi-chou-yang-suan-fa-by-jackwener/)。
$$
\begin{align}P\big(x=list(i)\big)&=\frac1{i}\Big(1-\frac1{i+1}\Big)\Big(1-\frac1{i+2}\Big)\cdots\\&=\frac1{i}\Big(\frac{i}{i+1}\Big)\Big(\frac{i+1}{i+2}\Big)\Big(\frac{i+2}{i+3}\Big)\cdots\\&=\frac1{n}\end{align}
$$
该方案初始化的时间复杂度为 $O(1)$、空间复杂度为 $O(1)$，`getRandom` 的时间复杂度为 $O(n)$。

```java
class Solution {

    private ListNode head;
    private static Random rand = new Random("SAKI!".hashCode());

    public Solution(ListNode head) {
        this.head = head;
    }
    
    public int getRandom() {
        ListNode node = head;
        int x = 0;
        for (int i = 1; node != null; node = node.next, i++) {
            int r = rand.nextInt(i);
            if (r == 0) x = node.val;
        }
        return x;
    }
}
```

