题目简述：

> 给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。
>
> 题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。
>
> 请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。
>
> **进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

题目链接：[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

# 前缀乘积

## 思路

如果允许用除法的话，直接计算所有数字的乘积，然后将每个数字分别作为除数除该乘积，就可以得到结果。这样时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

但题干描述不准我们用除法，那么我们就只能增量地计算乘积，而不能考虑除法。

借鉴前缀和的思路，我们可以考虑前缀乘积，先正向扫描一次得到前缀积，再反向扫描一遍得到后缀积，然后就可以直接乘起来拼接乘积了。

例如，要计算 `[1, 2, 3, 4, 5]` 中第二个数字对应的解，则可以用 `[1]` 的前缀积乘以 `[3, 4, 5]` 的后缀积，最终的积就是 `[1, 3, 4, 5]` 的乘积。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n];
        int[] suf = new int[n];
        int p = 1;
        int s = 1;
        
        for (int i = 0; i < n; i++) {
            p *= nums[i];
            s *= nums[n - i - 1];
            pre[i] = p;
            suf[n - i - 1] = s;
        }

        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                res[0] = suf[1];
            } else if (i == n - 1) {
                res[n - 1] = pre[n - 2];
            } else {
                res[i] = pre[i - 1] * suf[i + 1];
            }
        }

        return res;
    }
}
```

# 原地算法

## 思路

要实现 $O(1)$ 的额外空间复杂度，我们可以考虑利用上输入数组与输出数组——用他们为我们存储前缀乘积。

具体来说是这样的：

1. 首先将输出数组用作后缀积数组，进行一次后缀积数组的初始化即可，只不过直接操作输出数组；
2. 使用一个变量维护当前前缀乘积；
3. 这样就可以直接算出当前元素对应的解——因为我们既有前缀积，又有后缀积；
4. 求解到下一个元素时，先更新前缀积——直接乘以上一个元素即可，对于后缀积——这是早已初始化在输出数组中的，直接获取。

这样就可以实现 $O(1)$ 的额外空间复杂度啦~

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        int suf = 1;
        for (int i = n - 1; i >= 0; i--) {
            suf *= nums[i];
            res[i] = suf;
        }

        int pre = 1;
        for (int i = 0; i < n - 1; i++) {
            res[i] = pre * res[i + 1];
            pre *= nums[i];
        }
        res[n - 1] = pre;

        return res;
    }
}
```

