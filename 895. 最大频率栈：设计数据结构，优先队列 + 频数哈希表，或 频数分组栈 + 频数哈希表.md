题目简述：

> 设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出**出现频率**最高的元素。
>
> 实现 `FreqStack` 类:
>
> - `FreqStack()` 构造一个空的堆栈。
> - `void push(int val)` 将一个整数 `val` 压入栈顶。
> - `int pop()`  删除并返回堆栈中出现频率最高的元素。
>   - 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。

题目链接：[895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/)

# 优先队列 + 哈希表

本方案不是最优实现哦！最优实现是分组栈，下文会专门分析。

但我觉得本方案是很直观的，因此在这里首先给出——虽然分组栈也挺直观的就是了。都了解一下，也没有坏处呢。

## 思路

我最初想，完全可以像 [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/) 那样用双哈希表 + 频数分桶双向链表的方案那样高效地实现。

仔细一想似乎根本不必要，因为本质上这是一个特别的栈逻辑，有点像优先队列，不需要以 $O(1)$ 的时间开销获取到 key 到 value 的映射，就连检查 val 是否存在都不需要，只要求实现 `push` 与 `pop`。

我们可以直接复用优先队列的逻辑，因为事实上该堆栈就是为栈内元素定义了优先级。我们封装 `Integer` 为 val + freq，例如第一次压入 1 时我们压入 val = 1、freq = 1 的封装，第二次压入 1 时我们压入 val = 1、freq = 2 的封装。定义优先队列的优先级，优先让 freq 的元素出栈，如果频率相同则按栈的自然顺序出栈。要维护栈的自然顺序，我们就还需要定义一个全局操作数 op，每次 push 时都为封装分配一个 op 值，然后 op 值递增，当 freq 相同时优先弹出 op 值更大的封装。

为了知道压入的元素在堆栈内的频次为多少以设定 freq，我们还需要一张哈希表用于频数统计。

这样就可以直接实现该堆栈了，不需要哈希表拉链，为优先队列定义优先级即可。

## 代码

数据结构的每个操作时间复杂度为 $O(\log n)$，总的空间复杂度为 $O(n)$。

```java
record Package(int val, long freq, long op) {}

class FreqStack {

    private PriorityQueue<Package> pq;
    private Map<Integer, Long> freqStat;
    private long op;

    public FreqStack() {
        pq = new PriorityQueue<>((a, b) -> {
            if (a.freq() != b.freq()) return Long.compare(b.freq(), a.freq());
            return Long.compare(b.op(), a.op());
        });
        freqStat = new HashMap<>();
        op = 0;
    }
    
    public void push(int val) {
        long freq = freqStat.merge(val, 1L, Long::sum);
        pq.offer(new Package(val, freq, op++));
    }
    
    public int pop() {
        int res = pq.poll().val();
        if (freqStat.merge(res, -1L, Long::sum) == 0) freqStat.remove(res);
        return res;
    }
}

/**
 * Your FreqStack object will be instantiated and called as such:
 * FreqStack obj = new FreqStack();
 * obj.push(val);
 * int param_2 = obj.pop();
 */
```

# 分组栈 + 哈希表

## 思路

另一种思路是按频数分组，每组对应一个栈。例如假设现在堆栈内一共有 3 个 1，那么再次将 1 压入堆栈时，我们就将其实际压入频数 4 对应的堆栈。显然，这也需要我们使用哈希表对 val 的频数进行记录。

当需要弹出元素时，我们就直接弹出当期堆栈内 val 的最大频数对应的栈的栈顶就好了——这样天然就符合优先弹出频数最大且距离堆栈栈顶最近元素的逻辑，不需要单独定义优先级。

注意到某频数的栈非空时，小于该频数的其他频数值对应的栈也必然非空，所以我们可以维护一个变量表示当前堆栈内 val 的最大频数，进而快速帮助我们找出需要弹出堆栈栈顶时应当具体弹出哪个分组栈的栈顶。如果弹出堆栈栈顶后分组栈空了，那就让最大频数变量自减一即可。

## 代码

数据结构的每个操作时间复杂度为摊还 $O(1)$，总的空间复杂度为 $O(n)$。

```java
class FreqStack {

    private Map<Long, Deque<Integer>> freqToStack;
    private Map<Integer, Long> freqStat;
    private long maxFreq;

    public FreqStack() {
        freqToStack = new HashMap<>();
        freqStat = new HashMap<>();
        maxFreq = 0;
    }
    
    public void push(int val) {
        long freq = freqStat.merge(val, 1L, Long::sum);
        Deque<Integer> stack = freqToStack.get(freq);
        if (stack == null) {
            stack = new ArrayDeque<>();
            freqToStack.put(freq, stack);
        }
        stack.push(val);
        maxFreq = Math.max(maxFreq, freq);
    }
    
    public int pop() {
        Deque<Integer> stack = freqToStack.get(maxFreq);
        int res = stack.pop();
        freqStat.merge(res, -1L, Long::sum);
        if (stack.isEmpty()) maxFreq--;
        return res;
    }
}
```

