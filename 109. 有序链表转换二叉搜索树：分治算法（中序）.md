题目简述：

> 给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为平衡二叉搜索树。

题目链接：[109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

# 思路

要动态维护平衡 BST 比较麻烦，但对于给定的升序数组 / 链表要初始化一个平衡 BST 则是非常简单的，递归即可，每次都取一段数字的中间元素作为该段对应子树的根节点。

这实际上是一个分治算法的应用，如果输入是数组而非链表，则问题会更简单，因为数组支持随机访问、可以直接定位一段数字的中间元素，这种情况就是 [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)。在那个问题中，我们先序地、递归地构造了平衡 BST。

而当输入是链表时，当然可以先将链表转为数组然后再直接复用 [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 的代码，但这样空间复杂度将达到 $O(n)$。

如果不先将链表转为数组而每次都快慢指针寻找中点以复用 [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 的逻辑的话，时间复杂度又将来到 $O(n\log n)$。

---

一个更好的方案是复用 [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 中分治算法的原理，但针对链表不支持随机访问的特点进行一点小小改造。

我们知道，BST 的中序遍历结果恰为其元素值的顺序排列。考虑到链表是不支持随机访问的，我们会有这样一个想法：能不能保证在构建过程中，不需要定位子树区间的根节点（类似先序遍历顺序构建，即数组中采用的办法），而是按照链表的顺序进行构建（类似中序遍历顺序构建）呢？

当然可以！

这样讲可能比较抽象，我们来看看在 [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 中我们的具体代码：

```java
private TreeNode build(int start, int end) {
    if (start > end) return null;
    int mid = start + (end - start) / 2;

    TreeNode root = new TreeNode(nums[mid]);
    TreeNode left = build(start, mid - 1);
    TreeNode right = build(mid + 1, end);

    root.left = left;
    root.right = right;

    return root;
}
```

这实际上是按照 “中 → 左 → 右” 的顺序进行构建的，即先序遍历。这就是为什么直接复用 [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 逻辑的话我们需要寻找中点，但这对链表而言很不友好。

按照上文的分析，应当结合考虑按照 “左 → 中 → 右” 的顺序进行构建，因为这样可以保证 “中节点” 的遍历顺序与链表的顺序完全重合。

***我们唯一要做的一件事就是：将构建的顺序从先序地改为中序地。***

现在开始编写算法吧！

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(\log n)$，其中空间复杂度主要来自于递归栈的开销。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    private ListNode listNode;

    public TreeNode sortedListToBST(ListNode head) {
        listNode = head;
        int n = 0;
        while (head != null) {
            n++;
            head = head.next;
        }

        return build(0, n - 1);
    }

    private TreeNode build(int start, int end) {
        if (start > end) return null;
        int mid = start + (end - start) / 2;

        // left
        TreeNode left = build(start, mid - 1);

        // mid
        int value = listNode.val;
        listNode = listNode.next;

        // right
        TreeNode right = build(mid + 1, end);

        TreeNode thisTreeNode = new TreeNode(value, left, right);
        return thisTreeNode;
    }
}
```

