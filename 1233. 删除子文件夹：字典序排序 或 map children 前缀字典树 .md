题目简述：

> 你是一位系统管理员，手里有一份文件夹列表 `folder`，你的任务是要删除该列表中的所有 **子文件夹**，并以 **任意顺序** 返回剩下的文件夹。
>
> 如果文件夹 `folder[i]` 位于另一个文件夹 `folder[j]` 下，那么 `folder[i]` 就是 `folder[j]` 的 **子文件夹** 。`folder[j]` 的子文件夹必须以 `folder[j]` 开头，后跟一个 `"/"`。例如，`"/a/b"` 是 `"/a"` 的一个子文件夹，但 `"/b"` 不是 `"/a/b/c"` 的一个子文件夹。
>
> 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：'/' 后跟一个或者多个小写英文字母。
>
> - 例如，`"/leetcode"` 和 `"/leetcode/problems"` 都是有效的路径，而空字符串和 `"/"` 不是。

题目链接：[1233. 删除子文件夹](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/)

# 字典序排序

## 思路

显然地，如果路径 `a`、`b`、`c` 均为 `a` 的子路径，则在排序后对于 `a` 的真子路径 `b`、`c`，他们必然连续地位置 `a` 排序后的右侧位置（`[a, b ,c]` 或 `[a, c, b]`），这是字典序的定义所保证的。

因此，我们只需要对字符串进行字典序排序，然后每次判断排序后的当前路径是否为当前可能的父路径 `parent` 的子路径，如果是则不进行任何操作、继续扫描下一个路径，如果不是则更新父路径 `parent` 的字符串，并将该字符串加入到结果集中。

这里要注意的小细节是比如 `"/a/b"` 与 `"/a/bc"`，我们通过模式匹配算法发现 `"/a/b"` 是 `"/a/bc"` 的前缀时不能直接判定后者就是前者的子路径——此时只能从字符串的角度判断确为子串，应当进一步检查 `"/a/bc"` 的第 `5` 个字符是否 `'/'` 才能确定是否确为 `"/a/b"` 的子路径。其中 `5` 就是 `"/a/b"` 的长度加一。

## 代码

算法的时间复杂度为 $O(nL\log n)$，空间复杂度取决于具体的排序算法，其中 $L$ 表示路径的平均长度。

```java
class Solution {
    public List<String> removeSubfolders(String[] folder) {
        Arrays.sort(folder);
        List<String> res = new ArrayList<>();
        String parent = "/";

        for (int i = 0; i < folder.length; i++) {
            int matched = folder[i].indexOf(parent);
            if (matched != 0 || (matched == 0 && folder[i].charAt(parent.length()) != '/')) {
                parent = folder[i];
                res.add(parent);
            }
        }

        return res;
    }
}
```

# map children 前缀字典树

## 思路

也可以考虑 map children 表示法的前缀字典树。map children 是指字典树的节点不仅仅存储字典片段值 `segment`，同时也使用一个变量 `isEnd` 标记当前节点是否为终点，这能够有效地帮助我们判断一个路径是否是另一个路径的子路径——如果当前路径已经到达了终点但字典树中该节点并没有结束标记，则我们需要更新结束标记；如果当前路径在搜索途中发现某个节点存在结束标记，则我们就不必再继续探索，因为该路径已经能够确定是某个路径的子路径。

最后再 DFS 字典树就可以得到所有非子路径的路径了，当节点 `isEnd` 为 `false` 或者 `children` 为空则认为此节点为叶子节点。

## 代码

算法的时间复杂度为 $O(nL)$，空间复杂度为 $O(nL)$，其中 $L$ 表示路径的平均长度。

```java
class Solution {

    private static class Node {

        String segment;
        boolean isEnd;
        Map<String, Node> children;

        Node(String segment) {
            this.segment = segment;
            isEnd = false;
            children = new HashMap<>();
        }
    }

    public List<String> removeSubfolders(String[] folder) {
        Node root = new Node("");

        for (String path : folder) {
            String[] segs = path.split("/");
            Node node = root;

            for (String seg : segs) {
                if (seg.isBlank()) continue;
                if (node.isEnd) break;

                Node next = node.children.get(seg);
                if (next == null) {
                    next = new Node(seg);
                    node.children.put(seg, next);
                }
                node = next;
            }

            node.isEnd = true;
            node.children.clear();
        }

        List<String> res = new ArrayList<>();
        StringBuilder path = new StringBuilder();
        for (var entry : root.children.entrySet()) {
            dfs(res, path, entry.getValue());
        }
        return res;
    }

    private void dfs(List<String> res, StringBuilder path, Node node) {
        path.append("/" + node.segment);

        if (node.isEnd || node.children.isEmpty()) {
            res.add(path.toString());
            path.setLength(path.length() - node.segment.length() - 1);
            return;
        }

        for (var entry : node.children.entrySet()) {
            dfs(res, path, entry.getValue());
        }

        path.setLength(path.length() - node.segment.length() - 1);
    }
}
```

