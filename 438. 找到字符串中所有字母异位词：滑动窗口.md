题目简述：

> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

题目链接：[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

# 双指针

## 思路

典型的双指针 / 滑动窗口问题，当 `s`  的窗口内的字符频率与 `p` 完全一致时，就将窗口的起始索引纳入结果集。

这里的一个注意到是要动态维护滑动窗口内每个字符的频数均小于等于 `p` 的对应字符频数，当滑动窗口右边界增长时，

- 如果每个字符的频数统计相同，则可以将滑动窗口的左边界记录在结果集；
- 如果滑动窗口内每个字符的频数均小于等于 `p` 的对应字符频数但至少存在一个字符在滑动窗口的频数是严格小于的 `p` 对应字符频数的，则无动作，继续向右探索滑动窗口边界；
- 如果右边界增长后新纳入的字符在滑动窗口内的频数已经大于其在 `p` 中的频数了，则不断右移左边界（缩小滑动窗口的范围），直到滑动窗口内该字符频数等于其在 `p` 中的频数。

这样就可以找出所有满足条件的子串的起始索引。

## 代码

算法的时间复杂度为 $O(m+n)$，空间复杂度为 $O(m+n)$。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n = s.length();
        List<Integer> res = new ArrayList<>();
        Map<Character, Integer> ss = new HashMap<>();
        Map<Character, Integer> pp = new HashMap<>();
        for (char ppp : p.toCharArray()) {
            pp.merge(ppp, 1, Integer::sum);
        }

        int left = 0;
        for (int right = 0; right < n; right++) {
            /* 允许 ss 中字符的计数比 pp 少，但不允许比 pp 多。
               一旦 ss 比 pp 多，就右移 left 指针以恢复状态，从而维护不变量。*/
            
            char c = s.charAt(right);
            int ssCounter = ss.merge(c, 1, Integer::sum);

            int ppCounter = pp.getOrDefault(c, 0);

            while (ssCounter > ppCounter) {
                char cc = s.charAt(left++);
                int result = ss.merge(cc, -1, Integer::sum);
                if (result == 0) ss.remove(cc);
                if (cc == c) ssCounter--;
            }
            
            if (ss.equals(pp)) res.add(left);
        }

        return res;
    }
}
```

# 滑动窗口改进

## 优化思路

上面的实现更准确讲还是属于双指针的思路，注意到异位词的长度必然是相等的，因此完全可以用一个固定大小的滑动窗口进行扫描，而不必手动维护两个边界指针，这样就是一个标准的滑动窗口算法。虽然复杂度在数量级上并无差异，但算法及其逻辑可以设计地更简单，并且能够避免一些常数开销的不可能为解的搜索。

## 改良后代码

复杂度同上，但更轻量级，常数开销更少，逻辑也更简单。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n = s.length();
        int m = p.length();
        List<Integer> res = new ArrayList<>();
        int[] ss = new int[26];
        int[] pp = new int[26];
        for (char ppp : p.toCharArray()) {
            pp[ppp - 'a']++;
        }

        // 避免边界条件，单独检查初始化情况
        for (int i = 0; i < m && i < n; i++) {
            ss[s.charAt(i) - 'a']++;
        }
        if (isEquals(ss, pp)) res.add(0);

        for (int right = m; right < n; right++) {
            ss[s.charAt(right - m) - 'a']--;
            ss[s.charAt(right) - 'a']++;
            if (isEquals(ss, pp)) res.add(right - m + 1);
        }

        return res;
    }

    private boolean isEquals(int[] a, int[] b) {
        // if (a.length != b.length) return false;
        int n = a.length;
        for (int i = 0; i < n; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}
```

