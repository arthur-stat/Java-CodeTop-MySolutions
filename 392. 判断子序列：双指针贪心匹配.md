题目简述：

> 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
>
> **进阶：**
>
> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
>
> **致谢：**
>
> 特别感谢 [@pbrother ](https://leetcode.com/pbrother/)添加此问题并且创建所有测试用例。

题目链接：[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

# 思路

双指针贪心匹配即可。

如果 `s` 是 `t` 的子序列，那么假设 `s[i]` 也位于 `t[j1]` 与 `t[t2]`，如果 `t1 < t2`，一定优先选择 `t[j1]` 与 `s[i]` 匹配。这是因为选择最早能够匹配成功的字符，将能够覆盖后续所有可能的选择。

# 代码

算法的时间复杂度为 $O(m+n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length();
        int n = t.length();
        if (m == 0) return true;

        int i = 0;
        char c = s.charAt(i);

        for (int j = 0; j < n; j++) {
            if (c == t.charAt(j)) {
                i++;
                if (i == m) return true;
                c = s.charAt(i);
            }
        }
        
        return false;
    }
}
```

# 进阶

面对海量的输入，不再考虑该方法，因为对 `t` 做了太多次重复扫描。

可以考虑建立 `next` 表，令 `next[i][c]` 表示字符 `c` 出现在 `t` 的索引 `i` 后的下一个位置。

这样，对每个输入的 `s`，只需要不断查 `next` 表判断能够 “走完” `s` 自身即可，省去了对每个 `s` 也扫描一次 `t` 的开销。

还可以考虑二分查找，这里就不多言了。
