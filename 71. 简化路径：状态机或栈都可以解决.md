题目简述：

> 给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为 **更加简洁的规范路径**。
>
> 在 Unix 风格的文件系统中规则如下：
>
> - 一个点 `'.'` 表示当前目录本身。
> - 此外，两个点 `'..'` 表示将目录切换到上一级（指向父目录）。
> - 任意多个连续的斜杠（即，`'//'` 或 `'///'`）都被视为单个斜杠 `'/'`。
> - 任何其他格式的点（例如，`'...'` 或 `'....'`）均被视为有效的文件/目录名称。
>
> 返回的 **简化路径** 必须遵循下述格式：
>
> - 始终以斜杠 `'/'` 开头。
> - 两个目录名之间必须只有一个斜杠 `'/'` 。
> - 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
> - 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。
>
> 返回简化后得到的 **规范路径** 。

题目链接：[71. 简化路径](https://leetcode.cn/problems/simplify-path/)

# 我的思路（状态机）

## 思路

关键是如何处理 `".."`，至于其他的情况，例如 `"."`、`'//'`，都是容易处理的。

我的思路是首先将字符串 `path` 按 `"/"` 分割为字符串数组，再从后往前构建简化路径。这样做的好处是可以将 `".."` 视为抵消操作，这样我们在拼接结果时当碰上 `".."` 时就可以忽视上一级目录——前提是上一级目录不是 `".."`，否则继续向前忽视两级目录。因此，我们可以为 `".."` 设置一个计数器，用以表示应忽略多少级目录。

这样实现代码的话，应该是一种利用状态机的思想。

## 代码

```java
class Solution {
    public String simplifyPath(String path) {
        LinkedList<String> list = new LinkedList<>();
        String[] s = path.split("/");
        
        int len = s.length;
        int doubleDotCount = 0;
        
        for (int i = len - 1; i >= 0; i--) {
            switch (s[i]) {
                case "..":
                    doubleDotCount++;
                    break;
                case ".":
                    break;
                case "":
                    break;
                default:
                    if (doubleDotCount > 0) {
                        doubleDotCount--;
                    } else {
                        list.addFirst(s[i]);
                        list.addFirst("/");
                    }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (String ss : list) sb.append(ss);
        if (sb.isEmpty()) sb.append("/");
        return sb.toString();
    }
}
```

# 其他思路

这个问题也天然适合用栈来解决，因为碰到 `".."` 后从栈中弹出一次栈顶即可（逻辑上也是 “抵消”），这样的话就是从左至右处解析的，区别于我们此前从右到左解析的思路。实现上是大同小异的。