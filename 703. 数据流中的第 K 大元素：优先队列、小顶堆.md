题目简述：

> 设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。
>
> 请实现 `KthLargest` 类：
>
> - `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。
> - `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

题目链接：[703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

# 思路

用优先队列 / 小顶堆维护数据流最大的前 `k` 个元素即可。

# PriorityQueue

```java
class KthLargest {

    private PriorityQueue<Integer> pq;
    private int k;

    public KthLargest(int k, int[] nums) {
        pq = new PriorityQueue();
        this.k = k;
        for (int num : nums) add(num);
    }
    
    public int add(int val) {
        pq.offer(val);
        if (pq.size() == k + 1) pq.poll();
        return pq.peek();
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 */
```

# 数组实现小顶堆

```java
class KthLargest {

    private MinHeap minHeap;
    private int k;

    public KthLargest(int k, int[] nums) {
        minHeap = new MinHeap(k);
        this.k = k;
        for (int num : nums) add(num);
    }
    
    public int add(int val) {
        minHeap.offer(val);
        if (minHeap.size() == k + 1) minHeap.poll();
        return minHeap.peek();
    }
}

class MinHeap {

    private int[] arr;
    private int size_;

    public MinHeap(int k) {
        arr = new int[k + 1];
        size_ = 0;
    }

    public void offer(int val) {
        arr[size_++] = val;
        shiftUp(size_ - 1);
    }

    public void poll() {
        swap(0, --size_);
        shiftDown(0);
    }

    public int peek() {
        return arr[0];
    }
    
    public int size() {
        return size_;
    }

    private void shiftUp(int i) {
        while (true) {
            int p = parent(i);
            if (i == 0 || arr[p] <= arr[i]) break;
            swap(i, p);
            i = p;
        }
    }

    private void shiftDown(int i) {
        while (true) {
            int l = left(i);
            int r = right(i);
            if ((!isValid(l) || arr[l] >= arr[i]) && (!isValid(r) || arr[r] >= arr[i])) break;
            int minOne;
            if (!isValid(r)) {
                minOne = l;
            } else {
                minOne = (arr[l] < arr[r]) ? l : r;
            }
            swap(i, minOne);
            i = minOne;
        }
    }

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int left(int i) {
        return 2 * i + 1;
    }

    private int right(int i) {
        return 2 * i + 2;
    }

    private boolean isValid(int i) {
        return i >= 0 && i < size_;
    }

    private void swap(int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

