题目简述：

> 给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。
>
> 必须在不使用库内置的 sort 函数的情况下解决这个问题。
>
> **进阶：**
>
> - 你能想出一个仅使用常数空间的一趟扫描算法吗？

题目链接：[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

# 思路

如果只有两种颜色，那么直接双指针就可以实现仅使用常数空间的一趟扫描算法。

但现在有三种颜色，这可能需要我们思考一下。

容易想到，双指针可以实现仅使用常数空间的两趟扫描算法，时间复杂度不变、常数因子翻倍，做法是第一趟扫描时将红色和白色视为同色、把蓝色先排到末段位置，第二趟再在红色和白色间排序即可。但这样做意义不大——毕竟，如果允许两趟扫描，那么我们在第一趟扫描时直接计数、第二趟遍历时直接对数组按计数赋值，实现起来还更简洁一些。

---

考虑这样一个场景：如果我们扫描到第 $i+1$ 个元素，前 $i$ 个元素都是已经排好序的，那么我们如何处理第 $i+1$ 个元素呢？

1. 最简单的情况，如果第 $i+1$ 个元素的蓝色的，那么什么也不用做；
2. 如果第 $i+1$ 个元素是白色的，那么我们调换该元素与首个蓝色元素；
3. 如果第 $i+1$ 个元素是红色的，那么我们调换该元素与首个白色元素，于是转化为第二种情况，再调换该白色元素与首个蓝色元素即可。

这样问题就迎刃而解了。

---

这个问题就是所谓**荷兰国旗问题（the Dutch National Flag problem）**。

# 分析

但在上述思路下依然不方便编写代码，问题在于如何初始化首个蓝色元素指针与首个白色元素指针。毕竟在一开始的时候，我们对数组的信息是一无所知的。

实际上，仔细观察，上述思路正是三路快速排序算法的思想。在三路快排中，`left` 与 `right` 把元素划分为了 `left` 左侧的小于区、`left` 至 `right` 的等于区以及 `right` 右侧的大于区，当 `mid` 递增至超过 `right` 时算法结束，最终 `left` 与 `right` 划分了整个数组。因此，前文中首个白色元素指针正对应 `left`、首个蓝色元素指针正对应 `right`。
$$
\underbrace{0000000}_{\text{less area}}\ \ \ \mathrm{left}\ \ \ \underbrace{11111}_{\text{equal area}}\ \ \mathrm{mid}\ \ \underbrace{???????????}_{\text{unknown area}}\ \ \ \mathrm{right}\ \ \ \underbrace{222222222222}_{\text{greater area}}
$$
所以我们按三路快排编写算法即可。

# 代码

经过分析，我们对三路快排的设计的了解就更加深入了。分析中的例图直接说明了为何 `mid`（`i`） 在有些情况下不需要递增。

> 这个题也告诉了我们，以后写快排算法如果忘了怎么写三向切分，直接把上面的示意图画出来就好了！也不需要死记硬背了，只要记得这张公式图就好。

```java
class Solution {

    public void sortColors(int[] nums) {
        int n = nums.length;
        int left = 0;
        int i = 0;
        int right = n - 1;

        while (i <= right) {
            switch (nums[i]) {
                case 0:
                    swap(nums, i, left);
                    left++;
                    i++;
                    break;

                case 1:
                    i++;
                    break;

                case 2:
                    swap(nums, i, right);
                    right--;
                    break;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
}
```

