题目简述：

> 给你一个整数数组 `nums` 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。
>
> 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 `0` 。每一回合，玩家从数组的任意一端取一个数字（即，`nums[0]` 或 `nums[nums.length - 1]`），取到的数字将会从数组中移除（数组长度减 `1` ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。
>
> 如果玩家 1 能成为赢家，返回 `true` 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 `true` 。你可以假设每个玩家的玩法都会使他的分数最大化。

题目链接：[486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/)

# 记忆化搜索

## 思路

这个问题用记忆化搜索比较好想，是比较直观且自然的思路。

本问题是一种完全信息、零和、无随机的博弈，这种博弈具有最优子结构：当前选择是否最优，只取决于后续子局面中双方继续做出最优选择时所能到达的结果。

> 这里 “后续子局面中双方继续做出最优选择时所能到达的结果” 一定程度上启示了不要设计双方各自累积的绝对分数，而要设计相对分数差，这样，对玩家 1 而言最优选择就是尽可能让最终的相对分差更大、对玩家 2 而言最优选择就是尽可能让最终的相对分差更小。
>
> 如果硬要采取双方各自累积的绝对分数的设计，就不便于刻画出什么选择才是当前的最优选择了。即使采用绝对分数的设计，最终的判定也依赖于两个玩家的绝对分数差值，而不会依赖两个玩家绝对分数的绝对数值——如果从绝对数值出发思考，那就***彻底绕进死胡同了：我到底该让自己分数最大化，还是让对手分数最小化？***得承认，我就在这个问题上卡了很久很久。

状态设计为双指针，分别指向最左侧尚未被移除的元素 $i$ 与最右侧尚未被移除的元素 $j$，这样状态本身就蕴含了当前回合是谁的回合（利用 $n-(j-i)$ 的奇偶性）。利用最优子结构，我们可以解出一个确定状态下的最优相对分差——对玩家 1 而言是最大相对分差，对玩家 2 而言是最小相对分差。

## 关键

> 来时的路是踩了一个个坑……

关键在于设计 DFS 时应当返回***自当前状态起***能够获得的最优相对分差，我一度忽略了这一点，将 DFS 设计为<u>首次进入当前状态时</u>能够获得的最大相对分差。虽然我从一开始就通过奇偶性正确区分了两个玩家的回合，但这样的 DFS 设计使我无法实现正确的算法。

我们知道记忆化搜索与动态规划通常是一体两面，实际上这里就体现了动态规划的无后效性：进入当前状态时已累积的相对分差很可能是不同的，因为这取决于此前每一步两个玩家的具体决策。我们唯一能确定的是对于这一个完全信息的博弈问题，自当前状态起能够获得的最优相对分差。

> 还有个不那么关键的踩坑，就是上文有提及的我起初并没有设计出相对分差，而是设计的双方各自的累积绝对得分——这显然就更无法实现正确的记忆化搜索了，因为相同的状态可能是从不同路径转移而来的，我们其实没法仅凭当前状态确定累积分数，根据当前状态只能确定未来能获得的最优分数。
>
> 可以看出，这个坑和 DFS 返回值设计的坑背后的原因是相同的，就是状态 $(i,j)$ 只能找到自此刻起的未来最优相对分差，无法知道过去的累积相对分差。

换句话说，我们只能通过最优子结构递归地求出子问题的解，父问题的解虽然依赖于子问题，但一个子问题却具有多个父问题，我们绝对不能简单地把第一个父问题当作子问题的所有父问题的解。正确的做法是在父问题中求解子问题（为避免重复求解于是考虑记忆化），然后让父问题利用子问题的解再解出自己的解，而不是期盼子问题在解中直接给出父问题的解。

在代码上的体现之一，就是对于相对分差变量究竟是选择设计为全局变量并在 DFS 过程中更新且由递归调用返回（状态泄露，唯一的$(i,j)$ 不对应唯一的全局变量），还是选择设计为 DFS 递归栈中的局部变量。后者才是正确的。

## 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。

```java
class Solution {

    private int[][] cache;  // score_cache[i][j]
    private int[] nums;
    private int n;

    public boolean predictTheWinner(int[] nums) {
        this.nums = nums;
        n = nums.length;
        cache = new int[n][n];
        for (int[] row : cache) {
            Arrays.fill(row, Integer.MIN_VALUE);
        }
        return dfs(0, n - 1) >= 0;
    }

    // 返回当前状态能够获得的最优相对分差
    private int dfs(int i, int j) {
        if (i > j) return 0;
        if (cache[i][j] != Integer.MIN_VALUE) return cache[i][j];

        // 如果 n - (j - i) 为奇数，意味着此时为玩家 1 的回合，否则为玩家 2 的回合
        boolean player1 = ((n - j + i) & 1) == 1;
        int relative;  // relative = socre1 - score2

        if (player1) {
            // player1
            int res1 = dfs(i + 1, j) + nums[i];
            int res2 = dfs(i, j - 1) + nums[j];
            relative = Math.max(res1, res2);
        } else {
            // player2
            int res1 = dfs(i + 1, j) - nums[i];
            int res2 = dfs(i, j - 1) - nums[j];
            relative = Math.min(res1, res2);
        }
        
        cache[i][j] = relative;
        return relative;
    }
}
```

# 区间 DP

## 思路

这个问题我是首先想到记忆化搜索的。我觉得 DP 并没有那么自然，至少我第一时间是先想到记忆化搜索，第二时间才通过记忆化搜索意识到可以等价转换为 DP。

从记忆化搜索的实现看，可以将自顶而下的记忆化搜索改造为自底而上的动态规划，状态设计为 $dp[i][j]$，$i,j$ 的定义与上文保持一致，$dp[i][j]$ 定义为在可选元素区间 $[i,j]$ 上能够贡献的最优相对分差（即自此刻开始、从 $0$ 开始记录的最优相对分差），那么状态转移方程为
$$
dp[i][j]=
\left\{\begin{align}
&\max\big\{dp[i+1][j]+\mathrm{nums}[i],\,dp[i][j-1]+\mathrm{nums}[j]\big\},&&\text{Round for player }1\\\\
&\min\big\{dp[i+1][j]-\mathrm{nums}[i],\,dp[i][j-1]-\mathrm{nums}[j]\big\},&&\text{Round for player }2
\end{align}\right.
$$
从定义上可以看出，这是一个区间 DP。我个人感觉区间 DP 问题用区间 DP 都没有相应的记忆化搜索直观。

不过本问题用区间 DP 的形式解决的好处是可以通过滚动数组降低空间开销，在逻辑上对上三角 DP 矩阵自底而上、从左至右的遍历更新。

## 代码

算法的时间复杂度为 $O(n^2)$，利用滚动数组将空间复杂度优化至 $O(n)$。

```java
class Solution {
    public boolean predictTheWinner(int[] nums) {
        int n = nums.length;
        int[] dp1 = new int[n];
        int[] dp2 = new int[n];

        for (int row = n - 1; row >= 0; row--) {
            dp1[row] = nums[row];
            for (int col = row + 1; col < n; col++) {
                boolean player1 = ((n - col + row) & 1) == 1;
                if (player1) {
                    dp2[col] = Math.max(dp1[col] + nums[row], dp2[col - 1] + nums[col]);
                } else {
                    dp2[col] = Math.min(dp1[col] - nums[row], dp2[col - 1] - nums[col]);
                }
            }

            int[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
        }

        return dp2[n - 1] >= 0;
    }
}
```

## 无需滚动

虽然滚动数组已经将空间复杂度从 $O(n^2)$ 降至 $O(n)$，但其实本问题无需滚动就可以做到这一点。

这得益于 DP 矩阵中每个元素严格只依赖于其下方元素（旧值）与左侧元素（新值）。

```java
class Solution {
    public boolean predictTheWinner(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];

        for (int row = n - 1; row >= 0; row--) {
            dp[row] = nums[row];
            for (int col = row + 1; col < n; col++) {
                boolean player1 = ((n - col + row) & 1) == 1;
                if (player1) {
                    dp[col] = Math.max(dp[col] + nums[row], dp[col - 1] + nums[col]);
                } else {
                    dp[col] = Math.min(dp[col] - nums[row], dp[col - 1] - nums[col]);
                }
            }
        }

        return dp[n - 1] >= 0;
    }
}
```

