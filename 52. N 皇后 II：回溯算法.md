题目简述：

> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n × n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回 **n 皇后问题** 不同的解决方案的数量。

题目链接：[52. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

# 代码

和 [51. N 皇后](https://leetcode.cn/problems/n-queens/) 没有任何区别。需要解析请移步至 [51. N 皇后](https://leetcode.cn/problems/n-queens/)，这里不再赘述，只给出代码实现。

```java
class Solution {
    public int totalNQueens(int n) {
        boolean[] col = new boolean[n];
        boolean[] diag = new boolean[1 + 2 * (n - 1)];
        boolean[] antiDiag = new boolean[1 + 2 * (n - 1)];
        return dfs(n, 0, col, diag, antiDiag, 0);
    }

    private int dfs(int n, int row, boolean[] col, boolean[] diag, boolean[] antiDiag, int queen) {
        if (queen == n) return 1;

        int num = 0;

        for (int j = 0; j < n; j++) {
            int diagIndex = calDiagIndex(n, row, j);
            int antiDiagIndex = calAntiDiagIndex(n, row, j);
            if (!col[j] && !diag[diagIndex] && !antiDiag[antiDiagIndex]) {
                col[j] = true;
                diag[diagIndex] = true;
                antiDiag[antiDiagIndex] = true;
                num += dfs(n, row + 1, col, diag, antiDiag, queen + 1);
                col[j] = false;
                diag[diagIndex] = false;
                antiDiag[antiDiagIndex] = false;
            }
        }

        return num;
    }

    private int calDiagIndex(int n, int i, int j) {
        // int tmp = Math.min(i, j);
        // i -= tmp;
        // j -= tmp;
        return (n - i - 1) + j;
    }

    private int calAntiDiagIndex(int n, int i, int j) {
        // int tmp = Math.min(i, n - j - 1);
        // i -= tmp;
        // j += tmp;
        return i + j;
    }
}
```

