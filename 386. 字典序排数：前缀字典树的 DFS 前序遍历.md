题目简述：

> 给你一个整数 `n` ，按字典序返回范围 `[1, n]` 内所有整数。
>
> 你必须设计一个时间复杂度为 `O(n)` 且使用 `O(1)` 额外空间的算法。

题目链接：[386. 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)

# 思路

视为一棵十叉树，每个节点存储一个数字，然后进行先序遍历即可。先序遍历的结果即为整数的字典序。

要注意的是首个数字不应为 $0$，因此可以视作存在一个不存储实际数字的虚拟根节点，但该虚拟根节点只有 $9$ 个直接子节点——不包含 $0$。这九个子节点作为根节点的每棵子树才是真正的十叉树。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {

    private List<Integer> res;
    private int n;

    public List<Integer> lexicalOrder(int n) {
        this.n = n;
        res = new ArrayList<>(n);
        for (int i = 1; i <= 9; i++) {
            if (i <= n) dfs(i);
        }
        return res;
    }

    private void dfs(int number) {
        res.add(number);

        number *= 10;
        for (int i = 0; i <= 9; i++) {
            int newNumber = number + i;
            if (newNumber <= n) {
                dfs(newNumber);
            } else {
                return;
            }
        }
    }
}
```

