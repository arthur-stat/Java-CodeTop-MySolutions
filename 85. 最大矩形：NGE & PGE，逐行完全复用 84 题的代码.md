题目简述：

> 给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

题目链接：[85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

# 思路

思路来自于 [直接调用 84 题代码解决（Python/Java/C++/C/Go/JS/Rust）| 灵茶山艾府](https://leetcode.cn/problems/maximal-rectangle/solutions/3704011/zhi-jie-diao-yong-84-ti-dai-ma-jie-jue-p-49at/)。

本题应完全复用 84 题的代码：

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxSqure = 0;
        int[] nextLess = nextLessElement(heights);
        int[] lastLess = nextLessElementInverse(heights);

        for (int i = 0; i < n; i++) {
            int last = lastLess[i];
            int next = nextLess[i];
            int squre;

            if (last != -1 && next != -1) {
                squre = heights[i] * (next - last - 1);
            } else if (last != -1) {
                squre = heights[i] * (n - last - 1);
            } else if (next != -1) {
                squre = heights[i] * next;
            } else {
                squre = heights[i] * n;
                
            }
            maxSqure = Math.max(maxSqure, squre);
        }
        return maxSqure;
    }

    // 从左至右扫描每个元素的下一个严格更小元素（单调栈），返回索引数组
    public int[] nextLessElement(int[] nums) {
        int n = nums.length;
        Deque<Integer> s = new ArrayDeque<>();
        int[] nextLess = new int[n];
        Arrays.fill(nextLess, -1);

        for (int i = 0; i < n; i++) {
            while (!s.isEmpty() && nums[s.peek()] > nums[i]) {
                int j = s.pop();
                nextLess[j] = i;
            }
            s.push(i);
        }
        return nextLess;
    }

    // 从右至左扫描每个元素的前一个严格更小元素（单调栈），返回索引数组
    public int[] nextLessElementInverse(int[] nums) {
        int n = nums.length;
        Deque<Integer> s = new ArrayDeque<>();
        int[] lastLess = new int[n];
        Arrays.fill(lastLess, -1);

        for (int i = n - 1; i >= 0; i--) {
            while (!s.isEmpty() && nums[s.peek()] > nums[i]) {
                int j = s.pop();
                lastLess[j] = i;
            }
            s.push(i);
        }
        return lastLess;
    }
}
```

具体的做法是：从最后一行遍历到第一行，遍历过程中将每一行视为底，计算各列的高度。对于其中的一行，各列高度计算方式为

- 如果该列上元素的值为 0，视高度为 0；
- 如果该列上元素的值为 1，则沿该列向上方延申，直到索引越界或探索到首个值为 0 的元素，此过程中访问了多少个元素，该列的高度就定义为多少。

当一行的各列高度能够进行确认后，就对该行应用 `largestRectangleArea` 方法，计算的结果即表示底边位于该行的最大面积矩形的面积值。这样就将每一行都转化为了一个子问题（第 84 题），即柱状图的最大矩形面积。

最终，当我们对每一行应用 `largestRectangleArea` 方法后，其中的最大值即为问题的解，即全局面积最大矩形的面积值——因为任何一个矩形一定有一个底边，而我们遍历了所有底边可能存在的行，得到的结果中就一定包含面积最大矩阵的面积值。

# 代码

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] heightsForRow = new int[n];

        int maxRectangle = 0;
        for (int row = m - 1; row >= 0; row--) {
            calculateHeightsForRow(matrix, row, heightsForRow);
            maxRectangle = Math.max(maxRectangle, SolutionForQuestion84.largestRectangleArea(heightsForRow));
        }

        return maxRectangle;
    }

    private void calculateHeightsForRow(char[][] matrix, int row, int[] res) {
        for (int i = 0; i < matrix[0].length; i++) {
            res[i] = 0;
            for (int j = row; j >= 0; j--) {
                if (matrix[j][i] == '1') {
                    res[i]++;
                } else {
                    break;
                }
            }
        }
    }
}

class SolutionForQuestion84 {
    public static int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxSqure = 0;
        int[][] tmp = scan(heights);
        int[] lastLess = tmp[0];
        int[] nextLess = tmp[1];

        for (int i = 0; i < n; i++) {
            int last = lastLess[i];
            int next = nextLess[i];
            int squre;

            if (last != -1 && next != 0) {
                squre = heights[i] * (next - last - 1);
            } else if (last != -1) {
                squre = heights[i] * (n - last - 1);
            } else if (next != 0) {
                squre = heights[i] * next;
            } else {
                squre = heights[i] * n;
                
            }
            maxSqure = Math.max(maxSqure, squre);
        }
        return maxSqure;
    }

    // 从左至右一次扫描，返回 lastLess 与 nextLess
    public static int[][] scan(int[] nums) {
        int n = nums.length;
        int[] lastLess = new int[n];
        int[] nextLess = new int[n];
        int[] stack = new int[n];
        int stackTop = -1;

        for (int i = 0; i < n; i++) {
            while (stackTop >= 0 && nums[stack[stackTop]] > nums[i]) {
                nextLess[stack[stackTop--]] = i;
            }
            lastLess[i] = stackTop >= 0 ? stack[stackTop] : -1;
            stack[++stackTop] = i;
        }
        return new int[][]{lastLess, nextLess};
    }
}
```

当前代码有一些可以改进的点，例如自顶行至末行更新高度能够实现增量更新，时间复杂度从 $O(m^2n)$ 降至 $O(mn)$。

但无论如何这些改良均并非重点，读者感兴趣可以自行优化，本解法的核心观点正如上所述，这里所给出的代码只是完全遵循思路的描述实现。

可考虑的优化点，加速算法：

- 自顶行至末行增量更新行高；
- `largestRectangleArea` 的一次正向单调栈扫描与一次反向单调栈扫描改为仅一次正向单调栈扫描，因为目前只利用了 “弹出的元素” 以得到一侧的边界， 但实际上 “尚留在栈内” 的元素能够直接得到另一侧的边界；
- 维护每行的左右边界，并在遍历到上一行时从边界开始计算行高，因为边界外的列不可能属于柱状图的最大矩形范围内，因此不必浪费算力。
