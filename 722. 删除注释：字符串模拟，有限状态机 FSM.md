题目简述：

> 给一个 C++ 程序，删除程序中的注释。这个程序`source`是一个数组，其中`source[i]`表示第 `i` 行源码。 这表示每行源码由 `'\n'` 分隔。
>
> 在 C++ 中有两种注释风格，行内注释和块注释。
>
> - 字符串`//` 表示行注释，表示`//`和其右侧的其余字符应该被忽略。
> - 字符串`/*` 表示一个块注释，它表示直到下一个（非重叠）出现的`*/`之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串`/*/`并没有结束块注释，因为注释的结尾与开头相重叠。
>
> 第一个有效注释优先于其他注释。
>
> - 如果字符串`//`出现在块注释中会被忽略。
> - 同样，如果字符串`/*`出现在行或块注释中也会被忽略。
>
> 如果一行在删除注释之后变为空字符串，那么**不要**输出该行。即，答案列表中的每个字符串都是非空的。
>
> 样例中**没有**控制字符，单引号或双引号字符。
>
> - 比如，`source = "string s = "/* Not a comment. */";"` 不会出现在测试样例里。
>
> 此外，没有其他内容（如定义或宏）会干扰注释。
>
> 我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的`/*`总是开始新的注释。
>
> 最后，隐式换行符**可以**通过块注释删除。 有关详细信息，请参阅下面的示例。
>
> 从源代码中删除注释后，需要以相同的格式返回源代码。

题目链接：[722. 删除注释](https://leetcode.cn/problems/remove-comments/)

# 思路

如果所有注释都在同一行内，那么是很容易处理的。这种情况下每一行的初始状态都可以被视为非注释块，查询块注释与行注释的起始关键字谁首次出现（`.indexOf("/*")` 与 `.indexOf("//")`），那么我们就优先处理谁，处理的逻辑是结算到达下一个注释起点前的非注释文本，然后指针再跳过注释，尝试寻找该行内的下一个非注释文本段。

考虑块注释，也并不难解决，仅需跨行记忆注释块的状态即可。我们只需要用一个布尔变量 `blockComment` 表示当前是否位于注释块内的状态，当且仅当在非跨行注释块情况下（`blockComment = false`）自当前索引起能够找到下一个位于行注释标记前的注释块起始标记，且本行内不存在相应的注释块结束标记时，我们才让状态 `blockComment` 从 `false` 转移至 `true`，结算非注释文本段并进入下一行。当我们进入了一个新的行时，若 `blockComment` 为 `false` 则意味着当前行初始状态为非注释块，那么按上文描述的逻辑处理即可，否则尝试寻找注释块结束标记，如果能够找到该标记则将指针移至结束标记后并更新状态 `blockComment` 为 `false` 然后再按上文描述的逻辑处理，如果找不到结束标记说明整行都属于注释块，于是可以直接跳过当前行，维持状态不变。

# 代码

```java
class Solution {
    public List<String> removeComments(String[] source) {
        List<String> res = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        boolean blockComment = false;

        for (String line : source) {
            if (!blockComment) sb.setLength(0);
            int start = 0;

            while (true) {
                if (start >= line.length() && !blockComment) {
                    if (!sb.isEmpty()) res.add(sb.toString());
                    break;
                }

                int slash = line.indexOf("//", start);
                int block = line.indexOf("/*", start);

                if (blockComment) {
                    int end = line.indexOf("*/");
                    if (end == -1) break;
                    start = end + 2;
                    blockComment = false;
                } else if (slash == -1 && block == -1) {
                    sb.append(line.substring(start));
                    if (!sb.isEmpty()) res.add(sb.toString());
                    break;
                } else if (block == -1 || (slash != -1 && slash < block)) {
                    sb.append(line.substring(start, slash));
                    if (!sb.isEmpty()) res.add(sb.toString());
                    break;
                } else if (slash == -1 || (block != -1 && block < slash)) {
                    int end = line.indexOf("*/", block + 2);
                    sb.append(line.substring(start, block));
                    if (end == -1) {
                        blockComment = true;
                        break;
                    } else {
                        start = end + 2;
                    }
                } else {
                    throw new RuntimeException();
                }
            }
        }

        return res;
    }
}
```

