题目简述：

> 给你一个只包含三种字符的字符串，支持的字符类型分别是 `'('`、`')'` 和 `'*'`。请你检验这个字符串是否为有效字符串，如果是 **有效** 字符串返回 `true` 。
>
> **有效** 字符串符合如下规则：
>
> - 任何左括号 `'('` 必须有相应的右括号 `')'`。
> - 任何右括号 `')'` 必须有相应的左括号 `'('` 。
> - 左括号 `'('` 必须在对应的右括号之前 `')'`。
> - `'*'` 可以被视为单个右括号 `')'` ，或单个左括号 `'('` ，或一个空字符串 `""`。

题目连接：[678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/)

# 动态规划

动态规划不是最优解，最坏时间复杂度始终为 $O(n^3)$，减枝优化也只能向 $O(n^2)$ 靠拢，但针对 `1 <= s.length <= 100` 的测试能够 AC。稍后会介绍 $O(n)$ 时间复杂度的贪心策略解决方案。

## 思路

直觉上，这应该是一个可以使用动态规划算法解决的问题（但事实上，动态规划不是该问题的最优解，时间复杂度比较高）。本问题与 [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) 存在一点相似性，但不同的是在那个问题中不存在通配符，并且最终需要计算的是最长有效括号子串的长度。而在这一问题中，我们要考虑通配符，但仅需要计算整个字符串是否为有效的括号串。

尝试定义布尔状态 $dp[i]$ 表示自 `s[0]` 起至 `s[i]` 的子串是否为有效括号，考虑状态转移：

- 如果 `s[i]` 为 `'('`，则 $dp[i]$ 必然为 $\mathrm{false}$；
- 可如果 `s[i]` 为 `')'` 或 `'*'` 呢？似乎无法再往下继续分析了。

究其原因，单变量的二值布尔状态 $dp[i]$ 本身无法直接提供可能与 `s[i]` 相匹配的 `'('` 的信息。要么尝试将布尔状态 $dp$ 定义为已知的以 `s[i]` 结尾的有效括号子串长度（一维 dp），要么尝试增加一个变量 $j$ 以表示有效括号子串起点（二维 dp）。我们考虑后者，看起来成功的可能更高。

重新定义布尔状态 $dp[i][j]$ 表示自 `s[i]` 起至 `s[j]` 的子串是否为有效括号，考虑状态转移：

1. 如果 `s[i]` 为 `'('` 且 `s[j]` 为 `')'`，假设 `s[i]` 恰匹配 `s[j]` 则 $dp[i][j]=dp[i+1][j-1]$，否则应考虑有效括号由若干子有效括号拼接而成的可能，为此需要寻找分割点，因此 $\displaystyle{dp[i][j]=\bigvee^{j-1}_{k=i}\big(dp[i][k]\land dp[k+1][j]\big)}$。综上，
   $$
   dp[i][j]=dp[i+1][j-1]\ \,\vee\ \left(\bigvee^{j-1}_{k=i}\big(dp[i][k]\land dp[k+1][j]\big)\right)
   $$

2. 如果 `s[i]` 为 `'*'` 且`s[j]` 为 `')'`，则 `'*'` 视为 `'('` 时等于第一种情况，`'*'` 视为空串时 $dp[i][j]=dp[i+1][j]$，因此
   $$
   dp[i][j]=dp[i+1][j-1]\ \lor\ dp[i+1][j]\ \,\vee\ \left(\bigvee^{j-1}_{k=i}\big(dp[i][k]\land dp[k+1][j]\big)\right)
   $$

3. 如果 `s[i]` 为 `'('` 且`s[j]` 为 `'*'`，则 `'*'` 视为 `')'` 时等于第一种情况，`'*'` 视为空串时 $dp[i][j]=dp[i][j-1]$，因此
   $$
   dp[i][j]=dp[i+1][j-1]\ \lor\ dp[i][j-1]\ \,\vee\ \left(\bigvee^{j-1}_{k=i}\big(dp[i][k]\land dp[k+1][j]\big)\right)
   $$

4. 如果 `s[i]` 与 `s[j]` 均为 `'*'`，则要么属于第一种情况、第二种情况、第三种情况，要么两个 `'*'` 均被视为空串，于是
   $$
   dp[i][j]=dp[i+1][j-1]\ \lor\ dp[i+1][j]\ \lor\ dp[i][j-1]\ \,\vee\ \left(\bigvee^{j-1}_{k=i}\big(dp[i][k]\land dp[k+1][j]\big)\right)
   $$

5. 其他任何情况下，$dp[i][j]=\mathrm{false}$

理论初始化条件：
$$
\forall i>j,\ \ dp[i][j]=\mathrm{false}
$$

$$
\forall i=j,\ \ dp[i][j]=\left\{\begin{align}&\mathrm{true},&&s[i]=\ '*\,'\\\\&\mathrm{false},&&s[i]\neq\ '*\,'\end{align}\right.
$$

此外，为适应 `"()"` 子串，需要额外初始化：
$$
\forall i>0,\ \ dp[i][i-1]=\mathrm{true}
$$
虽然该初始化无现实意义，但如果不这样做，则需要在每一次考虑 `s[i]` 为 `'('` 且 `s[j]` 为 `')'` 时额外判断是否有 $i+1=j$，如果是则赋 `true`。

最终 $dp[0][n-1]$ 即为问题的解。

## 代码

算法的时间复杂度均为 $O(n^3)$，空间复杂度为 $O(n^2)$，可以利用滚动数组优化空间复杂度至 $O(n)$。

```java
class Solution {
    public boolean checkValidString(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];  // 'false' init

        if (s.charAt(0) == '*') dp[0][0] = true;
        for (int i = 1; i < n; i++) {
            dp[i][i - 1] = true;
            if (s.charAt(i) == '*') dp[i][i] = true;
        }

        for (int row = n - 2; row >= 0; row--) {
            char c = s.charAt(row);

            col_loop:
            for (int col = row + 1; col < n; col++) {
                char cc = s.charAt(col);
                if (c != ')' && cc != '(') {
                    if (dp[row + 1][col - 1]) {
                        dp[row][col] = true;
                        continue;
                    }

                    for (int k = row; k < col; k++) {
                        if (dp[row][k] && dp[k + 1][col]) {
                            dp[row][col] = true;
                            continue col_loop;
                        }
                    }

                    if (c == '*' && dp[row + 1][col]) {
                        dp[row][col] = true;
                        continue;
                    }

                    if (cc == '*' && dp[row][col - 1]) {
                        dp[row][col] = true;
                        continue;
                    }
                }
            }
        }

        return dp[0][n - 1];
    }
}
```

# 贪心算法

贪心算法为本问题的最优解，能够做到 $O(n)$ 的时间复杂度与 $O(1)$ 的空间复杂度。

可以用两个栈显式地模拟贪心算法的逻辑，即所谓的双栈解法，但我认为没有必要，因为其核心仍为贪心策略，只不过显式化了 “括号匹配” 的过程。

## 思路

贪心算法在本问题中是这样的思路：使用两个变量 `less` 与 `more` 分别表示完成当前子串的有效匹配所需的最少左括号数量（视 `'*'` 为 `')'`）以及最多左括号的数量（视 `'*'` 为 `'('`），遍历字符串，然后

- 如果 `s[i]` 为 `'('`，则 `less++`、`more++`

- 如果 `s[i]` 为 `')'`，则 `less--`、`more--`

- 否则 `s[i]` 为 `'*'` ，则 `less--`、`more++`
- 必须保证 `less` 非负，因为如果右括号过多意味当前并不需要为左括号匹配，这点可以通过当 `less` 为负时重新赋 0 达到。
- 如果 `more` 为负数（在任何时刻），则意味着我们已经尽力匹配 `')'` 但仍有剩余 `')'` 无法完成匹配，这意味着该字符串一定非法。

当扫描结束时，如果 `less` 为正数，则意味着即使我们将所有的 `'*'` 均视为 `')'` 或空串仍无法匹配掉全部的 `'('`，这意味着字符串非法。

## 代码

```java
class Solution {
    public boolean checkValidString(String s) {
        int less = 0;
        int more = 0;

        for (char c : s.toCharArray()) {
            if (c == '(') {
                less++;
                more++;
            } else if (c == ')') {
                less = Math.max(0, less - 1);
                more--;
                if (more < 0) return false;
            } else {
                less = Math.max(0, less - 1);
                more++;
            }
        }

        return less == 0;
    }
}
```

# 双栈模拟

## 思路

本质上仍是贪心策略，与贪心算法的实现没有本质区别，反而空间复杂度为更高的 $O(n)$。

原理同上，别无二致。

请结合代码，代码的变量名起得非常细致。

---

- 使用两个栈：
  - `leftStack` 记录所有 `'('` 的下标
  - `starStack` 记录所有 `'*'` 的下标

从左到右扫描字符串：

- 如果遇到 `'('`：压入 `leftStack`
- 如果遇到 `'*'`：压入 `starStack`
- 如果遇到 `')'`：
  - 如果 `leftStack` 不为空，弹出一个 `'('`
  - 否则如果 `starStack` 不为空，弹出一个 `'*'`（作为 `'('`）
  - 否则：非法，返回 false

最后：

- `leftStack` 中可能还有剩余的 `'('`，看能否用 `'*'` 来匹配它们。
- 注意要保证：每个 `'*'` 的位置要在右边（即下标大于 `'('`）

## 代码

```java
class Solution {
    public boolean checkValidString(String s) {
        Deque<Integer> leftParenthesesStack = new ArrayDeque<>();
        Deque<Integer> asteriskStack = new ArrayDeque<>();

        char[] ss = s.toCharArray();
        for (int i = 0; i < ss.length; i++) {
            if (ss[i] == '(') {
                leftParenthesesStack.push(i);
            } else if (ss[i] == '*') {
                asteriskStack.push(i);
            } else {
                if (!leftParenthesesStack.isEmpty()) {
                    leftParenthesesStack.pop();
                } else {
                    if (!asteriskStack.isEmpty()) {
                        asteriskStack.pop();
                    } else {
                        return false;
                    }
                }
            }
        }

        while (!leftParenthesesStack.isEmpty()) {
            int leftParenthesesIndex = leftParenthesesStack.pop();
            int asteriskIndex;
            if (asteriskStack.isEmpty()) {
                return false;
            } else {
                asteriskIndex = asteriskStack.pop();
            }

            if (leftParenthesesIndex > asteriskIndex) return false;
        }

        return true;
    }
}
```

