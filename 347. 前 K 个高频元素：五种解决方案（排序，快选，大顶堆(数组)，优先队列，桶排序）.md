é¢˜ç›®ç®€è¿°ï¼š

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ `k` é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
> **æç¤ºï¼š**
>
> - é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå”¯ä¸€ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°ç»„ä¸­å‰ `k` ä¸ªé«˜é¢‘å…ƒç´ çš„é›†åˆæ˜¯å”¯ä¸€çš„
>
> **è¿›é˜¶ï¼š**ä½ æ‰€è®¾è®¡ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ **å¿…é¡»** ä¼˜äº `O(n log n)` ï¼Œå…¶ä¸­ `n` æ˜¯æ•°ç»„å¤§å°ã€‚

é¢˜ç›®è¿æ¥ï¼š[347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)

# åˆ†æ

è¯»å®Œé¢˜ç›®åï¼Œ æˆ‘çš„ç¬¬ä¸€æƒ³æ³•æ˜¯ç›´æ¥éå†ä¸€æ¬¡æ•°ç»„ï¼ŒåŒæ—¶ç”¨ä¸€å¼ å“ˆå¸Œè¡¨è®¡æ•°ï¼Œéå†å®Œæˆæ—¶å³å¯å¾—åˆ°æ¯ä¸ªæ•°å­—çš„é¢‘æ•°ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

æ¥ç€æˆ‘ä»¬å°†æ•°å­—ä¸å¯¹åº”çš„é¢‘æ•°ç»„æˆ pairï¼Œå†åˆ©ç”¨å¿«é€Ÿé€‰æ‹©ç®—æ³•æˆ–å¤§é¡¶å †å³å¯å¾—åˆ°é¢‘ç‡å‰ $k$ é«˜çš„ pairï¼Œpair ä¸­åŒ…å«äº†å¯¹åº”çš„æ•°å­—ã€‚è¿™ä¸€æ­¥çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(k\log n)$ã€‚

ä½†å…¶å®ä¹Ÿå¯ä»¥ç›´æ¥å¯¹ pair æ•°ç»„æ’åºï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦ä¸º $O(n\log n)$ã€‚

è¿™æ ·æˆ‘ä»¬èƒ½å¾—åˆ°æœ€ç»ˆç»“æœï¼Œå¦‚æœç›´æ¥å¯¹ pair æ•°ç»„æ’åºåˆ™æ—¶é—´å¤æ‚åº¦ä¸º $O(n\log n)$ï¼Œå¦‚æœè€ƒè™‘å¿«é€Ÿé€‰æ‹©æˆ–å¤§é¡¶å †åˆ™å¤æ‚åº¦ä¸º $O(k\log n)$ï¼Œå…¶ä¸­å¿«é€Ÿé€‰æ‹©çš„æ–¹æ¡ˆå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚

å¿«é€Ÿé€‰æ‹©ä¸å¤§é¡¶å †æ˜¯ä¸“é—¨ç”¨æ¥è§£å†³ Top-K é—®é¢˜çš„ç®—æ³•ï¼Œè¿™é‡Œé€šè¿‡é¢‘æ•°ç»Ÿè®¡å°† FreqTop-K é—®é¢˜è½¬æ¢ä¸ºäº† ValTop-Kã€‚

---

ä»¥ä¸Šæ–¹æ¡ˆéƒ½æ˜¾å¼ç»Ÿè®¡é¢‘æ•°å¹¶ä½¿ç”¨ pair è®¡æ•°ã€‚é™¤äº†ä»¥ä¸Šæ–¹æ¡ˆï¼Œè¿˜å¯ä»¥è€ƒè™‘æ¡¶æ’åºï¼Œè¿™æ˜¯å”¯ä¸€ä¸€ç§èƒ½ä¿è¯æœ€å $O(n)$ æ—¶é—´å¤æ‚åº¦çš„æ–¹æ¡ˆã€‚æˆ‘ç¬¬ä¸€æ—¶é—´å¹¶æœªæƒ³åˆ°ã€‚

è™½ç„¶æ¡¶æ’åºå¯¹äºæœ¬é—®é¢˜ç†è®ºä¸Šæœ€ä½³ï¼Œä½†åœ¨è®¸å¤šåœºæ™¯ä¸‹å®é™…æ€§èƒ½è¡¨ç°å´ä¸ä¸€å®šä¼˜äºå¿«é€Ÿé€‰æ‹©ã€‚æˆ‘ä¼šç»™å‡ºæ‰€æœ‰æåŠæ–¹æ¡ˆçš„å®ç°ï¼Œå¯ä»¥ä½œä¸ºæ€§èƒ½å¯¹ç…§å‚è€ƒã€‚

DeepSeek-R1 æ€»ç»“ï¼š

> 1. **å‡†å¤‡ä¸€å †ç©ºæ¡¶** ğŸª£
>
> - æ¯ä¸ªæ¡¶çš„ç¼–å·ä»£è¡¨ **æ•°å­—å‡ºç°çš„é¢‘ç‡**ï¼ˆæ¯”å¦‚1å·æ¡¶è£…å‡ºç°1æ¬¡çš„æ•°å­—ï¼Œ2å·æ¡¶è£…å‡ºç°2æ¬¡çš„æ•°å­—ï¼Œä¾æ­¤ç±»æ¨ï¼‰ã€‚
> - æ¡¶çš„æ€»æ•°ç”± **æœ€å¤§å¯èƒ½é¢‘ç‡** å†³å®šï¼ˆä½ çš„ä»£ç ä¸­ç›´æ¥ä½¿ç”¨ `nums.length + 1`ï¼Œå› ä¸ºé¢‘ç‡æœ€å¤šä¸ºæ•°ç»„é•¿åº¦ï¼‰ã€‚
>
> 2. **æŠŠæ•°å­—æ‰”è¿›å¯¹åº”çš„æ¡¶é‡Œ** ğŸ”¢â†’ğŸª£
>
> - ç»Ÿè®¡æ¯ä¸ªæ•°å­—çš„é¢‘ç‡åï¼Œæ ¹æ®é¢‘ç‡å€¼å°†æ•°å­—æ”¾å…¥å¯¹åº”ç¼–å·çš„æ¡¶ä¸­ã€‚
> - ä¾‹å¦‚ï¼š
>   - æ•°å­— `3` å‡ºç° `2` æ¬¡ â†’ æ‰”è¿› `2` å·æ¡¶ã€‚
>   - æ•°å­— `5` å‡ºç° `5` æ¬¡ â†’ æ‰”è¿› `5` å·æ¡¶ã€‚
>
> 3. **ä»é«˜åˆ°ä½å€’å‡ºæ¡¶é‡Œçš„æ•°å­—** ğŸ“¤
>
> - ä»ç¼–å·æœ€å¤§çš„æ¡¶å¼€å§‹å€’ï¼ˆå› ä¸ºé«˜é¢‘æ•°å­—åœ¨å‰ï¼‰ï¼Œä¾æ¬¡å–å‡ºæ•°å­—ï¼Œç›´åˆ°å‡‘æ»¡ `k` ä¸ªã€‚
> - **å°±åƒå€’æ°´ä¸€æ ·**ï¼šå…ˆå€’æœ€æ»¡çš„æ¡¶ï¼ˆé«˜é¢‘ï¼‰ï¼Œå†å€’æ¬¡æ»¡çš„æ¡¶ï¼ˆä½é¢‘ï¼‰ã€‚

GPT-4o ç‚¹è¯„ï¼š

> *æ¡¶æ’åºæ˜¯ä¸€ç§é—®é¢˜ç‰¹åŒ–çš„åˆ†å¸ƒå¼æ’åºç­–ç•¥ï¼Œåœ¨åˆé€‚çš„åœºæ™¯ä¸­è¡¨ç°æå…¶å‡ºè‰²ï¼ˆå¦‚æœ¬é¢˜ï¼‰ï¼Œä½†å®ƒå¹¶ä¸æ˜¯é€šç”¨æ’åºç®—æ³•ï¼Œæ— æ³•ä»£æ›¿å¿«æ’ã€å †æ’ã€å½’å¹¶è¿™ç±»åŸºäºæ¯”è¾ƒçš„é€šç”¨æ¯”è¾ƒæ’åºã€‚*

å¯¹äºä¸€èˆ¬æ„ä¹‰ä¸Šçš„æ¡¶æ’åºï¼Œæ¡¶çš„ç¼–å·ä»£è¡¨çš„æ˜¯å€¼çš„èŒƒå›´ï¼Œè€Œéé¢‘æ•°ã€‚å¯¹äºæœ¬é—®é¢˜æˆ‘ä»¬è€ƒè™‘ä¸ºé¢‘æ•°ï¼Œæ˜¯å‡ºäºå’Œç‰¹åŒ–ç‰ˆæœ¬çš„å¿«é€Ÿé€‰æ‹©ä¸å¤§é¡¶å †ç›¸åŒçš„ç›®çš„ï¼šé€šè¿‡é¢‘æ•°ç»Ÿè®¡å°† FreqTop-K é—®é¢˜è½¬æ¢ä¸º ValTop-Kã€‚

# è®¡æ•° + æ’åº

AC å®é™…è€—æ—¶ 14 msï¼Œè¶…è¿‡ 35.24% çš„ä»£ç ã€‚

```java
class Solution {

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        Arrays.sort(pairs, (a, b) -> a.frequency - b.frequency);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pairs[pairs.length - i - 1].value;
        }

        return res;
    }
}
```

# è®¡æ•° + å¿«é€Ÿé€‰æ‹©

AC å®é™…è€—æ—¶ 11 msï¼Œè¶…è¿‡ 89.74% çš„ä»£ç ã€‚

```java
class Solution {

    Random rand = new Random(0);
    int found;

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        found = 0;
        quickselect(pairs, 0, pairs.length - 1, k);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pairs[pairs.length - i - 1].value;
        }

        return res;
    }

    private void quickselect(Pair[] pairs, int low, int high, int k) {
        if (low > high) return;

        int left = low;
        int right = high;
        int i = low;

        int pivotIndex = low + rand.nextInt(high - low + 1);
        int pivot = pairs[pivotIndex].frequency;
        while (i <= right) {
            if (pairs[i].frequency < pivot) {
                swap(pairs, left, i);
                left++;
                i++;
            } else if (pairs[i].frequency == pivot) {
                i++;
            } else {
                swap(pairs, right, i);
                right--;
            }
        }

        if (right + 1 >= pairs.length - k) {
            int limitedLeft = Math.max(left, pairs.length - k);
            found += right - limitedLeft + 1;
            if (found == k) return;
        }

        quickselect(pairs, low, left - 1, k);
        quickselect(pairs, right + 1, high, k);
    }

    private void swap(Pair[] pairs, int i, int j) {
        Pair tmp = pairs[i];
        pairs[i] = pairs[j];
        pairs[j] = tmp;
    }
}
```

# è®¡æ•° + å¤§é¡¶å †ï¼ˆæ•°ç»„ï¼‰

AC å®é™…è€—æ—¶ 12 msï¼Œè¶…è¿‡ 86.41% çš„ä»£ç ã€‚

```java
class Solution {

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        MyPq pq = new MyPq(pairs);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll().value;
        }

        return res;
    }

    private class MyPq {

        Pair[] pairs;
        int size;

        public MyPq(Pair[] pairs) {
            this.pairs = pairs;
            this.size = pairs.length;
            for (int i = pairs.length / 2 - 1; i >= 0; i--) {
                shiftDown(i);
            }
        }

        private void shiftDown(int i) {
            int left = left(i);
            int right = right(i);

            while ((check(left) && pairs[i].frequency < pairs[left].frequency) || 
                (check(right) && pairs[i].frequency < pairs[right].frequency)) {

                int less;
                if (check(left) && check(right)) {
                    less = pairs[left].frequency > pairs[right].frequency ? left : right;
                } else {
                    less = check(left) ? left : right;
                }
                swap(i, less);
                i = less;
                left = left(i);
                right = right(i);
            }
        }

        private Pair poll() {
            Pair res = pairs[0];
            swap(0, size - 1);
            size--;
            shiftDown(0);
            return res;
        }

        private void swap(int i, int j) {
            Pair tmp = pairs[i];
            pairs[i] = pairs[j];
            pairs[j] = tmp;
        }

        private int left(int i) {
            return 2 * i + 1;
        }

        private int right(int i) {
            return 2 * i + 2;
        }

        private int parent(int i) {
            return (i - 1) / 2;
        }

        private boolean check(int i) {
            return i >= 0 && i < size;
        }
    }
}
```

# è®¡æ•° + å¤§é¡¶å †ï¼ˆä¼˜å…ˆçº§é˜Ÿåˆ—ï¼‰

AC å®é™…è€—æ—¶ 13 msï¼Œè¶…è¿‡ 63.21% çš„ä»£ç ã€‚

```java
class Solution {

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.frequency - a.frequency);
        pq.addAll(Arrays.asList(pairs));
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll().value;
        }

        return res;
    }
}
```

# è®¡æ•° + æ¡¶æ’åº

AC å®é™…è€—æ—¶ 11 msï¼Œè¶…è¿‡ 89.74% çš„ä»£ç ã€‚

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        List<Integer>[] buckets = new List[nums.length + 1];
        for (int key : count.keySet()) {
            int freq = count.get(key);
            if (buckets[freq] == null) {
                buckets[freq] = new ArrayList<>();
            }
            buckets[freq].add(key);
        }

        List<Integer> result = new ArrayList<>();
        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {
            if (buckets[i] != null) {
                result.addAll(buckets[i]);
            }
        }

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = result.get(i);
        }
        return res;
    }
}
```
