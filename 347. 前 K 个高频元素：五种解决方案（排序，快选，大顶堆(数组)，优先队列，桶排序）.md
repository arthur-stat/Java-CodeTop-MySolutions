题目简述：

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
>
> **提示：**
>
> - 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的
>
> **进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

题目连接：[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

# 分析

读完题目后， 我的第一想法是直接遍历一次数组，同时用一张哈希表计数，遍历完成时即可得到每个数字的频数，时间复杂度为 $O(n)$。

接着我们将数字与对应的频数组成 pair，再利用快速选择算法或大顶堆即可得到频率前 $k$ 高的 pair，pair 中包含了对应的数字。这一步的时间复杂度为 $O(k\log n)$。

但其实也可以直接对 pair 数组排序，这样时间复杂度为 $O(n\log n)$。

这样我们能得到最终结果，如果直接对 pair 数组排序则时间复杂度为 $O(n\log n)$，如果考虑快速选择或大顶堆则复杂度为 $O(k\log n)$，其中快速选择的方案平均时间复杂度为 $O(n)$，最坏时间复杂度为 $O(n^2)$。

快速选择与大顶堆是专门用来解决 Top-K 问题的算法，这里通过频数统计将 FreqTop-K 问题转换为了 ValTop-K。

---

以上方案都显式统计频数并使用 pair 计数。除了以上方案，还可以考虑桶排序，这是唯一一种能保证最坏 $O(n)$ 时间复杂度的方案。我第一时间并未想到。

虽然桶排序对于本问题理论上最佳，但在许多场景下实际性能表现却不一定优于快速选择。我会给出所有提及方案的实现，可以作为性能对照参考。

DeepSeek-R1 总结：

> 1. **准备一堆空桶** 🪣
>
> - 每个桶的编号代表 **数字出现的频率**（比如1号桶装出现1次的数字，2号桶装出现2次的数字，依此类推）。
> - 桶的总数由 **最大可能频率** 决定（你的代码中直接使用 `nums.length + 1`，因为频率最多为数组长度）。
>
> 2. **把数字扔进对应的桶里** 🔢→🪣
>
> - 统计每个数字的频率后，根据频率值将数字放入对应编号的桶中。
> - 例如：
>   - 数字 `3` 出现 `2` 次 → 扔进 `2` 号桶。
>   - 数字 `5` 出现 `5` 次 → 扔进 `5` 号桶。
>
> 3. **从高到低倒出桶里的数字** 📤
>
> - 从编号最大的桶开始倒（因为高频数字在前），依次取出数字，直到凑满 `k` 个。
> - **就像倒水一样**：先倒最满的桶（高频），再倒次满的桶（低频）。

GPT-4o 点评：

> *桶排序是一种问题特化的分布式排序策略，在合适的场景中表现极其出色（如本题），但它并不是通用排序算法，无法代替快排、堆排、归并这类基于比较的通用比较排序。*

对于一般意义上的桶排序，桶的编号代表的是值的范围，而非频数。对于本问题我们考虑为频数，是出于和特化版本的快速选择与大顶堆相同的目的：通过频数统计将 FreqTop-K 问题转换为 ValTop-K。

# 计数 + 排序

AC 实际耗时 14 ms，超过 35.24% 的代码。

```java
class Solution {

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        Arrays.sort(pairs, (a, b) -> a.frequency - b.frequency);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pairs[pairs.length - i - 1].value;
        }

        return res;
    }
}
```

# 计数 + 快速选择

AC 实际耗时 11 ms，超过 89.74% 的代码。

```java
class Solution {

    Random rand = new Random(0);
    int found;

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        found = 0;
        quickselect(pairs, 0, pairs.length - 1, k);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pairs[pairs.length - i - 1].value;
        }

        return res;
    }

    private void quickselect(Pair[] pairs, int low, int high, int k) {
        if (low > high) return;

        int left = low;
        int right = high;
        int i = low;

        int pivotIndex = low + rand.nextInt(high - low + 1);
        int pivot = pairs[pivotIndex].frequency;
        while (i <= right) {
            if (pairs[i].frequency < pivot) {
                swap(pairs, left, i);
                left++;
                i++;
            } else if (pairs[i].frequency == pivot) {
                i++;
            } else {
                swap(pairs, right, i);
                right--;
            }
        }

        if (right + 1 >= pairs.length - k) {
            int limitedLeft = Math.max(left, pairs.length - k);
            found += right - limitedLeft + 1;
            if (found == k) return;
        }

        quickselect(pairs, low, left - 1, k);
        quickselect(pairs, right + 1, high, k);
    }

    private void swap(Pair[] pairs, int i, int j) {
        Pair tmp = pairs[i];
        pairs[i] = pairs[j];
        pairs[j] = tmp;
    }
}
```

# 计数 + 大顶堆（数组）

AC 实际耗时 12 ms，超过 86.41% 的代码。

```java
class Solution {

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        MyPq pq = new MyPq(pairs);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll().value;
        }

        return res;
    }

    private class MyPq {

        Pair[] pairs;
        int size;

        public MyPq(Pair[] pairs) {
            this.pairs = pairs;
            this.size = pairs.length;
            for (int i = pairs.length / 2 - 1; i >= 0; i--) {
                shiftDown(i);
            }
        }

        private void shiftDown(int i) {
            int left = left(i);
            int right = right(i);

            while ((check(left) && pairs[i].frequency < pairs[left].frequency) || 
                (check(right) && pairs[i].frequency < pairs[right].frequency)) {

                int less;
                if (check(left) && check(right)) {
                    less = pairs[left].frequency > pairs[right].frequency ? left : right;
                } else {
                    less = check(left) ? left : right;
                }
                swap(i, less);
                i = less;
                left = left(i);
                right = right(i);
            }
        }

        private Pair poll() {
            Pair res = pairs[0];
            swap(0, size - 1);
            size--;
            shiftDown(0);
            return res;
        }

        private void swap(int i, int j) {
            Pair tmp = pairs[i];
            pairs[i] = pairs[j];
            pairs[j] = tmp;
        }

        private int left(int i) {
            return 2 * i + 1;
        }

        private int right(int i) {
            return 2 * i + 2;
        }

        private int parent(int i) {
            return (i - 1) / 2;
        }

        private boolean check(int i) {
            return i >= 0 && i < size;
        }
    }
}
```

# 计数 + 大顶堆（优先级队列）

AC 实际耗时 13 ms，超过 63.21% 的代码。

```java
class Solution {

    private class Pair {
        int value;
        int frequency;

        public Pair (Map.Entry<Integer, Integer> entry) {
            value = entry.getKey();
            frequency = entry.getValue();
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        Pair[] pairs = new Pair[count.size()];
        int n = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            pairs[n++] = new Pair(entry);
        }

        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.frequency - a.frequency);
        pq.addAll(Arrays.asList(pairs));
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll().value;
        }

        return res;
    }
}
```

# 计数 + 桶排序

AC 实际耗时 11 ms，超过 89.74% 的代码。

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            int freq = count.getOrDefault(num, 0);
            count.put(num, freq + 1);
        }

        List<Integer>[] buckets = new List[nums.length + 1];
        for (int key : count.keySet()) {
            int freq = count.get(key);
            if (buckets[freq] == null) {
                buckets[freq] = new ArrayList<>();
            }
            buckets[freq].add(key);
        }

        List<Integer> result = new ArrayList<>();
        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {
            if (buckets[i] != null) {
                result.addAll(buckets[i]);
            }
        }

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = result.get(i);
        }
        return res;
    }
}
```
