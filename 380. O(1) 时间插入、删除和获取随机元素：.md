题目简述：

> 实现`RandomizedSet` 类：
>
> - `RandomizedSet()` 初始化 `RandomizedSet` 对象
> - `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
> - `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
> - `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。
>
> 你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。

题目链接：[380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

# 思路

根据题意，显然是不需要记忆元素更新顺序的。

- `insert(int val)` 显然是 Set 的逻辑；
- `remove(int val)` 显然也是，这两个方法便是典型的 Set 的方法；
- 但 `getRandom()` 就需要我们仔细想一想了，通常的 Set 不能保证以 $O(1)$ 的平均实现复杂度实现这一点。例如 HashSet 只能判断元素是否存在于集合内，无法等概率随机地得到一个元素。

在计算机中要实现伪随机，我们应考虑伪随机数生成器。但由于 Set 不存在索引，即使有伪随机数我们也无法随机获取元素。因此考虑 List。对于 List，可以以 $O(1)$ 的时间复杂度得到元素，然而 List 本身又无法以 $O(1)$ 时间复杂度实现 `insert(int val)` 与 `remove(int val)` 的存在性判断的逻辑。

因此可能需要结合两者的特性。首先考虑 ArrayList 帮助我们随机得到元素，接着为高效判断存在性，我们同时维护一个 Map 做元素到元素在 ArrayList 上的位置的映射，即元素作为 key，ArrayList 上的索引作为 value。

- `bool insert(int val)`：当 `val` 作为 key 存在于 Map 中，返回 `false`；否则，将 `val` 插入到 ArrayList 的尾部，并在 Map 中将 `val` 映射到 ArrayList 尾部的索引，返回 `true`。

- `bool remove(int val)`：当 `val` 作为 key 不存在于 Map 中，返回 `false`；否则，通过 Map 找到 `val` 在 ArrayList 中的索引，记为 `i`，然后获取 ArrayList 的末尾元素，记为 `tail`，交换 `val` 与 `tail`，然后删除末位元素，接着在 Map 中删除 key `val`，并更新 `tail` 的映射为 `i`，最后返回 `true`。

  这里交换元素的原因是确保删除元素后 ArrayList 是连续的、不存在已失效元素，否则 `getRandom()` 无法确认得到的元素是否实际上应已被删除。

- `int getRandom()`：利用随机数生成器生成随机索引，然后在 ArrayList 中随机取元素即可。

如果做过 [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)，那么对这样的复合基本数据结构的问题一定不会陌生，一下就能找到大概思路。

# 代码

每个操作的平均时间复杂度均为 $O(1)$。

```java
class RandomizedSet {

    Random rand = new Random();
    ArrayList<Integer> list;
    Map<Integer, Integer> map;

    public RandomizedSet() {
        list = new ArrayList<>();
        map = new HashMap<>();
    }
    
    public boolean insert(int val) {
        if (map.containsKey(val)) return false;
        list.add(val);
        map.put(val, list.size() - 1);
        return true;
    }
    
    public boolean remove(int val) {
        Integer index = map.getOrDefault(val, null);
        if (index == null) return false;
        if (index.equals(list.size() - 1)) {
            list.removeLast();
            map.remove(val);
        } else {
            Integer swapVal = list.getLast();
            swap(list, index, list.size() - 1);
            list.removeLast();
            map.remove(val);
            map.put(swapVal, index);
        }
        return true;
    }
    
    public int getRandom() {
        int r = rand.nextInt(list.size());
        return list.get(r);
    }

    private void swap(ArrayList<Integer> list, Integer i, Integer j) {
        Integer tmp = list.get(i);
        list.set(i, list.get(j));
        list.set(j, tmp);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

