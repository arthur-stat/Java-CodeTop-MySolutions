题目简述：

> 给你一个由数字和运算符组成的字符串 `expression` ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。
>
> 生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 `10^4` 。
>
> **提示：**
>
> - `1 <= expression.length <= 20`
> - `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
> - 输入表达式中的所有整数值在范围 `[0, 99]` 
> - 输入表达式中的所有整数都没有前导 `'-'` 或 `'+'` 表示符号。

题目链接：[241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

# 思路

仔细思考了一下，这算是一个典型的分治算法问题。

> 受到了数据范围 `1 <= expression.length <= 20` 的启发，所以根本就不去考虑 $n$ 的多项式数量级时间复杂度的方案，否则题目是不可能给这么短的 `expression` 的。

实际上就是说任意挑选两个相邻的数字对他们优先计算，这一步可以视为对他们的运算加小括号，那么计算完该运算后，结果数字的左右两侧剩余的表达式就变成了两个结构相同的子问题。

但为了方便实现算法，我们考虑最后计算哪一个运算符。不难证明，考虑最先计算哪一个运算符与最后计算哪一个运算符，最终都会完整遍历相同的解空间，因此都能算出正确结果。

> 如果考虑优先计算哪一个运算符，计算完该运算后需要更新表达式。如果考虑内存连续的数据结构，例如数组，不可避免地需要一个新的对象以存放新表达式；如果考虑内存离散的数据结构，例如链表，我们也不得不首先克隆一份对象，否则无法保证 DFS 过程中不同分支的相互独立。这个问题是考虑优先计算哪一个运算符时需要保证计算的数字在当前状态下 “相邻” 造成的，维护 “相邻” 的代价在这里是很大的。
>
> 但考虑最后计算谁就容易得多了，因为这时我们不必先对两个相邻的数字进行计算，我们只需要先计算运算符左侧的所有可能的结果数字，再计算运算符左侧的所有可能的结果数字，然后将这两组数字遍历运算即可。这就是标准的分治算法思路。

# 代码

算法的时间复杂度是 $O(C_n)$，其中 $C$ 表示卡特兰数。

```java
class Solution {

    public List<Integer> diffWaysToCompute(String expression) {
        List[] parsed = parse(expression.toCharArray());
        List<Integer> nums = (List<Integer>) parsed[0];
        List<Character> ops = (List<Character>) parsed[1];
        return dfs(nums, 0, nums.size() - 1, ops, 0, ops.size() - 1);
    }

    public List<Integer> dfs(List<Integer> nums, int lo1, int hi1, List<Character> ops, int lo2, int hi2) {
        if (lo1 == hi1) return List.of(nums.get(lo1));

        List<Integer> res = new ArrayList<>();

        for (int i = lo2; i <= hi2; i++) {
            char op = ops.get(i);
            List<Integer> leftRes = dfs(nums, lo1, i, ops, lo2, i - 1);
            List<Integer> rightRes = dfs(nums, i + 1, hi1, ops, i + 1, hi2);
            for (int l : leftRes) {
                for (int r : rightRes) {
                    res.add(cal(l, r, op));
                }
            }
        }

        return res;
    }

    public List[] parse(char[] expression) {
        List[] res = new List[]{new ArrayList<Integer>(), new ArrayList<Character>()};
        int i = 0;
        int n = expression.length;
        int number = 0;

        while (i < n) {
            if (Character.isDigit(expression[i])) {
                while (i < n && Character.isDigit(expression[i])) {
                    number = number * 10 + expression[i++] - '0';
                }
                res[0].add(number);
                number = 0;
            } else {
                res[1].add(expression[i++]);
            }
        }

        return res;
    }

    public int cal(int a, int b, char op) {
        if (op == '+') return a + b;
        if (op == '-') return a - b;
        if (op == '*') return a * b;
        throw new RuntimeException();
    }
}
```

