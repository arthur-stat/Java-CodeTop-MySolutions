题目简述：

> 给定一个非负整数，你**至多**可以交换一次数字中的任意两位。返回你能得到的最大值。
>
> 给定数字的范围是 [0, 108]

题目链接：[670. 最大交换](https://leetcode.cn/problems/maximum-swap/)

# 暴力枚举

## 思路

直接暴力枚举完全能 AC，效率还挺高的，因为本来组合数就不多。最多 45 个。

## 代码

```java
class Solution {

    private int num;
    private static final int[] POW10 = {
        1,
        10,
        100,
        1_000,
        10_000,
        100_000,
        1_000_000,
        10_000_000,
        100_000_000,
        1_000_000_000
    };

    public int maximumSwap(int num) {
        this.num = num;
        int place = getPlace();
        int res = num;

        for (int i = 0; i < place; i++) {
            for (int j = i; j < place; j++) {
                res = Math.max(res, swap(i, j));
            }
        }

        return res;
    }

    // for example: swap(123, 0, 1) = 132
    private int swap(int i, int j) {
        int digit_i = num % POW10[i + 1] / POW10[i];
        int digit_j = num % POW10[j + 1] / POW10[j];
        return num - digit_i * POW10[i] - digit_j * POW10[j] + digit_i * POW10[j] + digit_j * POW10[i];
    }

    private int getPlace() {
        int tmp = num;
        int place = 0;
        while (tmp > 0) {
            tmp /= 10;
            place++;
        }
        return place;
    }
}
```

# 两次遍历的贪心算法

## 思路

这个题贪心算法的思路是进行两次扫描。首先进行一次从高位至低位的遍历，记录 0 至 9 每个数码最后出现的索引。然后进行第二次扫描，如果存在一个比当前扫描的数码更大的数码且该数码最后一次出现于正被扫描的数码的右侧，那么就交换两个数码，并且返回。

# 一次遍历的贪心算法

## 思路

[灵茶山艾府](https://leetcode.cn/u/endlesscheng/) 给出的实现：[一次遍历，简洁写法（Python/Java/C++/Go/JS/Rust）](https://leetcode.cn/problems/maximum-swap/solutions/2614470/yi-ci-bian-li-jian-ji-xie-fa-pythonjavac-c9b1/)