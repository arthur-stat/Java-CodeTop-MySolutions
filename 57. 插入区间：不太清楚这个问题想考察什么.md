题目简述：

> 给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表 `intervals`，其中 `intervals[i] = [start_i, end_i]` 表示第 `i` 个区间的开始和结束，并且 `intervals` 按照 `start_i` 升序排列。同样给定一个区间 `newInterval = [start, end]` 表示另一个区间的开始和结束。
>
> 在 `intervals` 中插入区间 `newInterval`，使得 `intervals` 依然按照 `start_i` 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。
>
> 返回插入之后的 `intervals`。
>
> **注意** 你不需要原地修改 `intervals`。你可以创建一个新数组然后返回它。

题目链接：[57. 插入区间](https://leetcode.cn/problems/insert-interval/)

# 思路

不太清楚这个问题想考察什么，很简单而直白的问题。说是贪心算法的话，又有点太看不起贪心算法了。

记待插入区间的左端点为 `a`、右端点为 `b`，

1. 如果 `intervals[i]` 的右端点小于 `a`，则 `intervals[i]` 必然位于待插入区间的左侧，可以安全地放到结果集中；

2. 如果 `intervals[i]` 的左端点大于 `b`，则 `intervals[i]` 必然位于待插入区间的右侧，可以安全地放到结果集中；

3. 否则意味着 `intervals[i]` 与待插入区间相交、需要被合并，记合并后的的区间左端点为 `c`、右端点为 `d`，初始化 `c = min(c, a)`、`d = max(d, b)`，最后当首次出现第二种情况时就可以安全地把合并后区间放置在此时的 `intervals[i]` 左侧。

   注意合并后区间可能就是结果集中的最后一个区间，这时循环中不存在第二种情况，此时不要忘了把合并后区间手动插入到结果集的尾部哦！在下面的代码实现中，我们是通过布尔变量 `added` 控制这一点的。

# 代码

算法的时间复杂度为 $O(n)$。不考虑输出数组的空间开销时，算法的空间复杂度为 $O(1)$。

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> res = new ArrayList<>();
        int n = intervals.length;

        int start = newInterval[0];
        int end = newInterval[1];
        boolean added = false;
        for (int i = 0; i < n; i++) {
            if (intervals[i][1] < newInterval[0]) {
                res.add(intervals[i]);
            } else if (intervals[i][0] > newInterval[1]) {
                if (!added) {
                    res.add(new int[]{start, end});
                    added = true;
                }
                res.add(intervals[i]);
            } else {
                start = Math.min(start, intervals[i][0]);
                end = Math.max(end, intervals[i][1]);
            }
        }

        if (!added) res.add(new int[]{start, end});

        return res.toArray(new int[0][]);
    }
}
```

