题目简述：

> 给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。
>
> 以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
> 你所设计的解决方案必须只使用常量级的额外空间。

题目链接：[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

# 思路

如果允许使用 $O(n)$ 的空间开销，那么即使数组是无序的，利用哈希表缓存的经典做法能在 $O(n)$ 的时间复杂度解决两数之和的问题。

本问题虽然只允许使用常量级额外空间，但数组本身是有序的，因此可以考虑双指针。

初始化 `left` 与 `right` 分别为 `0` 及 `n-1`，计算 `nums[left] + nums[right]`，记和为 `sum`：

- 若 `sum = target`，返回 `left` 与 `right` 即可；
- 若 `sum < target`，意味着 `sum` 小了，应使其变大，所以令 `left++`；
- 若 `sum > target`，意味着 `sum` 大了，应使其变小，所以令 `right--`；
- 如果 `left = right` 但仍不能返回结果，意味着不存在有效答案。不过问题描述保证了一定会存在且只存在唯一的答案，所以可以不考虑这一情况。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

如果数组是无序的，这样做就要付出 $O(n\log n)$ 的排序时间复杂度代价了。

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return new int[]{left + 1, right + 1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }

        throw new RuntimeException("不存在有效答案");
    }
}
```