题目简述：

> 设计一个支持push，pop，top，peekMax和popMax操作的最大栈。
>
> 1. push(x) -- 将元素x添加到栈中。
> 2. pop() -- 删除栈中最顶端的元素并将其返回。
> 3. top() -- 返回栈中最顶端的元素。
> 4. peekMax() -- 返回栈中最大的元素。
> 5. popMax() -- 返回栈中最大的元素，并将其删除。如果有多于一个最大的元素，只删除最靠近顶端的一个元素。

题目链接：[859 · 最大栈](https://www.lintcode.com/problem/859/)

# 懒删除：栈 + 优先队列

注：两种方法不能简单讲谁更好，取决于 `popMax` 方法是否被使用得非常频繁。

## 思路

我认为这算一个直观的思路，栈用于实现栈本身的固有 LIFO 逻辑，优先队列用于实现处理最大元素的逻辑。

每 `push` 一个元素，我们都将该元素包装为一个具有三个字段的对象，这三个字段分别为：

1. 值 `val`，被 `push` 的原始输入；
2. 操作数 `count`，用于优先队列实现相同值时优先让离栈顶最近的元素出队；
3. 是否有效 `isValid`，用于支持懒删除的逻辑。

当需要调用栈方法 `pop` 弹出一个有效栈顶时，如果当前栈顶实际上是已失效的元素，即已经在优先队列中被删除的元素，那么我们需要弹出一次栈顶，但我们认为该栈顶是无效的，所以我们还需要继续弹出栈顶——直到弹出一个有效的栈顶，这里就是栈在执行懒删除，然后将该栈顶对应的封装对象的 `isValid` 字段设置为 `false` 表示该对象已被删除，通知稍后优先队列在操作时如果碰到该对象则应触发懒删除。

`top` 是类似的，只不过最后不将有效栈顶封装对象的 `isValid` 字段设置为 `false`，而是直接返回其对应的值。

当需要调用优先队列方法 `popMax` 时，类似地，我们就不断让处于队首的已失效元素出队，直到某个队首是有效的，然后将该队首对应的封装对象的 `isValid` 字段设置为 `false` 表示该对象已被删除，通知稍后栈在操作时如果碰到该对象则应触发懒删除。

`peekMax` 也是类似的。

## 代码

除了 `top` 操作的时间复杂度为摊还 $O(1)$ 外，所有操作的时间复杂度均为 $O(\log n)$ 或摊还 $O(\log n)$。

```java
class MaxStack {

    private class Pair {

        int val;
        long count;
        boolean isValid;

        Pair(int val) {
            this.val = val;
            count = sta++;
            isValid = true;
        }
    }

    private Deque<Pair> stack;
    private PriorityQueue<Pair> pq;
    private long sta;

    public MaxStack() {
        stack = new ArrayDeque<>();
        pq = new PriorityQueue<>((a, b) ->{
            int res = Integer.compare(b.val, a.val);
            if (res != 0) return res;
            return Long.compare(b.count, a.count);
        });
        sta = 0;
    }

    /*
     * @param number: An integer
     * @return: nothing
     */    
    public void push(int x) {
        Pair p = new Pair(x);
        stack.push(p);
        pq.offer(p);
    }

    public int pop() {
        while (!stack.peek().isValid) {
            stack.pop();
        }
        Pair p = stack.pop();
        p.isValid = false;
        return p.val;
    }

    /*
     * @return: An integer
     */    
    public int top() {
        while (!stack.peek().isValid) {
            stack.pop();
        }
        return stack.peek().val;
    }

    /*
     * @return: An integer
     */    
    public int peekMax() {
        while (!pq.peek().isValid) {
            pq.poll();
        }
        return pq.peek().val;
    }

    /*
     * @return: An integer
     */    
    public int popMax() {
        while (!pq.peek().isValid) {
            pq.poll();
        }
        Pair p = pq.poll();
        p.isValid = false;
        return p.val;
    }
}
```

# 双栈

注：两种方法不能简单讲谁更好，取决于 `popMax` 方法是否被使用得非常频繁。

## 思路

这个思路倒也算直观……也不必封装输入元素。

使用两个栈，其中一个栈为主要栈、另一个栈为最大值栈。对于栈的固有 LIFO 操作直接在主要栈中进行即可，最大值栈负责维护当前栈状态的最大值。这个思路是利用了栈状态的 “可回溯” 特点，即如果进行了 `pop`，则栈一定会回到过去的某个状态（`push` 前的状态），这点与队列是不同的，队列一个元素出队后的状态与上一个元素入队前的状态是不一样的。

这样的话，如果需要获取栈的最大值则直接读取最大值栈即可，但需要删除离主要栈栈顶最近的最大值元素时则比较麻烦，这种情况下只能不断弹主要栈并再用第三个辅助栈临时缓存被弹出的元素，直到弹出的元素的值为所期望的最大值，我们将其永久地弹出栈，随后再将辅助栈中的元素 “倾倒” 回主要栈，同时更新最大值栈。

## 代码

除了 `topMax` 操作的时间复杂度为 $O(n)$ 外，所有操作的时间复杂度均为 $O(1)$。

```java
class MaxStack {

    private Deque<Integer> mainStack;
    private Deque<Integer> maxValStack;

    public MaxStack() {
        mainStack = new ArrayDeque<>();
        maxValStack = new ArrayDeque<>();
    }

    /*
     * @param number: An integer
     * @return: nothing
     */    
    public void push(int x) {
        mainStack.push(x);
        if (maxValStack.isEmpty()) {
            maxValStack.push(x);
        } else {
            maxValStack.push(Math.max(maxValStack.peek(), x));
        }
    }

    public int pop() {
        int res = mainStack.pop();
        maxValStack.pop();
        return res;
    }

    /*
     * @return: An integer
     */    
    public int top() {
        return mainStack.peek();
    }

    /*
     * @return: An integer
     */    
    public int peekMax() {
        return maxValStack.peek();
    }

    /*
     * @return: An integer
     */    
    public int popMax() {
        int maxVal = maxValStack.peek();
        Deque<Integer> tmp = new ArrayDeque<>();
        while (mainStack.peek() != maxVal) {
            tmp.push(mainStack.pop());
            maxValStack.pop();
        }
        mainStack.pop();
        maxValStack.pop();
        while (!tmp.isEmpty()) push(tmp.pop());
        return maxVal;
    }
}
```
