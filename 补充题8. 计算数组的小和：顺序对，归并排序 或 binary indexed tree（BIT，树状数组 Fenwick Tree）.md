题目简述：

> 数组小和的定义如下： 
>
> $\sum^{n}_{i=1}f_i$(其中 $f_i$ 的定义是第 $i$ 个数的左侧小于等于 $s_i$ 的个数）
>
> 例如，数组 s = [1, 3, 5, 2, 4, 6] ，在 s[0] 的左边小于或等于 s[0] 的数的和为 0 ； 在 s[1] 的左边小于或等于 s[1] 的数的和为 1 ；在 s[2] 的左边小于或等于 s[2] 的数的和为 1+3=4 ；在 s[3] 的左边小于或等于 s[3] 的数的和为 1 ； 
>
> 在 s[4] 的左边小于或等于 s[4] 的数的和为 1+3+2=6 ；在 s[5] 的左边小于或等于 s[5] 的数的和为 1+3+5+2+4=15 。所以 s 的小和为 0+1+4+1+6+15=27 
>
> 给定一个数组 s ，实现函数返回 s 的小和
>
> 数据范围：$0<n\leqslant10^5$，$|s_i|\leqslant100$

题目链接：[[编程题]计算数组的小和](https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469)

# 整体思路

实际上就是找正序对，考虑 BIT 或归并排序。

思路与此前找逆序对是一样的，例如 [LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 与 [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)。这两个题解中我详细分析了 BIT 与归并排序如何计算逆序对，这里就直接给出实现了。

# Binary Indexed Tree

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {

    public static class BIT {

        private int[] bit;
        private int n;

        public BIT(int len) {
            bit = new int[len + 1];
            n = len;
        }

        // 1-based
        public void update(int i, int delta) {
            while (i <= n) {
                bit[i] += delta;
                i += i & -i;
            }
        }

        // 1-based
        public int query(int i) {
            int res = 0;
            while (i > 0) {
                res += bit[i];
                i -= i & -i;
            }
            return res;
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextLine()) { // 注意 while 处理多个 case
            int len = Integer.parseInt(in.nextLine());
            int[] nums = Arrays.stream(in.nextLine().split(" "))
                               .mapToInt(Integer::parseInt)
                               .toArray();

            // 离散化
            Set<Integer> set = new HashSet<>();
            for (int num : nums) set.add(num);
            int[] y = set.stream().mapToInt(Integer::intValue).toArray();
            Arrays.sort(y);
            Map<Integer, Integer> map = new HashMap<>();
            for (int i = 0; i < y.length; i++) map.put(y[i], i);

            // 值域统计
            BIT bit = new BIT(y.length);

            long res = 0;
            for (int num : nums) {
                int index = map.get(num) + 1;
                res += bit.query(index);
                bit.update(index, num);
            }

            System.out.println(res);
        }
    }
}
```

# 归并排序

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {

    private static long res;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextInt()) { // 注意 while 处理多个 case
            int len = Integer.parseInt(in.nextLine());
            int[] nums = Arrays.stream(in.nextLine().split(" "))
                               .mapToInt(Integer::parseInt)
                               .toArray();
            int[] tmp = nums.clone();
            res = 0;

            for (int size = 1; size < len; size *= 2) {
                for (int left = 0; left < len; left += 2 * size) {
                    int right = Math.min(left + 2 * size - 1, len - 1);
                    int mid   = left + size;
                    if (mid > right) continue;
                    merge(nums, tmp, left, right, mid);
                }
            }

            System.out.println(res);
        }
    }

    private static void merge(int[] nums, int[] tmp, int left, int right, int mid) {
        int i = left;
        int j = mid;
        int k = left;
        int sum = 0;
        System.arraycopy(nums, left, tmp, left, right - left + 1);

        while (i < mid && j <= right) {
            if (tmp[i] <= tmp[j]) {
                res += (long) tmp[i] * (right - j + 1);
                nums[k++] = tmp[i++];
            } else {
                nums[k++] = tmp[j++];
            }
        }

        System.arraycopy(tmp, i, nums, k, mid - i);
    }
}
```

