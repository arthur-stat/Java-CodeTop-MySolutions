题目简述：

> 给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
>
> **进阶：**
>
> - 如果给定的数组已经排好序呢？你将如何优化你的算法？
> - 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
> - 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

题目链接：[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

# 哈希表计数

先分别使用哈希表对 `nums1` 与 `nums2` 的值的频次进行计数，然后遍历其中一个计数哈希表，对比 key 是否也存在于另一个计数哈希表中，如果存在则取两者 value 最小值，value 最小值即为 key 在两个数组交集中的频次。

算法的时间复杂度为 $O(m+n)$，空间复杂度为 $O(m+n)$。

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer, Integer> sta1 = new HashMap<>();
        Map<Integer, Integer> sta2 = new HashMap<>();
        for (int num1 : nums1) sta1.merge(num1, 1, Integer::sum);
        for (int num2 : nums2) sta2.merge(num2, 1, Integer::sum);

        List<Integer> res = new ArrayList<>();
        for (var entry1 : sta1.entrySet()) {
            int key = entry1.getKey();
            Integer freq2 = sta2.get(key);
            if (freq2 != null) {
                res.addAll(Collections.nCopies(Math.min(entry1.getValue(), freq2), key));
            }
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

# 排序 + 双指针

对 `nums1` 与 `nums2` 排序，然后分别置两个指针在 `nums1` 与 `nums2` 的首部。尝试递增指向更小值的指针，当该指针移动后指向的值与另一个指针指向的值相同，我们就找到了一个交集中的元素。

由于要求结果是交集中的所有元素，因此当发现两个指针指向的元素的值相等时，我们需要将两个指针均移动至指向各自数组上的下一个不同值，同时记录两指针中所移动的距离的最小值，该最小距离值即为相等值在两个数组交集中的频次。

算法的时间复杂度为 $O(n\log n+m\log m)$，空间复杂度取决于所使用的排序算法。

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i = 0;
        int j = 0;

        List<Integer> res = new ArrayList<>();
        while (i < m && j < n) {
            if (nums1[i] < nums2[j]) {
                i++;
            } else if (nums1[i] > nums2[j]) {
                j++;
            } else {
                int val = nums1[i];
                int count1 = 1;
                int count2 = 1;
                while (i < m - 1 && nums1[i + 1] == val) {
                    i++;
                    count1++;
                }
                while (j < n - 1 && nums2[j + 1] == val) {
                    j++;
                    count2++;
                }
                res.addAll(Collections.nCopies(Math.min(count1, count2), val));

                i++;
                j++;
            }
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

