题目简述：

> 给定一个非负整数数组 `nums` 和一个整数 `k` ，你需要将这个数组分成 `k` 个非空的连续子数组，使得这 `k` 个子数组各自和的最大值 **最小**。
>
> 返回分割后最小的和的最大值。
>
> **子数组** 是数组中连续的部份。

题目链接：[410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

# 单调决策（值域二分查找 & 贪心策略）

使最小值最大，或使最大值最小，这类问题常见二分搜索解决。

> “**使最小值最大** / **使最大值最小**”这类题，**常能**用二分答案解决——但前提是：把目标值当作一个阈值 $X$，存在一个**关于 $X$ 的可行性判断** $P(X)$ 且它是**单调的**（$X$ 越宽松越容易可行，或反之）。满足这个条件，就可以“**把优化问题降解为单调决策问题**”，对 $X$ 做二分，这就是所谓的**二分答案/参数搜索（parametric search）**。

> 把优化目标写成阈值 $X$ 的**可行性问题**：
>
> - **最小化最大值**（minimize max）：给一个上限 $X$，问“能不能让**每段的最大值 $\leqslant X$**？”
>   若 $X$ 可行，则任何更大的 $X'\geqslant X$ 也一定可行（**可行集关于 $X$ 单调不减**）。
> - **最大化最小值**（maximize min）：给一个下限 $X$，问“能不能让**每段的最小值 $\geqslant X$**？”
>   若 $X$ 可行，则任何更小的 $X'\leqslant X$ 也可行（**可行集关于 $X$ 单调不增**）。
>
> 有了这种单调性，就能用标准二分在区间里找到**最小可行的 $X$**（或**最大可行的 $X$**），即最优解。
>
> > 这就是“把优化问题 → 单调判定问题 → 二分参数”的核心逻辑。

这是本问题的最优解。

## 思路

设答案区间：

- `low = max(nums)`（任何一段至少要容得下最大元素）
- `high = sum(nums)`（不分段时的段和）

二分 `mid`，判定是否存在一个切法，使得 “每段和 ≤ mid”，并且 “段数 ≤ k”。

- 判定函数 `checkValid(mid)`：从左到右贪心累加，**一旦加上当前元素超过 `mid` 就切一刀**，段数 `count++`，新段从当前元素开始。
- 如果最后 `count ≤ k`，说明 `mid` 够大（可行）；否则不够大（不可行）。

可行就收缩右边界，不可行就扩大左边界，直到收敛。

## 代码

算法的时间复杂度为 $O(n\log S)$，空间复杂度为 $O(1)$，其中 $S=\sum\mathrm{num}_i$。

```java
class Solution {

    private int[] nums;
    private int k;

    public int splitArray(int[] nums, int k) {
        this.nums = nums;
        this.k = k;

        int max = nums[0];
        int sum = 0;
        for (int num : nums) {
            max = Math.max(max, num);
            sum += num;
        }

        int low = max;
        int high = sum;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (!checkValid(mid)) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return low;
    }

    private boolean checkValid(int mid) {
        int intervalSum = 0;
        int intervalCount = 1;

        for (int num : nums) {
            if (num > mid) return false;

            if (intervalSum + num <= mid) {
                intervalSum += num;
            } else {
                intervalCount++;
                if (intervalCount > k) return false;
                intervalSum = num;
            }
        }

        return intervalCount <= k;
    }
}
```

# 动态规划

动态规划只是可行，但远非最优解。

而且状态转移方程尚比较好推导，写代码时他的边界条件极其恶心。

可以考虑决策单调与分治算法优化，但性能不会优于单调决策（二分查找）。

## 思路

直觉上，本问题可以动态规划解决。

尝试设 $dp[n][k]$ 为 `nums[0]` 至 `nums[n]` 的子串被分割为 $k$ 个非空的连续子数组各自和中最大值的最小者，那么
$$
dp[n][k]=\min\left\{\max\Big\{dp[j][k-1],\sum^n_{i=j+1}nums[i]\Big\}:k-1\leqslant j<n\right\} 
$$

## 代码

时间复杂度为 $O(kn^2)$。

```java
class Solution {
    public int splitArray(int[] nums, int k) {
        int n = nums.length;
        int[][] dp = new int[n + 1][k + 1];
        int[] prefixSum = new int[n + 1];
        
        for (int i = 1; i <= n; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }
        
        for (int i = 1; i <= n; i++) {
            dp[i][1] = prefixSum[i];
        }
        
        for (int m = 2; m <= k; m++) {
            for (int i = m; i <= n; i++) {
                dp[i][m] = Integer.MAX_VALUE;
                for (int j = m - 1; j < i; j++) {
                    int currentMax = Math.max(dp[j][m - 1], prefixSum[i] - prefixSum[j]);
                    dp[i][m] = Math.min(dp[i][m], currentMax);
                }
            }
        }
        
        return dp[n][k];
    }
}
```
