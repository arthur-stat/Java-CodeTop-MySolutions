题目简述：

> Trie（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。
>
> 请你实现 Trie 类：
>
> - `Trie()` 初始化前缀树对象。
> - `void insert(String word)` 向前缀树中插入字符串 `word` 。
> - `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
> - `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

题目连接：[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

# 前言

算是比较有意思的模拟吧，相比字符串的那些恶心人的模拟。

唯一一个比较关键的点是为了实现 `search` 的功能，`Node` 需要一个布尔变量 `end` 表示单词到此是否结束，否则只能实现 `startsWith`。方法 `search` 与 `startsWith` 的唯一差别正是一个在前面的字符匹配成功时返回 `node.end == true ? true : false` （多一步 `end` 检查）而另一个此时直接返回 `true` 表示匹配成功。

# 代码

可以把 `HashMap<Character, Node>` 改为数组，这样在时间开销上性能会更高一些，毕竟字母表里字母的顺序本身就构成可作为 key 直接使用的不重复索引。

```java
class Trie {

    private Node head;

    private class Node {

        boolean end = false;
        private HashMap<Character, Node> map = new HashMap<>();

        public boolean containsKey(char c) {
            return map.containsKey(c);
        }

        public void put(char c, Node n) {
            map.put(c, n);
        }

        public Node get(char c) {
            return map.get(c);
        }
    }

    public Trie() {
        head = new Node();
    }
    
    public void insert(String word) {

        int len = word.length();
        Node node = head;

        for (int i = 0; i < len - 1; i++) {
            char c = word.charAt(i);
            if (!node.containsKey(c)) node.put(c, new Node());
            node = node.get(c);
        }

        char lastChar = word.charAt(len - 1);
        if (!node.containsKey(lastChar)) node.put(lastChar, new Node());
        node.get(lastChar).end = true;
    }
    
    public boolean search(String word) {

        int len = word.length();
        Node node = head;

        for (int i = 0; i < len; i++) {
            char c = word.charAt(i);
            if (!node.containsKey(word.charAt(i))) return false;
            node = node.get(c);
        }

        return node.end == true ? true : false;
    }
    
    public boolean startsWith(String prefix) {
        
        int len = prefix.length();
        Node node = head;

        for (int i = 0; i < len; i++) {
            char c = prefix.charAt(i);
            if (!node.containsKey(prefix.charAt(i))) return false;
            node = node.get(c);
        }

        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

