题目简述：

> 给定一个单词列表 `words` 和一个整数 `k` ，返回前 `k` 个出现次数最多的单词。
>
> 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， **按字典顺序** 排序。
>
> **进阶：**尝试以 `O(n log k)` 时间复杂度和 `O(n)` 空间复杂度解决。

题目链接：[692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/)

本问题的主要逻辑与 [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) 基本上相同，不同的是要求在频率相同时按字典序排序。在 [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) 问题的题解中我给出了基于大顶堆（数组、优先队列）、快速选择、桶排序的不同实现方案。这里我就只给出优先队列的实现了，其他实现是类似的。

# 思路

大小顶堆（优先队列）与快速选择算法能够用来解决 Top-K 问题。

这里我们进行词频统计后可以将问题转为 Top-K。

# 代码

算法的近似时间复杂度为 $O\big((m+k)\log m\big)$，空间复杂度为 $O(m)$，其中 $m$ 是不重复字符串的个数。

```java
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> stat = new HashMap<>();
        for (String word : words) {
            stat.merge(word, 1, Integer::sum);
        }

        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(
            new Comparator<Map.Entry<String, Integer>>() {
                @Override
                public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                    int v1 = o1.getValue();
                    int v2 = o2.getValue();
                    if (v1 != v2) return v2 - v1;

                    return o1.getKey().compareTo(o2.getKey());
                }
            }
        );

        for (Map.Entry<String, Integer> entry : stat.entrySet()) {
            pq.offer(entry);
        }

        List<String> res = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            res.add(pq.poll().getKey());
        }
        return res;
    }
}
```

