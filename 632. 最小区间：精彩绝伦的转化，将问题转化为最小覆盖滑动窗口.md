题目简述：

> 你有 `k` 个 **非递减排列** 的整数列表。找到一个 **最小** 区间，使得 `k` 个列表中的每个列表至少有一个数包含在其中。
>
> 我们定义如果 `b-a < d-c` 或者在 `b-a == d-c` 时 `a < c`，则区间 `[a,b]` 比 `[c,d]` 小。
>
> **提示：**
>
> - `nums.length == k`
> - `1 <= k <= 3500`
> - `1 <= nums[i].length <= 50`
> - `-10^5 <= nums[i][j] <= 10^5`
> - `nums[i]` 按非递减顺序排列

题目链接：[632. 最小区间](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/)

# 基本方案（超时）

## 滑动窗口 + 多路归并

> 这个算法能够计算出正确的结果，但是在测试平台上会超时！

首先要明确以下几个容易观察出来的事实：

1. 符合题干描述的最小区间，其左端点与右端点的值必然都各自存在于某个数组中，只有这样才能保证最小区间的宽度必然是最小的（但仅仅是该条件尚不能保证在所有宽度最小的区间中一个区间的左端点是最小的）；
2. 左端点至少要大于等于所有数组的最小值；
3. 右端点必须小于等于所有数组的最大值。

进一步地，这里存在单调性：

1. 如果右端点是确定的，假设合法的左端点存在，那么在题干描述的比较规则下左端点必然是唯一的；
2. 右端点如果递增，则合法的左端点单调不减。假设右端点增大了，意味着区间内更够容纳更多的数值，新区间是完全包含旧区间的，此时左端点绝不可能再减小，因为旧区间已经能保证每个数组至少包含一个数，那么新区间在左端点不移动时便已经能保证每个数组至少包含一个数，此时再减小左端点就违背了让区间长度最小化的原则。

利用这一单调性，显然地，我们应考虑滑动窗口方法：固定右端点，右端点递增至所有数组中的下一个值（注意不是步长 1，因为合法的区间的右端点必然是数组中的某个值），左端点尽可能地在确保区间至少包含每个数组一个数的前提下向右端点靠拢。于是，当我们遍历完所有可能的右端点后，取其中宽度最小的区间（多个宽度最小的区间则取左端点最小的区间），该区间就是问题的解了。

在滑动窗口扩张与收缩的过程中，我们可以避开不满足条件的非法解，因此滑动窗口具体的维护策略是：

- 增大右端点，当某个右端点恰使得区间至少包含每个数组一个数时，停止右端点的扩张；
- 然后，在使区间至少包含每个数组一个数的前提下，尽可能增大左端点，当左端点恰增大至区间不再能确保至少包含每个数组一个数时，结算合法区间，再回到第一步继续增大右端点。

这样能够确保滑动窗口每次扩张与收缩前的状态是一致的。

要实现「递增至所有数组中的下一个值」的逻辑，可以考虑小顶堆多路归并。

这个代码有点不好写，这版代码我是面向测试用例编程才解决了所有 bug。

该算法的时间复杂度为 $O(k^2L^2)$，其中 $k$ 为数组的数量，$L$ 为各数组的平均长度。

```java
record Pair(int val, int kthNums, int idx) implements Comparable<Pair> {
    @Override
    public int compareTo(Pair o) {
        return Integer.compare(this.val(), o.val());
    }
}

class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int[] res = new int[]{0, Integer.MAX_VALUE};
        PriorityQueue<Pair> rPq = new PriorityQueue<>(nums.size());
        for (int k = 0; k < nums.size(); k++) rPq.offer(new Pair(nums.get(k).get(0), k, 0));
        PriorityQueue<Pair> lPq = new PriorityQueue<>(rPq);
        int l = lPq.peek().val();
        int r = lPq.peek().val();
        if (isValid(nums, l, r)) return new int[]{l, l};

        while (!rPq.isEmpty()) {
            while (!rPq.isEmpty() && !isValid(nums, l, r)) {
                int prev_r = r;

                /* 因为 isValid 开销比较大，我们尽量减少 isValid 的调用 */
                while (prev_r == r && !rPq.isEmpty()) {
                    Pair p = rPq.poll();
                    r = p.val();
                    List<Integer> arr = nums.get(p.kthNums());
                    int i = p.idx();
                    if (i < arr.size() - 1) rPq.offer(new Pair(arr.get(i + 1), p.kthNums(), i + 1));
                }
            }

            int prev_l = l;
            while (l < r && isValid(nums, l, r)) {
                prev_l = l;

                /* 因为 isValid 开销比较大，我们尽量减少 isValid 的调用 */
                while (prev_l == l && !lPq.isEmpty()) {
                    Pair p = lPq.poll();
                    l = p.val();
                    List<Integer> arr = nums.get(p.kthNums());
                    int i = p.idx();
                    if (i < arr.size() - 1) lPq.offer(new Pair(arr.get(i + 1), p.kthNums(), i + 1));
                }
            }

            if (l == r && isValid(nums, l, r)) {
                return new int[]{l, l};
            } else if (l != prev_l && r - prev_l < res[1] - res[0]) {
                res[0] = prev_l;
                res[1] = r;
            }
        }

        return res;
    }

    private boolean isValid(List<List<Integer>> nums, int l, int r) {
        outer_loop:
        for (List<Integer> arr : nums) {
            for (int num : arr) {
                if (num >= l && num <= r) continue outer_loop;
            }
            return false;
        }
        return true;
    }
}
```

## 滑动窗口 + 多路归并 + 二分查找

> 这个算法能够计算出正确的结果，但是在测试平台上会超时！

上述算法的时间复杂度 $O(k^2L^2)$ 在题目给定的数据范围下数量级约为 $10^{10}$，这肯定是无法通过测试的，尽管算法能够算出正确结果，但当数组数量足够多、每个数组足够长时，算法将超时。

简单的改进方案是计算 `isValid` 时不要暴力遍历，而是考虑二分搜索确定存在性。首先二分搜索找出各数组内首个大于等于 `l` 的元素，我们知道如果区间 $[l,r]$ 至少包含数组中的一个元素，那么区间就一定包含数组内首个大于等于 `l` 的元素，因此只需要判断数组内首个大于等于 `l` 的元素是否也小于等于 `r`。

这样能将单次 `isValid` 操作的时间复杂度从 $O(kL)$ 降至 $O(k\log L)$，于是总的时间复杂度降至 $O(k^2L\log L)$。

```java
record Pair(int val, int kthNums, int idx) implements Comparable<Pair> {
    @Override
    public int compareTo(Pair o) {
        return Integer.compare(this.val(), o.val());
    }
}

class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int[] res = new int[]{0, Integer.MAX_VALUE};
        PriorityQueue<Pair> rPq = new PriorityQueue<>(nums.size());
        for (int k = 0; k < nums.size(); k++) rPq.offer(new Pair(nums.get(k).get(0), k, 0));
        PriorityQueue<Pair> lPq = new PriorityQueue<>(rPq);
        int l = lPq.peek().val();
        int r = lPq.peek().val();
        if (isValid(nums, l, r)) return new int[]{l, l};

        while (!rPq.isEmpty()) {
            while (!rPq.isEmpty() && !isValid(nums, l, r)) {
                int prev_r = r;

                /* 因为 isValid 开销比较大，我们尽量减少 isValid 的调用 */
                while (prev_r == r && !rPq.isEmpty()) {
                    Pair p = rPq.poll();
                    r = p.val();
                    List<Integer> arr = nums.get(p.kthNums());
                    int i = p.idx();
                    if (i < arr.size() - 1) rPq.offer(new Pair(arr.get(i + 1), p.kthNums(), i + 1));
                }
            }

            int prev_l = l;
            while (l < r && isValid(nums, l, r)) {
                prev_l = l;

                /* 因为 isValid 开销比较大，我们尽量减少 isValid 的调用 */
                while (prev_l == l && !lPq.isEmpty()) {
                    Pair p = lPq.poll();
                    l = p.val();
                    List<Integer> arr = nums.get(p.kthNums());
                    int i = p.idx();
                    if (i < arr.size() - 1) lPq.offer(new Pair(arr.get(i + 1), p.kthNums(), i + 1));
                }
            }

            if (l == r && isValid(nums, l, r)) {
                return new int[]{l, l};
            } else if (l != prev_l && r - prev_l < res[1] - res[0]) {
                res[0] = prev_l;
                res[1] = r;
            }
        }

        return res;
    }

    private boolean isValid(List<List<Integer>> nums, int l, int r) {
        outer_loop:
        for (List<Integer> arr : nums) {
            if (l <= arr.get(0) && r >= arr.getLast()) continue outer_loop;

            // 先得到首个大于等于 l 的元素
            int lo = 0;
            int hi = arr.size() - 1;
            while (lo <= hi) {
                int mid = lo + (hi - lo) / 2;
                if (arr.get(mid) < l) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }

            // 判断首个大于等于 l 的元素是否小于等于 r
            if (lo == arr.size() || arr.get(lo) > r) return false;
        }
        return true;
    }
}
```

## 滑动窗口 + 多指针

> 这个算法能够计算出正确的结果，但是在测试平台上会超时！

要进一步降低时间复杂度，就不能再逐元素地维护滑动窗口了，因为这样做会导致滑动窗口每次发生变化都需要调用一次 `isValid`，而基于比较的 `isValid` 方法理论时间复杂度最低的算法之一就是二分查找，不可能再低了。

其中一个替代方案是考虑多指针，利用上各数组都是单调递增的这一重要信息。在二分查找的方案中有提到，区间是否合法，取决于各数组内首个大于等于 `l` 的元素是否也小于等于 `r`。在先前的所有方案中都是一步步调整滑动窗口，每调整一次就调用一次 `isValid`，如果我们考虑多指针，就可以一次性地将滑动窗口调整至下一个合法的状态，不需要多次调用 `isValid`。

具体的方案是初始化 `l` 与 `r`，同时初始化 `k` 个指针，每个指针都位于唯一对应的一个数组上，我们要求指针指向各数组上的首个大于等于 `l` 的元素，然后：

1. 判断滑动窗口是否合法，判断方式是遍历指针数组，观察指针们所指向的元素是否都小于等于 `r`，这一步的时间复杂度为 $O(k)$，如果是则转到第 3 步，否则转到第 2 步；
2. 如果当前滑动窗口不合法，考虑扩大滑动窗口的右端点——易见此时右端点的最小合法值就是所有指针所指向元素的最大值。如果我们在第 1 步的遍历中就顺便记录了最大值，那么这一步是没有时间开销的。更新右端点后滑动窗口内至少包含每个数组的一个元素，转到第 3 步；
3. 进行到这一步时，滑动窗口内已经能够确定至少包含每个数组的一个元素，于是考虑增大左端点以收缩窗口——易见此时左端点的最大合法值就是所有指针所指向元素的最小值。如果我们在第 1 步的遍历中就顺便记录了最小值，那么这一步是没有时间开销的。现在滑动窗口不仅至少包含了每个数组的一个元素，而且对于目前这一确定的右端点，左端点已经不可能更大了，于是尝试更新结果，并转到第 4 步；
4. 现在我们需要探索其他解并确保不会漏解。我们让指针集合中所有指向最小元素的那些指针右移，并且跳过所有重复值，这样就回到了第 1 步的状态——滑动窗口恰不再合法，这不会造成漏解。我们可以在第 1 步的遍历中动态维护所有指向最小元素的指针，然后在这一步移动他们，这样这一步的摊还总时间复杂度就是 $O(kL)$。

这样我们就可以实现 $O(k^2L)$ 时间复杂度的算法。

```java
class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int[] ptr = new int[nums.size()];
        int[] res = new int[]{0, Integer.MAX_VALUE};

        while (true) {
            List<Integer> minPtr = new ArrayList<>(1000);
            int minVal = Integer.MAX_VALUE;
            int maxVal = Integer.MIN_VALUE;

            for (int i = 0; i < nums.size(); i++) {
                List<Integer> arr = nums.get(i);
                int val = arr.get(ptr[i]);

                if (val < minVal) {
                    minVal = val;
                    minPtr.clear();
                    minPtr.add(i);
                } else if (val == minVal) {
                    minPtr.add(i);
                }

                maxVal = Math.max(maxVal, val);
            }

            if (maxVal - minVal < res[1] - res[0]) {
                res[0] = minVal;
                res[1] = maxVal;
            }

            for (int j : minPtr) {
                List<Integer> arr = nums.get(j);
                while (ptr[j] < arr.size() - 1 && arr.get(ptr[j] + 1) == arr.get(ptr[j])) {
                    ptr[j]++;
                }
                ptr[j]++;
                if (ptr[j] == arr.size()) return res;
            }
        }
    }
}
```

## 小结

我们一步步将算法的时间复杂度从 $O(k^2L^2)$ 降低至 $O(k^2L\log L)$ 再降低至 $O(k^2L)$，但算法始终会超时。

我们必须找到性能更优的算法。

# 最终方案

## 排序 + 最小覆盖滑动窗口

上面的方案都是我早期的思路，实现后无一例外地都超时了，原因在于滑动窗口边界每次更新的「步子」迈得太小。

查看了他人的题解后，发现该问题有一种 $O(kL)$ 时间复杂度的滑动窗口方案，该方案巧妙地将本问题转换为了另一个容易解决的滑动窗口问题，但这要求我们必须彻底转变思路：这一方案就是将所有数组中的所有数字合并在一个集合中，每个元素都应该记忆他所属的数组，然后为他们按值排序，那么包含每个数组至少一个元素的区间就等价于排序后集合上包含 $k$ 个数组的数字的滑动窗口。如果不足 $k$ 个则右移右边界，如果达到 $k$ 个则右移左边界，并且右移左边界后尝试更新结果。

一言以蔽之：通过将数字合并但保留其所属数组的信息，将问题等价地转变为了一个更简单的问题（[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)）。

这样左右边界指针均至多移动 $kL$ 次，对合并后的数组排序的时间复杂度为 $O\big(kL\log(kL)\big)$，于是总的时间复杂度为 $O\big(kL\log(kL)\big)$。

由于各数组原本是有序的，所以可考虑多路归并排序，那么算法的时间复杂度可降至 $O(kL\log k)$。

```java
record Pair(int val, int kth) implements Comparable<Pair> {
    @Override
    public int compareTo(Pair o) {
        return Integer.compare(this.val(), o.val());
    }
}

class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        Pair[] sorted = mergeAndSort(nums);
        int[] res = new int[]{0, Integer.MAX_VALUE};
        int l = 0;
        int[] count = new int[nums.size()];
        int diff = 0;

        for (int r = 0; r < sorted.length; r++) {
            Pair p = sorted[r];
            if (++count[p.kth()] == 1) diff++;
            if (diff == nums.size()) {
                while (diff == nums.size()) {
                    Pair pp = sorted[l++];
                    if (--count[pp.kth()] == 0) diff--;
                }
                if (p.val() - sorted[l - 1].val() < res[1] - res[0]) {
                    res[0] = sorted[l - 1].val();
                    res[1] = p.val();
                }
            }
        }

        return res;
    }

    private Pair[] mergeAndSort(List<List<Integer>> nums) {
        List<Pair> res = new ArrayList<>();
        int[] ptr = new int[nums.size()];
        PriorityQueue<Pair> pq = new PriorityQueue<>(nums.size());
        for (int k = 0; k < nums.size(); k++) pq.offer(new Pair(nums.get(k).get(0), k));

        while (!pq.isEmpty()) {
            Pair p = pq.poll();
            res.add(p);
            int k = p.kth();
            List<Integer> arr = nums.get(k);
            if (ptr[k] < arr.size() - 1) pq.offer(new Pair(arr.get(++ptr[k]), k));
        }

        return res.toArray(new Pair[0]);
    }
}
```

