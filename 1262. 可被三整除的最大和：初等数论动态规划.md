题目简述：

> 给你一个整数数组 `nums`，请你找出并返回能被三整除的元素 **最大和**。
>
> **提示：**
>
> - `1 <= nums.length <= 4 * 10^4`
> - `1 <= nums[i] <= 10^4`

题目链接：[1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/)

# 逐个分析状态

## 思路

一个整数模 3 只有三个可能的值：0、1 与 2，即一个整数在一个模 3 剩余类中与另一个整数做加法的状态转移是完全可枚举的，天然构成状态转移方程。

因此可以考虑动态规划，我们维护三个状态：$dp_0[i]$、$dp_1[i]$ 以及 $dp_2[i]$，含义分别为自 `nums[0]` 起至 `nums[i]` 的子数组中模 3 后分别为 0、1 以及 2 的元素最大和。

那么，注意到 `nums` 内的元素均非负，初始化 $dp_0[-1]=0$、$dp_1[-1]=-1$ 与 $dp_2[-1]=-1$，其中值 $-1$ 被视为无效值，

- 若 `nums[i]` 模 3 余 0，则
  - $dp_0[i]:=dp_0[i-1]+\mathrm{nums}[i]$
  - $dp_1[i]:=dp_1[i-1]+\mathrm{nums}[i]$，前提是 $dp_1[i-1]$ 有效
  - $dp_2[i]:=dp_2[i-1]+\mathrm{nums}[i]$，前提是 $dp_2[i-1]$ 有效
- 若 `nums[i]` 模 3 余 1，则
  - $dp_0[i]:=\max\big\{dp_2[i-1]+\mathrm{nums}[i],\,dp_0[i-1]\big\}$，前提是 $dp_2[i-1]$ 有效
  - $dp_1[i]:=\max\big\{dp_0[i-1]+\mathrm{nums}[i],\,dp_1[i-1]\big\}$，前提是 $dp_1[i-1]$ 有效
  - $dp_2[i]:=\max\big\{dp_1[i-1]+\mathrm{nums}[i],\,dp_2[i-1]\big\}$，前提是 $dp_1[i-1],dp_2[i-1]$ 有效
- 若 `nums[i]` 模 3 余 2，则
  - $dp_0[i]:=\max\big\{dp_1[i-1]+\mathrm{nums}[i],\,dp_0[i-1]\big\}$，前提是 $dp_1[i-1]$ 有效
  - $dp_1[i]:=\max\big\{dp_2[i-1]+\mathrm{nums}[i],\,dp_1[i-1]\big\}$，前提是 $dp_1[i-1],dp_2[i-1]$ 有效
  - $dp_2[i]:=\max\big\{dp_0[i-1]+\mathrm{nums}[i],\,dp_2[i-1]\big\}$，前提是 $dp_2[i-1]$ 有效

最终 $dp_0$ 的最后一个数字即为全局能被三整除的元素最大和。

题目的数据范围 `1 <= nums.length <= 4 * 10^4` 也提示了，复杂度至多为 $O(n^2)$，很可能为 $O(n)$，回溯算法一定会超时，这也提示了我们考虑其他方法。

## 代码

考虑滚动数组，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

这样实现的代码一定是正确的，但可读性比较差。

```java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int[] mod = {0, -1, -1};
        int[] modd = new int[3];  // 滚动数组

        for (int num : nums) {
            int m = num % 3;

            if (m == 0) {

                modd[0] = mod[0] + num;

                modd[1] = mod[1] != -1 ? mod[1] + num : -1;

                modd[2] = mod[2] != -1 ? mod[2] + num : -1;

            } else if (m == 1) {

                if (mod[2] != -1) {
                    modd[0] = Math.max(mod[2] + num, mod[0]);
                } else {
                    modd[0] = mod[0];
                }

                if (mod[1] != -1) {
                    modd[1] = Math.max(mod[0] + num, mod[1]);
                } else {
                    modd[1] = mod[0] + num;
                }

                if (mod[1] != -1 && mod[2] != -1) {
                    modd[2] = Math.max(mod[1] + num, mod[2]);
                } else if (mod[2] != -1) {
                    modd[2] = mod[2];
                } else if (mod[1] != -1) {
                    modd[2] = mod[1] + num;
                } else {
                    modd[2] = -1;
                }

            } else {

                if (mod[1] != -1) {
                    modd[0] = Math.max(mod[1] + num, mod[0]);
                } else {
                    modd[0] = mod[0];
                }

                if (mod[1] != -1 && mod[2] != -1) {
                    modd[1] = Math.max(mod[2] + num, mod[1]);
                } else if (mod[1] != -1) {
                    modd[1] = mod[1];
                } else if (mod[2] != -1) {
                    modd[1] = mod[2] + num;
                } else {
                    modd[1] = -1;
                }

                if (mod[2] != -1) {
                    modd[2] = Math.max(mod[0] + num, mod[2]);
                } else {
                    modd[2] = mod[0] + num;
                }
            }

            int[] tmp = mod;
            mod = modd;
            modd = tmp;
        }

        return mod[0];
    }
}
```

# 合并状态转移

## 思路

上文的思路和代码都是完全正确的，但是事先按照模 3 剩余类进行分组，进行了大量分支讨论。

实际上我们可以合并状态转移方程，使状态转移方程以及代码能够简洁地书写：
$$
\text{next}\big[(\text{mod}+\text{num})\%3\big]=\max\big\{\text{next}\big[(\text{mod}+\text{num})\%3\big],\,\text{dp}[\text{mod}]+\text{num}\big\}
$$

简洁性一方面来自于惰性更新——如果相较于旧值没有改动则不新赋值，另一方面合并了分支。惰性更新本身也可以被认为是合并分支的其中一个策略。

## 代码

```java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int[] dp = {0, -1, -1};

        for (int num : nums) {
            int[] next = dp.clone();

            for (int mod = 0; mod < 3; mod++) {
                if (dp[mod] == -1) continue;

                int newMod = (mod + num) % 3;
                next[newMod] = Math.max(next[newMod], dp[mod] + num);
            }

            dp = next;
        }

        return dp[0];
    }
}
```

