题目简述：

> 给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。
>
> 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
>
> - 例如，`121` 是回文，而 `123` 不是。
>
> **进阶：**你能不将整数转为字符串来解决这个问题吗？

题目连接：[9. 回文数](https://leetcode.cn/problems/palindrome-number/)

# 模拟字符串回文比较

## 思路

不将整数转为字符串也很简单。对于一个数，首先要知道他的位数是什么，然后利用位数进行整除得到高位数码，再利用取模得到低位数码，比较两个数码是否相同，然后减去高位数码乘 10 的数位次方，再整除 10，就得到了去掉高位数码与低位数码的数字，然后继续重复该逻辑即可。

但是这里有一个关键点是必须注意到***次高位可能为零***，所以需要提前检验次高位是为零，如果为零我们检验次高位与次低位是否相等，如果相等则用四则运算将其变为相同的一个不为零的数字，再减去高位数码乘 10 的数位次方，否则减掉高位数码乘 10 的数位次方后次高位零将被清除（int 不能有前导零）！

## 代码

```java
class Solution {
    
    private static final int[] exp10 = {
        1, 10, 100, 1000, 10000,
        100000, 1000000, 10000000, 100000000, 1000000000
    };

    public boolean isPalindrome(int x) {
        if (x < 0) return false;

        int len = 0;
        int tmp = x;
        while (tmp != 0) {
            tmp /= 10;
            len++;
        }

        while (x > 9) {
            int high = x / pow10(len - 1);
            int low = x % 10;
            if (high != low) return false;

            // 考虑次高位可能为 0！
            tmp = x - high * pow10(len - 1);
            if (tmp / pow10(len - 2) == 0) {
                if (((x - low) / 10) % 10 == 0) {
                    x += pow10(len - 2) + 10;
                } else {
                    return false;
                }
            }

            x = (x - high * pow10(len - 1)) / 10;
            len -= 2;
        }

        return true;
    }

    // private int pow10(int exp) {
    //     if (exp == 0) return 1;
    //     return 10 * pow10(exp - 1);
    // }

    private int pow10(int exp) {
        return exp10[exp];
    }
}
```

# 翻转一半数字再判别

## 思路

这一方案不像上一种方案直接模拟字符串回文判别的流程，<u>不需要额外处理次高位为零的情况</u>。

该方案的思路源自于回文串的性质：将回文串翻转，翻转前后字面量不变。只不过我们不能直接翻转 int，因为可能会溢出。针对 int，我们的解决措施是只翻转一半。例如，输入数字 1234321，我们将数字的后半部分翻转，即 1234123。

- 对于偶数位数字，反转后的数字应该等于原始数字的前半部分。
- 对于奇数位数字，反转后的数字除以 10 应该等于原始数字的前半部分（因为中间的数字不影响回文性质）。

这里有一个很巧妙的技巧，可以让我们在翻转一半数字时不必事先知道数字位数（上一种方案中我们就事先计算了位数）：

- 每次将原始数字的最后一位取出，加到反转数字的后面。
- 原始数字不断除以 10，反转数字不断乘以 10 加余数。
- 当原始数字小于或等于反转数字时，说明已经处理了一半或过半的数字。

虽然巧妙，但是代码可读性不是很高，只看代码读者可能一时半会无法理解这里的逻辑。
