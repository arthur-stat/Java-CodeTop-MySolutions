题目简述：

> 这里有 `n` 个航班，它们分别从 `1` 到 `n` 进行编号。
>
> 有一份航班预订表 `bookings` ，表中第 `i` 条预订记录 `bookings[i] = [firsti, lasti, seatsi]` 意味着在从 `firsti` 到 `lasti` （**包含** `firsti` 和 `lasti` ）的 **每个航班** 上预订了 `seatsi` 个座位。
>
> 请你返回一个长度为 `n` 的数组 `answer`，里面的元素是每个航班预定的座位总数。

题目链接：[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

# 1. 模拟

最初看题目描述没有看懂一点，看了示例，发现描述有点抽象，实际上是计算一种特殊的区间和：

**示例 1：**

```
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
```

**示例 2：**

```
输入：bookings = [[1,2,10],[2,2,15]], n = 2
输出：[10,25]
解释：
航班编号        1   2
预订记录 1 ：   10  10
预订记录 2 ：       15
总座位数：      10  25
因此，answer = [10,25]
```

那么最简单的方案就是直接遍历 `bookings`，对每个 `bookings` 里的区间，我们都把它上面的元素与对应位置的结果元素相加。

这样算法的时间复杂度为 $O(nL)$，其中 $L$ 为区间的平均长度。虽然能 AC，但看到实际开销 1209ms 我就感觉大事不妙，肯定有更好的方案能做到 $O(n)$ 的时间复杂度，避开 $L$ 的影响。

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] res = new int[n];
        for (int[] book : bookings) {
            for (int i = book[0] - 1; i < book[1]; i++) {
                res[i] += book[2];
            }
        }
        return res;
    }
}
```

起初我还在想，这个问题怎么会这么简单呢？看来事情并非是表面上那样的简单啊。

# 2. 区间排序 + 累积（哈希表）

这个方法是我随后想到的，比模拟好上不少，因为使算法的时间复杂度与 $L$ 无关了，但依然不是极佳的方案，因为还无法做到小常数因子的线性时间复杂度。

这个方法的思路是：首先对所有区间按左端点进行升序排序，定义结果值的累积变量 `accumulator`，然后遍历地填充结果数组 `res`。在填充结果数组时，不妨设当前遍历的索引为 `i`，当我们发现存在过去一些区间右端点到 `i` 为止、需要使累积量 `accumulator` 中属于那些区间的部分过期时，就更新 `accumulator`——减去过期的部分；当我们发现存在新的区间以 `i` 为左端点时，就更新 `accumulator`——加上新的区间所累积的部分。

其中，判断过期的逻辑可以通过哈希表 `endToVal` 将区间右端点映射到将来某一时刻需要使过期的累积量实现。当我们加上了新的区间所累积的部分时，就把该区间的右端点也 “注册” 到哈希表 `endToVal` 中，将右端点与累积过期量做映射，这样当我们遍历到对应该区间右端点的索引时，就能通过 `endToVal` 知道该过期多少累积量。

该算法的时间复杂度为 $O(n\log n)$，时间开销主要来自于排序。算法 AC 时所花费的实际时间为 40ms，相比于大部分方法在 2ms 左右的时间开销，$O(n\log n)$ 的时间复杂度怎样也说不上好——但肯定比暴力模拟的 1209ms 好得多了。

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        Arrays.sort(bookings, (a, b) -> Integer.compare(a[0], b[0]));
        Map<Integer, Integer> endToVal = new HashMap<>();
        int[] res = new int[n];

        int accumulator = 0;
        int nextInterval = 0;
        for (int i = 0; i < n; i++) {
            if (endToVal.containsKey(i)) {
                accumulator -= endToVal.remove(i);
            }

            while (nextInterval < bookings.length && i == bookings[nextInterval][0] - 1) {
                accumulator += bookings[nextInterval][2];
                endToVal.merge(bookings[nextInterval][1], bookings[nextInterval][2], Integer::sum);
                nextInterval++;
            }

            res[i] = accumulator;
        }

        return res;
    }
}
```

# 3. 差分数组

这个问题的正解是考虑差分数组，这样算法能够实现严格的两次扫描线性时间复杂度 $O(n)$。

差分数组与前缀和数组的概念存在一些共性，他们都是原数组的一种描述，而且互相可以视为彼此的 “逆运算”。数列的差分可以视为连续函数微分的离散版本，对应着可以将数列的部分和视为连续函数积分的离散版本。如果读者曾学习过《时间序列分析》或曾或多或少了解过差分方程的话（比如考研数三？），对这个概念就不会陌生吧。

前缀和数组我们大多比较熟悉了，令 $sum[i]=sum[i-1]+nums[i]$，则 $sum[j]-sum[i]=\sum\limits^{j}_{k=i+1}nums[k]$。从数据结构上说，前缀和数组可以帮助我们高效地计算数组指定任意起点与终点的部分和。

那么差分数组呢？令 $diff[i]=nums[i]-nums[i-1]$，于是显然地，差分数组的前缀和数组就是原数组。

接下来我想一切就很自然了：在方法二（区间排序 + 累积）中，我们通过排序使区间们有序，然后一次遍历结果数组的索引计算每个索引位置上的（未过期的）累积量。这个方案的坏处是需要进行一次排序。但其实我们可以直接维护原数组的差分数组，即变化趋势（类比下一阶导数），这样就有

1. 不需要逐个遍历区间内的每个索引，对应方法一，因为没有直接逐区间地维护结果数组；
2. 也不需要保证输入的区间存在有序的性质，对应方法二，使用差分数组避免了结果数组顺序遍历填充时累积变量 `accumulator` 的有序性要求，因为维护差分数组本质上是在维护变化趋势（可以视为数列的导函数）。

然后就可以在严格地一遍扫描、不经过额外排序地得到差分数组了，最后再计算差分数组的部分和数组就得到了结果数组。算法的时间复杂度为 $O(n)$，AC 时的实际时间开销是 3ms，大幅降低。

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
        for (int[] book : bookings) {
            // 上升趋势
            diff[book[0] - 1] += book[2];
            // 下降趋势
            if (book[1] < n) diff[book[1]] -= book[2];
        }
        for (int i = 1; i < n; i++) diff[i] += diff[i - 1];
        return diff;
    }
}
```