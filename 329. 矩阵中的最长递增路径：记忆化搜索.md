题目简述：

> 给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。
>
> 对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

题目链接：[329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

# 思路

这个问题显然直接 DFS 就可以解决，但这存在一个问题：大量的重复子问题求解，时间开销非常大，不可接受。

显然地，应该考虑记忆化搜索的 DFS。毕竟，当我们已经探索过 1 → 2 → 3，对于 0 → 2 当然就没必要再探索 0 → 2 → 3 了，因为 2 → 3 是 1 → 2 → 3 的子路径，实际上在探索 1 → 2 → 3 时便已经探索过，所以直接使用此前缓存的结果即可。

# 代码

记忆化搜索本质上是空间换（大量）时间的策略，算法的时间复杂度为 $O(mn)$，空间复杂度为 $O(mn)$。

```java
class Solution {

    int m;
    int n;
    int res;
    int[][] matrix;
    int[][] searched;

    public int longestIncreasingPath(int[][] matrix) {
        m = matrix.length;
        n = matrix[0].length;
        res = 0;
        this.matrix = matrix;
        this.searched = new int[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dfs(i, j, 1);
            }
        }
        return res;
    }

    private void dfs(int row, int col, int len) {

        if (searched[row][col] > 0) {
            res = Math.max(res, searched[row][col] + len - 1);
            return;
        }

        res = Math.max(res, len);
        int lenStartHere = 1;

        if (valid(row - 1, col) && matrix[row - 1][col] > matrix[row][col]) {
            dfs(row - 1, col, len + 1);
            lenStartHere = Math.max(lenStartHere, searched[row - 1][col] + 1);
            
        }

        if (valid(row, col - 1) && matrix[row][col - 1] > matrix[row][col]) {
            dfs(row, col - 1, len + 1);
            lenStartHere = Math.max(lenStartHere, searched[row][col - 1] + 1);
        }

        if (valid(row + 1, col) && matrix[row + 1][col] > matrix[row][col]) {
            dfs(row + 1, col, len + 1);
            lenStartHere = Math.max(lenStartHere, searched[row + 1][col] + 1);
        }

        if (valid(row, col + 1) && matrix[row][col + 1] > matrix[row][col]) {
            dfs(row, col + 1, len + 1);
            lenStartHere = Math.max(lenStartHere, searched[row][col + 1] + 1);
        }

        searched[row][col] = lenStartHere;
    }

    private boolean valid(int row, int col) {
        return row >= 0 && row < m && col >= 0 && col < n ;
    }
}
```

