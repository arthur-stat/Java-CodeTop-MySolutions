题目简述：

> **描述**
>
> 计算一个浮点数的立方根，不使用库函数。
>
> 保留一位小数。
>
> 数据范围：$|val|\leqslant20$
>
> **输入描述：**
>
> 待求解参数，为double类型（一个实数）
>
> **输出描述：**
>
> 输出参数的立方根。保留一位小数。

题目链接：[求解立方根](https://www.nowcoder.com/practice/caf35ae421194a1090c22fe223357dca)

# 一阶牛顿法（最优化算法）

等价于求 $y=x^3$ 的根。

设 $a=x^3$，我们希望计算出 $f(x)=x^3-a$ 的零点，考虑 $f(x)$ 泰勒公式的一阶近似，有
$$
f(x)\sim f(b)+f'(b)(x-b)
$$
令一阶近似为 $0$，则
$$
f(b)+f'(b)(x-b)=0
$$
代入 $f(x)=x^3-a$，令 $b=x_{n}$、$x=x_{n+1}$，得到迭代公式
$$
x^3_{n}-a+3x^2_{n}(x_{n+1}-x_{n})=0
$$
整理得
$$
x_{n+1}=\frac{2x^3_{n}+a}{3x^2_{n}}
$$
于是可以根据迭代公式编写算法。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextDouble()) { // 注意 while 处理多个 case
            double a = in.nextDouble();
            double x = a;

            while (true) {
                double tmp = (2 * x * x * x + a) / 3 / x / x;
                if (Math.abs(tmp - x) < 1e-2) {
                    System.out.printf("%.1f\n", tmp);
                    break;
                }
                x = tmp;
            }
        }
    }
}
```

# 二分查找（分治算法）

不断地进行二分查找试探即可。

为讨论的简单起见，我们可以避免处理符号，因为立方根的符号在实数域上是由输入所唯一确定的。

这里有一个值得指出的关键点是必须令 `double r = Math.max(1, target);`，而不能令 `double r = target;`，否则当 $0<target < 1$ 时立方根 $\sqrt[3]{target}$ 满足 $0<target<\sqrt[3]{target}<1$，此时由于 $r$ 为二分查找的上确界（被初始化为了 $target$），我们便无论如何也无法找到正确的解 $\sqrt[3]{target}$ 的值。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextDouble()) { // 注意 while 处理多个 case
            double target = in.nextDouble();
            double sign = Math.signum(target);
            target = Math.abs(target);
            double l = 0;
            double r = Math.max(1, target);

            while (true) {
                double mid = l + (r - l) / 2.0;
                if (Math.abs(mid * mid * mid - target) < 1e-2) {
                    System.out.printf("%.1f\n", sign * mid);
                    break;
                }
                
                if (mid * mid * mid < target) {
                    l = mid;
                } else {
                    r = mid;
                }
            }
        }
    }
}
```

