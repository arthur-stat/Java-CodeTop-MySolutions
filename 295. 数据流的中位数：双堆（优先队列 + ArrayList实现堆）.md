题目简述：

> **中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
>
> - 例如 `arr = [2,3,4]` 的中位数是 `3` 。
> - 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。
>
> 实现 MedianFinder 类:
>
> - `MedianFinder() `初始化 `MedianFinder` 对象。
> - `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
> - `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

题目链接：[295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

# 思路

双堆是解决本问题的一个巧妙方案，能保证 `findMedian` 方法 $O(1)$ 的时间复杂度。

让我们思考一下：中位数的特点是什么？那就是计算时只考虑排序后中间的一个或两个元素（以下统称为中间元素），我们不关心其他元素的顺序如何。但是我们不能直接移除其他元素，因为随着数据流的传输，其他元素可能会称为新的中间元素，因此我们的数据结构需要保留他们。

中间元素又有什么特点呢？如果我们可以对已传输的元素进行排序然后在中间位置二分，那么要么中间元素就在中间位置上，要么中间元素分别在左半部分与右半部分，而且在左半部分的是左半部分的最大值，在右半部分的是右半部分的最小值。

答案将要浮出水面了——什么数据结构能够快速帮我们找出数据排序后被二分为左右两部分的数据的最大值或最小值呢？而且我们不关心在一次排序中其他元素究竟在什么位置、是什么分布！答案显然是大小顶堆。

我们维护左右两部分，左部分用大顶堆以快速求得最大值，右部分用小顶堆以快速求得最小值。只要能正确维护左右二分的逻辑，即右半部分的最小值应大于等于左半部分的最大值，而且两部分容纳的元素数量差额不能超过 1（最好同时固定某一部分元素数量不会少于另一部分），那么我们就可以轻松在 $O(1)$ 的时间复杂度里实现中位数的计算！添加元素后维护堆结构则需要 $O(\log n)$ 的时间复杂度。

# 优先队列

AC 时耗时 103 ms，超过 94.52% 的代码。

```java
class MedianFinder {

    private PriorityQueue<Integer> left = new PriorityQueue<>((a, b) -> b - a);  // 大顶堆
    private PriorityQueue<Integer> right = new PriorityQueue<>();                // 小顶堆
    
    public void addNum(int num) {
        if (left.isEmpty() || num <= left.peek()) {
            left.offer(num);
        } else {
            right.offer(num);
        }

        if (left.size() > right.size() + 1) {
            right.offer(left.poll());
        } else if (left.size() < right.size()) {
            left.offer(right.poll());
        }
    }
    
    public double findMedian() {
        return ((left.size() + right.size()) & 1) == 1 ? left.peek() : left.peek() + (right.peek() - left.peek()) / 2.0;
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

# 手动实现堆

AC 时耗时 120 ms，超过 55.21% 的代码。

```java
import java.util.*;

class MedianFinder {

    private MaxHeap left = new MaxHeap();
    private MinHeap right = new MinHeap();
    
    public void addNum(int num) {
        if (left.isEmpty() || num <= left.peek()) {
            left.offer(num);
        } else {
            right.offer(num);
        }

        if (left.size() > right.size() + 1) {
            right.offer(left.poll());
        } else if (left.size() < right.size()) {
            left.offer(right.poll());
        }
    }
    
    public double findMedian() {
        return ((left.size() + right.size()) & 1) == 1 ? left.peek() : left.peek() + (right.peek() - left.peek()) / 2.0;
    }
}


abstract class AbstractHeap {

    protected final ArrayList<Integer> arr;

    public AbstractHeap() {
        arr = new ArrayList<>();
    }

    public AbstractHeap(Collection<Integer> list) {
        arr = new ArrayList<>(list);
        for (int i = arr.size() / 2 - 1; i >= 0; i--) {
            shiftUp(i);
        }
    }

    public void offer(int num) {
        arr.add(num);
        shiftUp(arr.size() - 1);
    }

    public int poll() {
        int res = arr.get(0);
        swap(0, arr.size() - 1);
        arr.remove(arr.size() - 1);
        shiftDown(0);
        return res;
    }

    public boolean isEmpty() {
        return arr.isEmpty();
    }

    public int peek() {
        return arr.get(0);
    }

    public int size() {
        return arr.size();
    }

    protected int parent(int i) {
        return (i - 1) / 2;
    }

    protected int left(int i) {
        return i * 2 + 1;
    }

    protected int right(int i) {
        return i * 2 + 2;
    }

    protected boolean valid(int i) {
        return i >= 0 && i < arr.size();
    }

    protected void swap(int i, int j) {
        int tmp = arr.get(i);
        arr.set(i, arr.get(j));
        arr.set(j, tmp);
    }

    protected abstract void shiftDown(int i);

    protected abstract void shiftUp(int i);
}

class MinHeap extends AbstractHeap {

    public MinHeap() {
        super();
    }

    public MinHeap(Collection<Integer> list) {
        super(list);
    }

    @Override
    protected void shiftDown(int i) {
        int less;

        while (valid(left(i))) {
            int left = left(i);
            less = valid(right(i)) && arr.get(right(i)) < arr.get(left) ? right(i) : left;
            if (arr.get(i) > arr.get(less)) {
                swap(i, less);
                i = less;
            } else {
                break;
            }
        }
    }

    @Override
    protected void shiftUp(int i) {
        while (valid(parent(i))) {
            if (arr.get(i) < arr.get(parent(i))) {
                swap(i, parent(i));
                i = parent(i);
            } else {
                break;
            }
        }
    }
}

class MaxHeap extends AbstractHeap {

    public MaxHeap() {
        super();
    }

    public MaxHeap(Collection<Integer> list) {
        super(list);
    }

    @Override
    protected void shiftDown(int i) {
        int more;

        while (valid(left(i))) {
            int left = left(i);
            more = valid(right(i)) && arr.get(right(i)) > arr.get(left) ? right(i) : left;
            if (arr.get(i) < arr.get(more)) {
                swap(i, more);
                i = more;
            } else {
                break;
            }
        }
    }

    @Override
    protected void shiftUp(int i) {
        while (valid(parent(i))) {
            if (arr.get(i) > arr.get(parent(i))) {
                swap(i, parent(i));
                i = parent(i);
            } else {
                break;
            }
        }
    }
}
```

