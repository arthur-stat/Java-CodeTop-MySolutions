题目简述：

> 编写一个算法来判断一个数 `n` 是不是快乐数。
>
> **「快乐数」** 定义为：
>
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
>
> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

题目链接：[202. 快乐数](https://leetcode.cn/problems/happy-number/)

# HashSet 判别环路

## 思路

这个思路非常直接，直接按快乐数的定义模拟并检测是否存在环，时间开销也很低，只不过空间开销较大，是最简单暴力的重复检测办法。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(k)$——这是 HashSet 存储数字带来的开销。

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        set.add(n);
        while (true) {
            n = happy(n);
            if (n == 1) return true;
            if (set.contains(n)) return false;
            set.add(n);
        }
    }

    private int happy(int n) {
        int res = 0;
        while (n > 0) {
            int digit = n % 10;
            res += digit * digit;
            n /= 10;
        }
        return res;
    }
}
```

# Floyd 判圈算法

## 思路

> 其实就是快慢指针、龟兔赛跑！

将一个数字本身视为状态，视其逐数码的平方和为下一个状态，于是可以用 Floyd 判圈算法——其实就是快慢指针判别环路。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

在力扣平台 Java 的测试用例中，这样的实现比 HashSet 还快，相比是因为 HashSet 带来的实际常数时间开销还是相对大的——在 $O(n)$ 的总体时间复杂度下。

```java
class Solution {
    public boolean isHappy(int n) {
        int a = n;
        int b = n;
        while (b != 1) {
            a = happy(a);
            b = happy(happy(b));
            if (a == b && b != 1) return false;
        }
        return true;
    }

    private int happy(int n) {
        int res = 0;
        while (n > 0) {
            int digit = n % 10;
            res += digit * digit;
            n /= 10;
        }
        return res;
    }
}
```

# 数论技巧

## 思路

可以证明，在十进制下，除了到达 1 的吸收点外，所有非快乐数最终都会掉进这个 8 长度环：
$$
4\to 16\to 37\to 58\to 89\to 145\to 42\to 20\to 4
$$
也就是说，最终所有数字要么收敛到 1——即快乐数，要么在上述环中不断循环。

代码写起来当然非常简单——但初次面对本问题时，我们真的能想到这点并快速地证明出来吗？