题目简述：

> 给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。
>
> 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。
>
> 返回一个表示每个字符串片段的长度的列表。

题目链接：[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

# 显式区间排序合并区间

## 思路

合并区间我认为是一个非常直观的思路，这样实现的算法在性能上相当令人满意，更重要的是该算法很容易想出来，甚至是一种读完问题描述后的直觉与灵感。

由于问题描述中明确了 `s` 仅由小写英文字母组成，因此我们可以实现用一个哈希表（或更高效地，用一个二维数组）记录每种字符首次出现与最后一次出现的位置，这只需要一次遍历就可以做到。

然后，根据题目描述的一个要求：一个字符只能被包含在一个区间中，由于至多存在 26 种小写字符，因此我们现在至多有 26 个小区间。这些小区间可能存在交集，也可能并不相交。

现在我们开始合并区间，对于存在交集的区间（判断方式是是否有一个区间的右端点位于另一个区间的左端点的左侧），我们将其合并为一个更大的区间，这包括了一个区间完全被包含于另一个区间的情况。

在合并时，为满足题目描述的另一个要求：尽可能多地划分区间，因此对于不存在交集的区间，我们不进行合并。

就这样，当已经不存在还能合并的区间时，这些区间彼此相邻，于是我们便在使一个字符只出现在一个片段的前提下，实现了尽可能多的区间划分。

---

合并区间时为高效实现可以考虑区间排序，这也是一个常见的手法。

首先将所有区间按左端点索引大小排序，接着遍历排序后的区间，如果下一个区间的左端点索引小于前一个区间右端点的索引，则意味着两区间相交，于是可以进行合并。合并的具体操作是更新下一个区间左端点的索引为前一个区间左端点的索引（因为必然后者更小），然后更新下一个区间右端点索引为两个区间中右端点索引的最大值。

若反之，如果下一个区间的左端点索引不小于前一个区间右端点的索引，则可以将上一个区间加入到结果列表中。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[][] intervals = new int[26][2];
        for (int[] interval : intervals) { interval[0] = -1; interval[1] = -1; }
        int n = s.length();

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (intervals[c - 'a'][0] == -1) {
                intervals[c - 'a'][0] = i;
            }
            intervals[c - 'a'][1] = i;
        }

        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        List<List<Integer>> merged = new ArrayList<>();
        for (int i = 0; i < 25; i++) {
            if (intervals[i][0] == -1) continue;

            if (intervals[i][1] > intervals[i + 1][0]) {
                intervals[i + 1][0] = intervals[i][0];
                intervals[i + 1][1] = Math.max(intervals[i + 1][1], intervals[i][1]);
            } else {
                merged.add(List.of(intervals[i][0], intervals[i][1]));
            }
        }
        merged.add(List.of(intervals[25][0], intervals[25][1]));

        List<Integer> res = new ArrayList<>();
        for (List<Integer> mergedInterval : merged) {
            res.add(mergedInterval.get(1) - mergedInterval.get(0) + 1);
        }
        return res;
    }
}
```

# 贪心实现

## 思路

上述实现是显式对区间进行排序。如果我们实际上只需要合并区间，则并不需要先显式对区间进行排序再进行合并，可以实现直接得到合并区间的贪心算法，虽然在时间复杂度数量级上并不存在差异，但代码会简洁不少。

本问题的贪心实现思路是：

- 在上一个实现中，我们对每个字符记录了首次出现位置与最后出现位置，从而得到 26 个小区间，对小区间们排序后进行合并（排序是为了方便合并）。在贪心算法的思路中，我们在第一次遍历里只记录每个字符最后出现的位置，不需要记录首次出现的位置，记字符最后出现的位置数组为 `last`；
- 得到 `last` 后，通过指针 `i` 进行第二次遍历，此时用一个变量 `end` 维护当前区间的右端点，取 `end = max(end, last[s[i]])`，`end` 实际上意味着当前区间的右端点至少应为多大；
- 当且仅当 `i == end`，意味着此时当前区间内包含的所有种类的字符都已经出现过了最后一次，即使区间的右端点继续延展也不会再遇见当前区间内所包含的字符，这一情况下为最大化区间数量，就需要对区间 “切一刀”，开启新的区间。

这样也能得到区间合并后的结果，但事实上并没有进行区间排序与显式的合并操作。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int n = s.length();

        int[] last = new int[26];
        for (int i = 0; i < n; i++) {
            last[s.charAt(i) - 'a'] = i;
        }

        int start = 0;
        int end = 0;
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (end == i) {
                res.add(end - start + 1);
                start = end + 1;
            }
        }

        return res;
    }
}
```
