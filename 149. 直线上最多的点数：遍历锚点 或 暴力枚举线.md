题目简述：

> 给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

题目链接：[149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

# 暴力枚举遍历线

## 思路

没啥思路，两点唯一确定一条直线，枚举所有不同的两点组合就能枚举所有直线，然后看有多少个点落在这个直线上就可以了。

一个小关键是最好考虑直线的一般式 $Ax+By+C=0$，避免了斜率不存在与小数精度问题。

不是很懂为什么这个题能是 hard，最暴力的解法都完全能 AC，并且不会花费太多时间。

当然这远不是最优方案，因为对枚举出的每条直线都需要遍历两次整个点集，毕竟我们本身没有线集，只能先以 $O(n^2)$ 的时间代价遍历点集枚举出线、对每条线再以 $O(n)$ 的时间代价遍历点集统计线上的点，最后总的时间开销来到 $O(n^3)$。

## 代码

算法的时间复杂度为 $O(n^3)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n < 2) return n;

        int maxCount = 0;
        // 两点确定一条直线，考虑无序对组合
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int count = countLinePoints(points, points[i][0], points[i][1], points[j][0], points[j][1]);
                maxCount = Math.max(maxCount, count);
            }
        }

        return maxCount;
    }

    private int countLinePoints(int[][] points, int x1, int y1, int x2, int y2) {
        /* 解直线一般式的一次非齐次线性方程
        Ax1 + By1 + C = 0
        Ax2 + By2 + C = 0
        */
        int A = y2 - y1;
        int B = x1 - x2;
        int C = x2 * y1 - x1 * y2;

        int count = 0;
        for (int[] point : points) {
            if (A * point[0] + B * point[1] + C == 0) count++;
        }
        return count;
    }
}
```

## 记忆化搜索

可以为线的搜索加上记忆化缓存，避免多点共线时重复探索一条已知直线。

但这依然没解决对每条未知直线都需要遍历整个点集的问题，最坏时间复杂度仍为 $O(n^3)$。

```java
record Line(int A, int B, int C) {}

class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n < 2) return n;

        int maxCount = 0;
        Set<Line> cache = new HashSet<>();
        // 两点确定一条直线，考虑无序对组合
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                /* 解直线一般式的一次非齐次线性方程
                Ax1 + By1 + C = 0
                Ax2 + By2 + C = 0
                */
                int A = points[j][1] - points[i][1];
                int B = points[i][0] - points[j][0];
                int C = points[j][0] * points[i][1] - points[i][0] * points[j][1];
                Line line = new Line(A, B, C);
                if (cache.contains(line)) continue;
                maxCount = Math.max(maxCount, countLinePoints(points, A, B, C));
                //cache.add(line);
            }
        }

        return maxCount;
    }

    private int countLinePoints(int[][] points, int A, int B, int C) {
        int count = 0;
        for (int[] point : points) {
            if (A * point[0] + B * point[1] + C == 0) count++;
        }
        return count;
    }
}
```

# 遍历锚点

其实锚点这个说法不太适合，更好的说法是 fixed point。

## 思路

线视角枚举线无法避免最坏时间复杂度总为 $O(n^3)$，因为归根结底我们实际上只有点集而没有线集，枚举线需要我们先通过枚举点得到线再在线上遍历一次点集，但点视角枚举点可以做到稳定 $O(n^2)$ 的时间复杂度，只遍历一次点集。

具体怎么做呢？这里引用力扣官方题解中的描述：

> 我们可以考虑枚举所有的点，假设直线经过该点时，该直线所能经过的最多的点数。
>
> 假设我们当前枚举到点 $i$，如果直线同时经过另外两个不同的点 $j$ 和 $k$，那么可以发现点 $i$ 和点 $j$ 所连直线的斜率恰等于点 $i$ 和点 $k$ 所连直线的斜率。
>
> 于是我们可以统计其他所有点与点 $i$ 所连直线的斜率，出现次数最多的斜率即为经过点数最多的直线的斜率，其经过的点数为该斜率出现的次数加一（点 $i$ 自身也要被统计）。

设计双层循环，外层循环 $i$ 对应的点作为锚点，内层循环 $j$ 遍历整个点集，将点集中的所有点按其与锚点所确定的方向进行分类计数。

原理是，在确定了锚点的前提下，直线能够被其斜率唯一确定（包括斜率不存在的情况），于是我们就能够找出以 $i$ 对应的点作为锚点的线——即所有经过 $i$ 对应的点的线中，经过最多点数的线上的点数量。当 $i$ 也完成了遍历，我们就能够找出过任意一点的线中经过点最多的线上的点数——这实际上就是全局过最多点的线的点数。

如何高效地对方向进行分类计数是一个问题。

- 首先斜率不能考虑。就算我们选择单独处理斜率不存在的情况，在计算机中斜率作为浮点数也存在精度误差。在 IEEE 754 标准下，当两个双精度浮点数的绝对差额小于 $2^{-52}$，就可能因为精度问题而导致不等。

  但其实这在本问题的数据范围中不会发生这一情况，因为点坐标的绝对值被限定在 $10^4$，对于该范围内两整数相除所得到的有理数，两个有理数的绝对差额不可能小于 $2^{-52}$。但为了算法的泛用性，我们仍不考虑斜率。

- 既然不考虑浮点数斜率，那么我们就考虑两个坐标轴上每个分量的绝对变化量 $\mathrm{d}x,\mathrm{d}y$，这是两个整数。但变化量是绝对量，如何去掉绝对量的影响呢？我们需要对变化量进行加工。

  一个简单的方案就是计算两个变化量的最大公约数 $g=\mathrm{gcd}(\mathrm{d}x,\mathrm{d}y)$，然后分别让两个变化量除以其最大公约数，就可以消除绝对量的影响了，得到既约数对。

  对于既约数对，由于是两个 32 位的 `int`，因此可以压缩为一个 `long` 以直接使用 `HashMap<Long, Integer>`。最后，还要注意符号，对既约数对 $(\mathrm{d}x,\mathrm{d}y)$ 而言，$(3,-4)$ 与 $(-3,4)$ 表示的是同一方向。

这里补充计算最大公约数 $\mathrm{gcd}$ 的算法：算法的原理是
$$
\mathrm{gcd}(a,\,b)=\mathrm{gcd}(a\% b,\,b)
$$
因此令
$$
\left\{\begin{align}&a'=b\\\\&b'=a\% b\end{align}\right.
$$
将新的 $a'$ 视为 $a$、将新的 $b'$ 视为 $b$，这样 $b'$ 很快会减少至 $0$，此时的 $a'$ 即为最大公约数。

因此设计算法，

1. `tmp = b`
2. `b = a % b`
3. `a = tmp`
4. 如果成立 `b == 0`，则 `a` 为所求最大公约数，否则回到第一步重复执行。

## 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

下方的实现中，为什么可以取 `int j = i + 1;` 而不必是 `int j = 0;` 呢？取 `int j = 0;` 当然也不影响算法的正确性，但进行了不必要的计算——其实我最初写的算法取的就是 `int j = 0;`。对此，GPT 5 - thinking 是这样解释的：

>***目标是什么？***
>
>找一条**包含最多点**的直线，设这条直线上的点集合是 $S$，点的下标从小到大排序后是
>$$
>S=\{p_{i_0},p_{i_1},\cdots,p_{i_{k-1}}\},\ \ \ i_0<i_1<\cdots<i_{k-1}
>$$
>***关键不变式***
>
>当我们枚举到锚点 $i=i_0$（这条最优直线在全体点中的**最小下标**）时，内层 `j` 取 `i+1..n-1` 会遍历到 **这条直线上的所有其余点**：
>$$
>\{p_{i_1},\cdots,p_{i_{k-1}}\}\subseteq\{j:j>i_0\}
>$$
>所以，这一轮把这些点按“方向键”（约分后的 $(\mathrm{d}x,\mathrm{d}y)$，做了符号统一）归到**同一个桶**，桶内计数就是 $k-1$。再把锚点自己（以及重复点的 `dup`，这题无重复就 +1）加回去，得到这一轮的值就是 $k$。对所有锚点取最大，至少会拿到这条最优直线的 $k$，因此全局答案正确。
>
>> 换句话说：**不需要每个锚点都看见所有其他点**。只要存在“某个锚点能把它那条最优直线上的其余点都看到”（这个锚点就是那条线里**下标最小**的点），全局最大值就会在那一轮被正确统计到。

请结合代码理解。

```java
class Solution {
    public int maxPoints(int[][] points) {
        Map<Long, Integer> map = new HashMap<>();
        int maxPointsNum = 0;
        for (int i = 0; i < points.length; i++) {
            for (int j = i + 1; j < points.length; j++) {
                // if (i == j) continue;
                int dx = points[i][0] - points[j][0];
                int dy = points[i][1] - points[j][1];
                /* 统一符号，规定 dx 为正，或在 dx 为零时 dy 非负 */
                if (dx < 0) {
                    dx = -dx;
                    dy = -dy;
                } else if (dx == 0) {
                    dy = Math.abs(dy);
                }
                int gcd_ = gcd(dx, dy);
                long key = pair(dx / gcd_, dy / gcd_);
                map.merge(key, 1, Integer::sum);
            }
            maxPointsNum = Math.max(maxPointsNum, map.isEmpty() ? 1 : Collections.max(map.values()) + 1);
            map.clear();
        }
        return maxPointsNum;
    }

    private long pair(int a, int b) {
        return ((long) a << 32) | (b & 0xffffffffL);
    }

    private int gcd(int a, int b) {
        /* gcd(a, b) = gcd(b, a % b) */
        a = Math.abs(a);
        b = Math.abs(b);
        if (a == 0) return b;
        if (b == 0) return a;
        while (b > 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }
}
```
