题目简述：

> 给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

题目链接：[316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

# 我的原创解法（贪心字典序）

## 思路

我想，假设 `s` 中一共有 `m` 个不重复字符，那么最终答案必然仅包含 `m` 个不重复字符。

问题在于如何排列才能使得结果合法。一方面字典序要尽可能小，另一方面又要保证字符的相对位置不变。

对于字典序，越靠前的元素对字典序的影响越大，因此应尽可能让 ASCII 码更小的字符置于结果的前方。

如果 `s` 中存在 `'a'`，这是 ASCII 码最小的拉丁字母，那么只要首个 `'a'` 的右侧有 `m - 1` 个不重复元素，我们就应该让 `'a'` 放在首位。如果 `'a'` 不满足这一点，那我们就只好尝试顺延到 `'b'` 了，以此类推。

确定了结果中首位放置什么元素后，对于结果的第二位，我们应再次从 `'a'` 开始考虑未使用的字符。这次不能再搜索 `s` 中全局首个 `'a'` 右侧有多少个不重复元素了，应当考虑结果中首位放置的元素其后的首个 `'a'` 右侧有多少个不重复元素。如果 `'a'` 不满足要求，则以此类推至其他字符。

这一方案听上去似乎可行，但似乎并不方便实现，主要问题在于如何在确定了一位结果后动态更新每个元素在最新确定元素其后的首个元素右侧有多少个不重复元素。

或许可以维护字符 key 到哈希映射 value 的映射，每个 value 维护了在首个 key 字符后的各个字符的首个位置右侧有多少个不重复元素——但这样常数操作太多了。应该有更好的实现方案。

记录所有字符出现的索引吗？空间复杂度会来到 $O(n)$，似乎也不能算好方案。

想到了，记录各个字符们最后出现的位置即可！因为在字符最后出现的位置后再也不存在该字符了，而对于字符在最后位置左侧出现过的情况也不影响结果，因为我们需要的只是在某个字符的右侧还有多少个未使用的不重复元素，而不关心重复的元素到底重复了多少次。

## 代码

算法的时间复杂度为 $O(|\Sigma|^2n)$，空间复杂度为 $O(|\Sigma|)$。

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        int[] loc = new int[26];  // 各字符最后出现的位置
        Arrays.fill(loc, -1);
        int cnt = 0;  // 如果扫描到了 26 个字符就提前返回，同时也记录 s 中一共有多少个不重复元素

        for (int i = s.length() - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (loc[c - 'a'] == -1) {
                loc[c - 'a'] = i;
                cnt++;
                if (cnt == 26) break;
            }
        }

        char[] res = new char[cnt];
        boolean[] used = new boolean[26];
        for (int i = 0; i < 26; i++) {
            if (loc[i] == -1) used[i] = true;  // 未出现字符标记为不可用（逻辑上可视为已使用）
        }

        int index = 0;
        res_loop:  // 构造结果字符串的循环
        for (int i = 0; i < cnt; i++) {
            char_loop:  // 构造一位结果时优先考虑更小字符的循环
            for (int j = 0; j < 26; j++) {
                if (!used[j]) {
                    char_index_loop:  // 寻找优先考虑字符在数组中首个索引的循环
                    for (int k = index; k < s.length(); k++) {
                        char c = s.charAt(k);
                        if (c - 'a' != j) continue;
                        int count = 0;
                        used[j] = true;
                        valid_loop:  // 验证优先考虑的字符是否能够合法地作为此位结果的循环
                        for (int z = 0; z < 26; z++) {
                            if (!used[z] && k < loc[z]) count++;
                        }
                        if (count == cnt - i - 1) {
                            res[i] = (char) (j + 'a');
                            index = k + 1;
                            continue res_loop;
                        }
                        used[j] = false;
                    }
                }
            }
        }

        return new String(res);
    }
}
```

# 主流解法 · 单调栈 & 贪心算法

## 思路

> 首先考虑一个简单的问题：给定一个字符串 $s$，如何去掉其中的一个字符 $ch$，使得得到的字符串字典序最小呢？答案是：找出最小的满足 $s[i]>s[i+1]$ 的下标 $i$，并去除字符 $s[i]$——前提是字符 $s[i]$ 的字面量在稍后还会再次出现。
>

同样地可以先记录各字符最后出现的索引用来判断 $s[i]$ 的字面量稍后是否还会再次出现。

> 对于 $s=cbacdcbc$，从左到右遍历其中的字母。
>
> 1. $s[0]=c$。由于只遍历了一个字母，目前已知字典序最小的字符串是 $c$。
> 2. $s[1]=b$。如果右边没有字母 $c$，那么 $s[0]=c$ 必须保留；实际上右边还有字母 $c$，由于 $b<c$，我们可以去掉 $c$，改用 $b$ 当作目前字典序最小的字符串。
> 3. $s[2]=a$。同样的，由于 $a<b$ 且比右边还有字母 $b$，我们可以去掉 $b$，改用 $a$ 当作目前字典序最小的字符串（下面记作 $ans$）。
> 4. $s[3]=c$。由于 $c$ 比 $a$ 大，只能添加到 $a$ 后面，现在 $ans=ac$。
> 5. $s[4]=d$。由于 $d$ 比 $c$ 大，只能添加到 $c$ 后面，现在 $ans=acd$。
> 6. $s[5]=c$。由于 $acd$ 里面已经有 $c$ 了，直接跳过。现在 $ans=acd$。
> 7. $s[6]=b$。我们发现 $b$ 比 $d$ 小，能不能像上面 $s[1]$ 和 $s[2]$ 那样，去掉 $d$，添加 $b$ 呢？这是不行的，因为后面没有 $d$ 了，我们只能老老实实地添加到 $d$ 后面，现在 $ans=acdb$。
> 8. $s[7]=c$。由于 $acdb$ 里面已经有 $c$ 了，直接跳过。

一句话概括是：尽量维护栈内元素自栈底至栈顶单调递增，如果尝试压入栈的元素更小，当且仅当在后续栈顶元素还会再次出现时才允许弹出栈顶。此外，如果元素已经在栈内存在了，则不尝试压栈。

最终，栈内的元素即为按要求去除重复字母后的结果。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(|\Sigma|)$。

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        int n = s.length();
        int[] loc = new int[26];
        Arrays.fill(loc, -1);
        for (int i = 0; i < n; i++) {
            loc[s.charAt(i) - 'a'] = i;
        }

        boolean[] used = new boolean[26];
        char[] stack = new char[26];
        int top = -1;

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            int idx = c - 'a';
            if (used[idx]) continue;

            while (top >= 0 && stack[top] > c && loc[stack[top] - 'a'] > i) {
                used[stack[top] - 'a'] = false;
                top--;
            }

            stack[++top] = c;
            used[idx] = true;
        }

        return new String(stack, 0, top + 1);
    }
}
```

