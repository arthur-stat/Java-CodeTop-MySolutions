题目简述：

> 给定一棵二叉树中的两个节点 p 和 q，返回它们的最近公共祖先节点（LCA）。
>
> 每个节点都包含其父节点的引用（指针）。Node 的定义如下：
>
> ```java
> class Node {
>        public int val;
>        public Node left;
>        public Node right;
>        public Node parent;
> }
> ```
>
> 根据维基百科中对最近公共祖先节点的定义：“两个节点 p 和 q 在二叉树 T 中的最近公共祖先节点是后代节点中既包括 p 又包括 q 的最深节点（我们允许一个节点为自身的一个后代节点）”。一个节点 x 的后代节点是节点 x 到某一叶节点间的路径中的节点 y。

题目链接：[1650. 二叉树的最近公共祖先 III](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/description/)

LeetCode Wik 链接：[1650. 二叉树的最近公共祖先 III](https://leetcode.doocs.org/lc/1650/)

> Note: 2025/11/27 字节日常实习一面考了我这道题。虽然是 mid 难度的题目，但是过于冷门，尽管我做完了 Top 500，但这道题至少是 Top 1000 ~ Top 2000（CodeTop 上有记录的面试考察记录仅一次，截止至 2025/11/28），我根本就没有见过这个问题，也没有相似的题目（[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 仅需后序遍历，与本问题方法完全不同）。我不觉得回到面试时我还能在面试的那点时间内想出来这道题的正确解法，虽然我觉得我的项目和八股答得还不错，但算法的确在事实上没有写出来正确结果，被字节挂掉也算应该。不过毕竟我是 28 届，继续努力吧。

# 相交链表

与 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 不同，本问题中输入没有给定根节点，因此不能直接考虑后序遍历了。与此同时，本问题中的节点是双向的，节点中含有指向父节点的指针，因此应考虑自底而上的遍历方式。

正确的思路是考虑相交链表，也就是说本问题的正确思路更像是 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)，这样能实现 $O(h)$ 时间复杂度的算法，其中 $h$ 是树的高度。

> 面试的时候我一直在尝试向 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 的后序遍历对齐……因为我记得很清楚 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 就是后序遍历。实际上这样也能做，即暴力解法，只是时空开销上不是最优。

# 暴力解法

## 思路

暴力解法的实现时间复杂度为 $O(n)$，思路是任意挑选一个目标节点不断找到其父节点，那么最终我们一定能到达父节点为 `null` 的根节点。该过程的时间复杂度是 $O(h)$ 的。

有了根节点后，我们就可以忽略掉各节点中指向父节点的指针了，从而将问题转化为已解决的 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)，考虑后序遍历再在 $O(n)$ 的时间复杂度下就能找出 LCA。

该方法虽说时间复杂度稍高，但至少在面试场景下没想出来相交链表方法时是完全可以考虑的。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(h)$，其中空间复杂度来自于递归栈的开销。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
//        /* ACM 模式模板 */
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  // new FileReader(...)
//        String line;
//        while ((line = br.readLine()) != null) {
//            // ...
//        }

        Node n6 = new Node(6); Node n7 = new Node(7);
        Node n4 = new Node(4); Node n0 = new Node(0);
        Node n8 = new Node(8); Node n2 = new Node(2, null, n7, n4);
        n7.parent = n2; n4.parent = n2; Node n5 = new Node(5, null, n6, n2);
        n6.parent = n5; n2.parent = n5; Node n1 = new Node(1, null, n0, n8);
        n0.parent = n1; n8.parent = n1; Node top = new Node(3, null, n5, n1);
        n5.parent = top; n1.parent = top;
        // 树示意图
        //     3
        //    / \
        //   5   1
        //  / \ / \
        // 6  2 0  8
        //   / \
        //  7   4

        Node p = n6;
        Node q = n4;
        Node root = p;
        while (root.parent != null) root = root.parent;
        Node lca = LCA(root, p, q);
        System.out.println("LCA is " + (lca == null ? "null" : lca.val));
    }

    /**
     * 后序遍历（这里直接引用我在 236 题的实现）：
     *  - 如果左右子树中分别存在一个目标节点，则（后续遍历中的首个）该节点即为 LCA；
     *  - 如果其中一个子树存在一个目标节点且当前节点为另一个目标节点，则该节点为 LCA。
     */
    private static Node LCA(Node node, Node p, Node q) {
        if (node == null || node == p || node == q) return node;
        Node l = LCA(node.left, p, q);
        Node r = LCA(node.right, p, q);
        if (l != null && r != null) return node;
        else if (l != null) return l;
        else if (r != null) return r;
        return null;
    }

    public static class Node {

        int val;
        Node parent;
        Node left;
        Node right;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node parent, Node left, Node right) {
            this.val = val;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }
}
```

# 哈希表记录路径

## 思路

在知道本问题大致思路与相交链表相同后，本方法很容易想到。

从一个目标节点出发不断向上遍历父节点，直至遍历到根节点，记录遍历过程中路径上的各节点。然后，再从另一个目标节点出发不断向上遍历父节点，对当前遍历的节点检查其是否存在于此前记录的路径中。首个存在于路径中的节点即为 LCA。

## 代码

算法的时间复杂度为 $O(h)$，空间复杂度为 $O(h)$。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) throws IOException {
//        /* ACM 模式模板 */
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  // new FileReader(...)
//        String line;
//        while ((line = br.readLine()) != null) {
//            // ...
//        }

        Node n6 = new Node(6); Node n7 = new Node(7);
        Node n4 = new Node(4); Node n0 = new Node(0);
        Node n8 = new Node(8); Node n2 = new Node(2, null, n7, n4);
        n7.parent = n2; n4.parent = n2; Node n5 = new Node(5, null, n6, n2);
        n6.parent = n5; n2.parent = n5; Node n1 = new Node(1, null, n0, n8);
        n0.parent = n1; n8.parent = n1; Node top = new Node(3, null, n5, n1);
        n5.parent = top; n1.parent = top;
        // 树示意图
        //     3
        //    / \
        //   5   1
        //  / \ / \
        // 6  2 0  8
        //   / \
        //  7   4

        Node p = n6;
        Node q = n4;
        Node lca = null;

        Set<Node> path = new HashSet<>();
        while (p != null) {
            path.add(p);
            p = p.parent;
        }
        while (q != null) {
            if (path.contains(q)) {
                lca = q;
                break;
            }
            q = q.parent;
        }
        System.out.println("LCA is " + (lca == null ? "null" : lca.val));
    }

    public static class Node {

        int val;
        Node parent;
        Node left;
        Node right;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node parent, Node left, Node right) {
            this.val = val;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }
}
```

# 双指针

## 思路

类似 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 中的双指针法，两个指针分别置于两个初始节点同时地不断向上遍历父节点，指针抵达根节点后再重新从另一目标节点再次出发。这样，当两个指针最终相遇时，所处的节点即为 LCA。

相关原理请参见我为 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 所撰写的题解中的分析。

## 代码

算法的时间复杂度为 $O(h)$，空间复杂度为 $O(1)$，无额外空间开销。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
//        /* ACM 模式模板 */
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  // new FileReader(...)
//        String line;
//        while ((line = br.readLine()) != null) {
//            // ...
//        }

        Node n6 = new Node(6); Node n7 = new Node(7);
        Node n4 = new Node(4); Node n0 = new Node(0);
        Node n8 = new Node(8); Node n2 = new Node(2, null, n7, n4);
        n7.parent = n2; n4.parent = n2; Node n5 = new Node(5, null, n6, n2);
        n6.parent = n5; n2.parent = n5; Node n1 = new Node(1, null, n0, n8);
        n0.parent = n1; n8.parent = n1; Node top = new Node(3, null, n5, n1);
        n5.parent = top; n1.parent = top;
        // 树示意图
        //     3
        //    / \
        //   5   1
        //  / \ / \
        // 6  2 0  8
        //   / \
        //  7   4

        Node p = n6;
        Node q = n4;

        Node ptr1 = p;
        Node ptr2 = q;
        while (true) {
            if (ptr1 == null) ptr1 = q;
            if (ptr2 == null) ptr2 = p;
            ptr1 = ptr1.parent;
            ptr2 = ptr2.parent;
            if (ptr1 == ptr2) {
                System.out.println("LCA is " + ptr1.val);
                break;
            }
        }
    }

    public static class Node {

        int val;
        Node parent;
        Node left;
        Node right;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node parent, Node left, Node right) {
            this.val = val;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }
}
```

# 后记

重新认真分析完本题后，感觉更多的是可惜。这个问题不应该没 A 出来的，可能是第一次面试太紧张吧。