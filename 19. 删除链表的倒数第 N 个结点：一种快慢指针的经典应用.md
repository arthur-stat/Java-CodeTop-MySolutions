题目简述：

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

题目链接：[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

# 思考

1. 要删除链表的倒数第N个结点，最简单的办法当然就是先遍历一次找到链表的总长度，再用总长度减N得到需要删除的节点所处链表中的位置，再遍历一次找到这个位置，进行断开连接的操作。这样当然可以，而且实现起来很简单，但并不优雅，进行了两遍扫描，如果记链表长度为m，则可能要访问2m次。

   这个方法其实也可以看成双指针/快慢指针，只不过慢指针等快指针先遍历完、得知链表总长度后慢指针才出动。

2. 另一个思路是利用快慢指针并让快慢指针并行启动，同时让快指针每次自增2、慢指针每次自增1，这样当快指针到底时我们就知道了链表的总长度，这时如果倒数第N个节点在链表的后半部分，那么直接计算出位置，让正位于中点的慢指针继续遍历下去即可；如果倒数第N个节点在链表的前半部分，那么直接从头遍历即可。利用快慢指针，最多只需要进行1.5m次访问，效率要高了一点。

3. 但1.5m是不是还是有点高了呢？这就是这个问题有意思的地方：我们其实可以严格保证只需要进行m次访问就删除倒数第N个节点！

# 快慢指针

我们知道，对于链表的问题，很多都是需要利用双指针的。如果希望最多只访问m次就删除倒数第N个节点，思路照样是双指针，而且同样是快慢指针，但为提高效率，我们要在快慢指针的设计上做手脚。

我们此前让快指针每次自增2，其实2是没有理由的，这只是为了让他比慢指针更“快”而选定的一个数值。为什么不是3、不是4呢？回到设置快指针的目的本身，我们设置快指针是为了让他早一点探查到链表的长度，从而让我们计算出倒数第N个节点的顺序位置，进而再配合已知的链表总长度与慢指针删除指定节点。既然如此，为什么一定要设置快指针自增2呢？2是没有道理、没有支持的。

那到底该让快指针自增几呢？回到问题本身：删除链表的倒数第N个结点，那有没有可能，虽然起初设置快指针是为了获取列表长度再得知要删除的节点位于哪个位置，但其实我们根本**没必要知道链表的具体长度**呢？***只要让快指针先行N+1步，然后再启动慢指针，两个指针均每次自增一，这样当快指针到达链表尾时，慢指针不就刚好在倒数第N+1个节点，也就是倒数第N个节点的前驱节点嘛？***不难证明，这种方法我们每次都只需要m次访问。

只要想通了这一点，在m次访问中就解决这个问题的算法设计就很明确了。这个问题的编程不难，问题是能不能想到这一点。

该问题实际上正是快慢指针的经典应用。***“快”和“慢”不一定是体现在指针行进速度上的，也可以体现在先后关系上，一定不要陷入某一种思维模式里把自己困住了。***

# 代码

由于要断开连接就需要引用前驱节点，因此为避免单独处理无前驱节点的首节点，可以在头部插入一个哨兵节点。这算是链表相关算法问题很常用的一个小技巧吧。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */


class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode virtual = new ListNode(0, head);
        ListNode fast = virtual;
        ListNode slow = virtual;

        for (int i = 0; i < n + 1; i++) fast = fast.next;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return virtual.next;
    }
}
```

