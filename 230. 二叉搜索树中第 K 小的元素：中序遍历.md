题目简述：

> 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

题目链接：[230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

# 分析

最简单的方案当然是直接进行中序遍历，遍历到第 $k$ 个元素时结束。

> 注：无论是递归还是显式栈，中序遍历均只能做到 $O(n)$ 的时间复杂度与 $O(n)$ 的最坏空间复杂度。除非考虑 Morris 遍历，这样可以实现 $O(1)$ 空间复杂度，但将会使问题极大的复杂化。

# 递归代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    int count;
    int k;

    public int kthSmallest(TreeNode root, int k) {
        count = 0;
        this.k = k;
        return dfs(root);
    }

    private int dfs(TreeNode node) {
        int res;

        if (node.left != null) {
            res = dfs(node.left);
            if (res != -1) return res;
        }

        count++;
        if (count == k) return node.val;


        if (node.right != null) {
            res = dfs(node.right);
            if (res != -1) return res;
        }

        return -1;
    }
}
```

# 迭代代码

```java
class Solution {

    public int kthSmallest(TreeNode root, int k) {
        int count = 0;
        Deque<TreeNode> s = new ArrayDeque<>();

        while (count < k) {
            if (root != null) {
                s.push(root);
                root = root.left;
                continue;
            }

            count++;
            TreeNode cur = s.pop();
            if (count == k) return cur.val;

            root = cur.right;
        }

        return 666666;
    }
}
```

