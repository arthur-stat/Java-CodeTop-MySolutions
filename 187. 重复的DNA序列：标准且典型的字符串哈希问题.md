题目简述：

> **DNA序列** 由一系列核苷酸组成，缩写为 `'A'`, `'C'`, `'G'` 和 `'T'`.。
>
> - 例如，`"ACGAATTCCG"` 是一个 **DNA序列** 。
>
> 在研究 **DNA** 时，识别 DNA 中的重复序列非常有用。
>
> 给定一个表示 **DNA序列** 的字符串 `s` ，返回所有在 DNA 分子中出现不止一次的 **长度为 `10`** 的序列(子字符串)。你可以按 **任意顺序** 返回答案。

题目链接：[187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/)

# 思路

没有太多好讲的，很标准很典型的一个字符串哈希问题，即滚动哈希（rolling hash）。

考虑 Rabin–Karp 算法编码，对两个数组上每个固定长度 $10$ 的子数组计算多项式哈希，定义索引窗口 $[i,i+10)$ 上的哈希函数为
$$
H_{i}=(a_iB^{9}+a_{i+1}B^{8}+\cdots+a_{i+9}B^0)\mod{M}
$$
其中 $B$ 为所选取的基数，$M$ 为足够大的质数，例如经典的 `1_000_000_007L` 与 `1_000_000_009L`，应满足 $1<B<M$。通常 $B$ 会选择一个较大的随机数。

如果希望降低哈希碰撞的概率，可用考虑双模哈希校验，选择两对 $(B_1,M_1)$ 与 $(B_2,M_2)$，考虑两个哈希函数同时校验。

对于一个确定的长为 $10$ 的索引窗口，一共能截取出 $n-9$ 个子串，因此在 `s` 上将产生 $n-9$ 个哈希值，我们通过比较哈希值以快速判断是否存在重复子数组。在绝大多数情形下，可以认为如果哈希值相同，那么两子串相等，尽管严格来讲这肯定是不准确的，因为存在哈希冲突。不过，在双哈希的方案下这是几乎不可能发生的情况。

当我们已经拥有索引窗口 $[i,i+10)$ 的哈希值 $h$ 时，类似滚动数组地，$h\cdot B-s[i]\cdot B^{10}+s[i+10]$ 即为索引窗口 $[i+1,i+11)$ 的哈希值，由此可以快速地解出各窗口的哈希值，这就是所谓的滚动哈希。

# 代码

```java
class Solution {

    private static final Random rand = new Random("miku".hashCode());
    public static final long M1 = (long) 1e9 + 7;
    public static final long M2 = (long) 1e9 + 9;
    public static final long B1 = rand.nextLong(2, M1);
    public static final long B2 = rand.nextLong(2, M2);

    public List<String> findRepeatedDnaSequences(String s) {
        if (s.length() < 10) return Collections.emptyList();

        int n = s.length();
        Set<Integer> hash1 = new HashSet<>();
        Set<Integer> hash2 = new HashSet<>();
        Set<String> res = new HashSet<>();

        long h1 = 0;
        long h2 = 0;
        long POW_B1 = 1;
        long POW_B2 = 1;

        for (int i = 9; i >= 0; i--) {
            int c = s.charAt(i) - 'A';
            h1 += c * POW_B1;
            h2 += c * POW_B2;
            h1 %= M1;
            h2 %= M2;
            POW_B1 *= B1;
            POW_B2 *= B2;
            POW_B1 %= M1;
            POW_B2 %= M2;
        }

        hash1.add((int) h1);
        hash2.add((int) h2);

        for (int i = 10; i < n; i++) {
            int c = s.charAt(i) - 'A';
            int cc = s.charAt(i - 10) - 'A';
            h1 = h1 * B1 - cc * POW_B1 + c;
            h2 = h2 * B2 - cc * POW_B2 + c;
            h1 %= M1;
            h2 %= M2;
            boolean op1 = hash1.add((int) h1);
            boolean op2 = hash2.add((int) h2);
            if (!op1 && !op2) {
                res.add(s.substring(i - 9, i + 1));
            }
        }

        return new ArrayList<>(res);
    }
}
```

