题目简述：

> 数据范围：两个数字的长度都满足 $1\leqslant num1,num2\leqslant10^5$ ，数字中仅包含 $0\leqslant val\leqslant9$，第一位不可能是0

题目链接：[NC359 大数相减](https://www.nowcoder.com/practice/ae4d84312e384a1fa100b613f93f3fe0)

# 思路

类似 [415. 字符串相加](https://leetcode.cn/problems/add-strings/)，只不过由加法改为减法。

我的思路是：

1. 考虑到两个输入均被保证为正整数，因此可以统一用更大的数减更小的数，这样逻辑能够统一。

   为什么这样考虑呢？例如，$3-6$ 结果为负 $-3$，个位为 $3$；可 $13-6$ 结果为 $7$，个位为 $7$。显然，如果不能确保固定 `num1` 或 `num2` 为最大的数，我们就不知道小数码减大数码时是否会被允许借位，这会严重影响到我们逐位计算差的数码。当然也可以分类讨论是否存在借位的可能，但这样就相对麻烦了。我们只需要做两件事就可以统一逻辑：

   - 如果 `num1` 大于等于 `num2`，则结果非负，小数码减大数码必然被允许借位；
   - 如果 `num1` 小于 `num2`，则结果为负，那么交换 `num1` 与 `num2`——这样就确保了 `num1` 大于 `num2`，对正数的减法结果加一个负号即可——这是恒等变换，即：$a-b=c\Leftrightarrow b-a=-c$

2. 现在我们确定了计算时确保 `num1` 为最大的数，因此每次数码之差为负时，向高位借位即可。这样逻辑和代码能够大幅简化。

 # 代码

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param num1 string字符串 
     * @param num2 string字符串 
     * @return string字符串
     */
    public String substring (String num1, String num2) {
        boolean exchange = false;  // 是否交换过

        // 若 num1 < num2，交换 num1 与 num2
        if (num1.length() < num2.length()) {
            String tmp = num1;
            num1 = num2;
            num2 = tmp;
            exchange = true;
        } else if (num1.length() == num2.length()) {
            int index = 0;
            int len = num1.length();
            while (index < len) {
                if (num1.charAt(index) < num2.charAt(index)) {
                    String tmp = num1;
                    num1 = num2;
                    num2 = tmp;
                    exchange = true;
                    break;
                }
                index++;
            }
        }

        int i = num1.length() - 1;
        int j = num2.length() - 1;
        StringBuilder sb = new StringBuilder();
        boolean borrow = false;  // 是否借位
        
        // 只能处理 num1 >= num2（即结果非负），如不然则交换 num1 与 num2，结果取反
        while (i >= 0) {
            int digit = j >= 0 ? num1.charAt(i) - num2.charAt(j) : num1.charAt(i) - '0';
            if (borrow) {
                digit -= 1;
                borrow = false;
            }
            if (digit >= 0) {
                sb.append(digit);
            } else {
                sb.append(10 + digit);
                borrow = true;
            }
            i--;
            j--;
        }

        // 清理前缀零
        while (sb.length() > 1 && sb.charAt(sb.length() - 1) == '0') {
            sb.setLength(sb.length() - 1);
        }

        // 如果曾交换过，意味着结果本应为负
        if (exchange) sb.append('-');

        return sb.reverse().toString();
    }
}
```

