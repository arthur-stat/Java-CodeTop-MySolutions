题目简述：

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
>
> **进阶：**
>
> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题

题目链接：[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

# 思路

从 $0$ 开始向两侧移动双指针即可。

首先以最坏 $O(n)$ 的时间代价找到升序数组中负数与正数的分界点，从此处开始移动双指针，每次都将双指针所指向的数中平方最小的数加入到结果队列并向同侧端点移动指针。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度在不计算结果记录前提下为 $O(1)$。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int i = 0;
        while (i < n - 1 && nums[i + 1] <= 0) {
            i++;
        }

        int j = i + 1;
        int[] res = new int[n];
        int k = 0;
        while (i >= 0 && j < n) {
            int a = nums[i];
            int b = nums[j];
            a *= a;
            b *= b;

            if (a < b) {
                res[k++] = a;
                i--;
            } else {
                res[k++] = b;
                j++;
            }
        }

        while (i >= 0) {
            res[k++] = nums[i] * nums[i--];
        }
        while (j < n) {
            res[k++] = nums[j] * nums[j++];
        }

        return res;
    }
}
```

