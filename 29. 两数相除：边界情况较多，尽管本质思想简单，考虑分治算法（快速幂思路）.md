题目简述：

> 给你两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求 **不使用** 乘法、除法和取余运算。
>
> 整数除法应该向零截断，也就是截去（`truncate`）其小数部分。例如，`8.345` 将被截断为 `8` ，`-2.7335` 将被截断至 `-2` 。
>
> 返回被除数 `dividend` 除以除数 `divisor` 得到的 **商** 。
>
> **注意：**假设我们的环境只能存储 **32 位** 有符号整数，其数值范围是 `[−2^(31), 2^(31) − 1]` 。本题中，如果商 **严格大于** `2^(31) − 1` ，则返回 `2^(31) − 1` ；如果商 **严格小于** `-2^(31)` ，则返回 `-2^(31)` 。

题目链接：[29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)

# 思路

既然不允许使用乘、除与取余，那么最简单的方案显然就是不断循环递减除数，每减少一次记录的商加一，这也是除法运算的一种最基本定义。

但这样设计的算法时间复杂度为 $O(dividend)$，在 `-2^(31) <= dividend, divisor <= 2^(31) - 1` 的数据范围下将超时。

因此我们需要一种方案尽可能快速地找出商，借鉴快速幂的实现，我们可以考虑分治 / 减治算法。

对于 $divisor$ 我们简记为 $d$，那么

- $2d=d+d$
- $4d=2d+2d$
- $8d=4d+4d$
- ……

显然这里可以套用分治算法算出一个满足 $2^kd\leqslant dividend$ 的最小正整数 $k$，然后将 $dividend$ 减去 $2^kd$，同时临时商增加 $2^k$。对剩余的 $dividend$ 可以重复这一过程，于是我们很快就可以算出整数除法的商。

其中只需要注意这样几个关键点：

1. 最好将数字们统一转为负数（被除数、除数与临时商），避免 32 位有符号数正数最大值比负数最大值绝对值小 1 的问题；
2. 因为我们判断是否应继续递增 $k$ 实际上是通过判断是否还有 $2^{k+1}d\leqslant dividend$ 而进行的，所以我们应避免 $2^{k+1}d$ 发生溢出，对此我的解决方案是设常量 $|-2^{30}|$，然后进行两个特判：
   - 当进入子循环前发现 $|divisor|\geqslant|-2^{30}|$ 就拒绝进入尝试递增 $k$ 的子循环，因为根据 $dividend$ 的取值范围可以确定这种情况下 $k$ 必然只能为 $1$，单独处理即可；
   - 当进入子循环后一旦在 $k$ 递增后发现有 $|2^{k}d|\geqslant|-2^{30}|$ 就跳出递增 $k$ 的子循环。
3. 逻辑上不能将主循环条件视为 `while (dividend - divisor >= 0)`，应视为 `while (dividend != 0 && dividend - divisor >= 0)`，否则当 $dividend=divisor=-2^{31}$ 时将陷入死循环——具体来说，当经过第二步的特判后虽然正确更新了 $dividend=0$，但此时 $divisor$ 为 $-2^{31}$，于是 $-(-2^{31})=2^{31}>2^{31}-1$ 产生溢出，进而陷入死循环。

本问题思想上并不复杂，但由于只能使用 32 位有符号整数且不能使用乘、除与取模，实际实现时边界条件较多——主要是整数溢出的问题。

# 代码

算法的时间复杂度与空间复杂度可以认为是 $O(1)$。

```java
class Solution {

    public static final int HALF = Integer.MIN_VALUE >> 1;

    public int divide(int dividend, int divisor) {
        // if (divisor == 0) throw new ArithmeticException("/ by zero");
        // if (dividend == 0) return 0;
        boolean positive = false;
        if (dividend < 0 && divisor < 0 || dividend > 0 && divisor > 0) positive = true;

        /* 因为有符号数中最大正数绝对值比最大负数绝对值小 1，因此考虑统一转为负数 */
        if (dividend > 0) dividend = -dividend;
        if (divisor > 0) divisor = -divisor;

        /* 因为 Java 只能传值，因此将被除数、除数与商打包进同一个数组 */
        int[] arr = new int[3];
        arr[0] = dividend;
        arr[1] = divisor;
        // arr[2] = 0;

        while (arr[0] < 0 && arr[0] - arr[1] <= 0) {
            update(arr);
            /* 处理结果溢出 */
            if (positive && arr[2] == Integer.MIN_VALUE) return Integer.MAX_VALUE;
        }

        return positive ? -arr[2] : arr[2];
    }

    private void update(int[] arr) {
        if (arr[1] <= HALF) {
            arr[0] -= arr[1];
            arr[2]--;
            return;
        }

        int pow2k = 1;    // pow2k = 2^k
        int dd = arr[1];  // dd = 2^k * d
        while (arr[0] - dd - dd <= 0) {
            pow2k += pow2k;
            dd += dd;
            /* 溢出判断 */
            if (dd <= HALF) break;
        }

        arr[0] -= dd;
        arr[2] -= pow2k;
    }
}
```

