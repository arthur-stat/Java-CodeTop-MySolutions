题目简述：

> 给你一棵二叉树的根节点 `root` ，请你判断这棵树是否是一棵 **完全二叉树** 。
>
> 在一棵完全二叉树中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都尽可能靠左。最后一层（第 `h` 层）中可以包含 `1` 到 `2h` 个节点。

题目链接：[958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

# 思路

BFS 层序遍历就行，如果某一层存在空子节点，那么这一层尚未访问的节点就不能再有子节点，而且下一层的所有节点都不能有子节点。这是很自然的事。

所以先写一个 BFS 层序遍历，然后按上述条件判断即可。

# 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public boolean isCompleteTree(TreeNode root) {
        // if (root == null) return true;  // 题干向我们保证了至少有一个节点

        Deque<TreeNode> q = new ArrayDeque<>();
        q.offer(root);
        int thisLayerNum = 1;
        int nextLayerNum = 0;

        while (!q.isEmpty()) {
            TreeNode cur = q.peek();
            thisLayerNum--;

            if (cur.left != null) {
                q.offer(cur.left);
                nextLayerNum++;
            } else {
                break;
            }

            
            if (cur.right != null) {
                q.offer(cur.right);
                nextLayerNum++;
            } else {
                break;
            }

            q.poll();
            if (thisLayerNum == 0) {
                thisLayerNum = nextLayerNum;
                nextLayerNum = 0;
            }
        }

        // 当前层的所有剩余节点均应当不存在子节点
        TreeNode tmp = q.poll();
        if (tmp.left == null && tmp.right != null) return false;
        for (int i = thisLayerNum; i > 0; i--) {
            TreeNode cur = q.poll();
            if (cur.left != null || cur.right != null) return false;
        }

        // 下一层的所有节点均不应拥有子节点
        for (int i = nextLayerNum; i > 0; i--) {
            TreeNode cur = q.poll();
            if (cur.left != null || cur.right != null) return false;
        }

        return true;
    }
}
```

