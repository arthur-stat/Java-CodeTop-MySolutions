题目简述：

> 计算机安全专家正在开发一款高度安全的加密通信软件，需要在进行数据传输时对数据进行加密和解密操作。假定 `dataA` 和 `dataB` 分别为随机抽样的两次通信的数据量：
>
> - 正数为发送量
> - 负数为接受量
> - 0 为数据遗失
>
> 请不使用四则运算符的情况下实现一个函数计算两次通信的数据量之和（三种情况均需被统计），以确保在数据传输过程中的高安全性和保密性。

题目链接：[LCR 190. 加密运算](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

# 思路

题目描述说得让人只感到眼花缭乱，实际上就是不用编程语言提供的现成四则运算实现加法运算。

虽然作为非计算机专业出身的我从没学过《数字电路》课程，但在游玩《图灵完备》这款游戏时我倒是接触了硬件全加器的原理。

简单来说，对于比特 0 与比特 1 而言，异或运算等价于不带进位的加法操作——$0\oplus0=0$，$1\oplus0=1$，$0\oplus1=1$，$1\oplus1=0$。对于 $1\oplus1=0$ 而言，我们需要实现进位的逻辑，否则只能被视为半加器的模拟，不能处理来自低位的进位。

如何知道进位呢？在不考虑来自低位的进位的情况下，与运算就能够得出当前位的进位，只有 $1\wedge1=1$，其余情况结果均为 $0$。

要模拟全加器就需要考虑来自低位的进位，假设进位为 $carry$，$carry$ 要么为比特 $0$、要么为比特 $1$。显然地，就算是三个 $1$ 相加也不会导致进两次位，这是进制系统的严密数学逻辑所能保证的，所以我们依然可以通过 $bit1\oplus bit2\oplus carry$ 计算当前位的值。

那么如何计算当前位为高位传递的进位，即如何更新 $carry$ 呢？很简单，排除掉 $bit1,bit2,carry$ 全为 $0$ 或只有一个 $1$ 即可。

上述讨论假定了前提：相加的数均非负，即无符号数，但由于负数是以补码形式表示的，因此其实存在负数时依然照上述流程实现即可，不必特殊处理负数或符号位。这也是为何这样设计补码的原因，因为其能够直接复用原码的全加器实现。

# 代码

虽然对软件行业而言感觉本问题的确没有太大的意义，但是挺有趣的。

```java
class Solution {
    public int encryptionCalculate(int dataA, int dataB) {
        int res = 0;
        int carry = 0;

        for (int i = 0; i < 32; i++) {
            int bitA = dataA >>> i & 1;
            int bitB = dataB >>> i & 1;

            int bit = bitA ^ bitB ^ carry;
            carry = (bitA & bitB & carry) | (~bitA & bitB & carry) | (bitA & ~bitB & carry) | (bitA & bitB & ~carry);

            res |= bit << i;
        }

        return res;
    }
}
```