题目简述：

> 给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。
>
> **进阶：** 你可以使用一趟扫描完成反转吗？

题目链接：[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

# 代码

链表的基本功。算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$，且至多进行一次完整的遍历扫描。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 设置哨兵节点，简化边界处理
        ListNode dummy = new ListNode(0, head);

        // 首先遍历到 left 节点的前驱节点
        ListNode leftPrev = dummy;
        for (int i = 1; i < left; i++) leftPrev = leftPrev.next;

        // 部分翻转
        reversePart(leftPrev, left, right);

        return dummy.next;
    }

    public void reversePart(ListNode leftPrev, int left, int right) {
        ListNode prev = leftPrev;
        ListNode cur = leftPrev.next;

        for (int i = left; i < right; i++) {
            ListNode tmp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = tmp;
        }

        ListNode tmp = cur.next;
        cur.next = prev;
        leftPrev.next.next = tmp;
        leftPrev.next = cur;
    }
}
```