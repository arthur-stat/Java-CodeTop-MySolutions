题目简述：

> 给定一个按 **非递减顺序** 排列的数字数组 `digits` 。你可以用任意次数 `digits[i]` 来写的数字。例如，如果 `digits = ['1','3','5']`，我们可以写数字，如 `'13'`, `'551'`, 和 `'1351315'`。
>
> 返回 *可以生成的小于或等于给定整数 `n` 的正整数的个数* 。

题目链接：[902. 最大为 N 的数字组合](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/)

# 思路

典型的数位 DP 问题，这里引用我在 [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/) 题解中总结的数位 DP 模板：

> 这类问题通常都可以直接套数位 DP 的模板。
>
> 数位 DP 中公式化的状态定义通常为：`dp[pos][state][tight][lead]`，其中：
>
> - `pos`：当前处理数字的位数，通常从高位至低位遍历
>
> - `state`：需要计算的 “特征”，常见有
>
>   - 当前出现了多少次 `k`，或者附带一些限定条件，例如当前所有偶数位出现了多少次 `k`
>   - 余数为 `k`
>   - 当前位数和为 `k`
>   - 前一位数字（考虑数字连续方面的问题）
>
>   对于本问题，`state` 就是出现了多少次 `1`
>
>   要确保 `state` 的设计能够使记忆化搜索合法，四元组必须唯一确定一个结果，上述 `state` 示例均能被证明有能力确保这一点
>
> - `tight`：此前的数字构造是否达到上界，这决定了当前数码是否被允许任选
>
> - `lead`：是否位于前导零
>
> 然后，在构造数字的大框架下，用带有记忆化搜索的回溯算法计算 DP 数组。

本问题允许从 `digits` 任取数字且可以重复使用，亦无<u>相邻位关系</u>、<u>出现次数</u>、<u>模值</u>等**限制**，因此不需要设计 `state`。

# 代码

最初我写的回溯 DFS 忘记加记忆化了……导致 AC 时花了好多好多时间，再慢一点就超时。

```java
class Solution {

    private int[] N;     // 数组的每位仅存储单个数码
    private int[] path;  // 数组的每位仅存储单个数码，但本问题实际上不需要 path
    private int[] digits;
    private int[][][][] dp;

    public int atMostNGivenDigitSet(String[] digits, int n) {
        N = String.valueOf(n).chars().map(c -> c - '0').toArray();
        path = new int[N.length];
        this.digits = Arrays.stream(digits).mapToInt(Integer::parseInt).toArray();
        // Arrays.sort(this.digits);
        dp = new int[N.length][1][2][2];  // 本问题不需要设计 state
        for (int i = 0; i < N.length; i++) {
            dp[i][0][0][0] = -1;
            dp[i][0][0][1] = -1;
            dp[i][0][1][0] = -1;
            dp[i][0][1][1] = -1;
        }
        return dfs(0, 0, 1, 1);
    }

    private int dfs(int pos, int state, int tight, int lead) {
        if (pos == N.length) return (lead == 1) ? 0 : 1;
        if (dp[pos][state][tight][lead] != -1) return dp[pos][state][tight][lead];

        int res = 0;

        if (lead == 1) {
            //path[pos] = 0;
            res += dfs(pos + 1, state, 0, 1);
        }
        
        for (int i = 0; i < digits.length; i++) {
            if (tight == 1 && digits[i] > N[pos]) break;

            int newTight = (tight == 1 && digits[i] == N[pos]) ? 1 : 0;
            // path[pos] = digits[i];
            res += dfs(pos + 1, state, newTight, 0);
        }

        dp[pos][state][tight][lead] = res;
        return res;
    }
}
```

