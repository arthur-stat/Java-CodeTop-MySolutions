题目简述：

> 给定两个整数数组`a`和`b`，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差

题目链接：[面试题 16.06. 最小差](https://leetcode.cn/problems/smallest-difference-lcci/)

# 思路

众所周知，给定一个数，要寻找该数字与有序数组中各元素差的最小绝对值，只需要找到数组中最大的小于该数的元素以及最小的大于等于该数的元素，能够与给定的数做差得到最小绝对值的元素必然在二者之中，而且这两个元素在有序数组上一定是相邻的。

因此，我们可以先对 `a` 与 `b` 排序，然后分别考虑置于 `a` 与 `b` 上的双指针，寻找 `a` 排序后每个元素对应于在 `b` 排序后中相应的那两个相邻元素，并取其中最小的绝对差值。

但在实际地实现时则不需要考虑那么多情况、不必真的找出那两个相邻元素，只需要让 `b` 上的指针推进到首个大于 `a` 上的指着所指向的元素，并在推进的途中与推进以后不断更新最小绝对插值即可。这样 `a`、`b` 上的指针都是单调的，不存在指针的回退，所以当不考虑排序带来的开销时，时间复杂度严格为 $O(n)$。

# 代码

算法的时间复杂度主要来自于排序，如果考虑基于比较的排序算法则为 $O(n\log n)$，空间复杂度则取决于采用的具体排序算法。

```java
class Solution {
    public int smallestDifference(int[] a, int[] b) {
        int m = a.length;
        int n = b.length;
        Arrays.sort(a);
        Arrays.sort(b);

        int j = 0;
        long res = Math.abs((long) a[0] - b[0]);
        for (int i = 0; i < m; i++) {
            // 尝试推进至下一个大于等于 a[i] 的 b[j]
            while (j < n - 1 && b[j] < a[i]) {
                res = Math.min(res, Math.abs((long) b[j] - a[i]));
                j++;
            }
            res = Math.min(res, Math.abs((long) b[j] - a[i]));
        }

        return (int) res;
    }
}
```

