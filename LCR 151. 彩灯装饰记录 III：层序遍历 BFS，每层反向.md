题目简述：

> 一棵圣诞树记作根节点为 `root` 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照如下规则记录彩灯装饰结果：
>
> - 第一层按照从左到右的顺序记录
> - 除第一层外每一层的记录顺序均与上一层相反。即第一层为从左到右，第二层为从右到左。

题目链接：[LCR 151. 彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

# 思路

BFS 层序遍历，每层反向即可。

不过 BFS 的队列不必在遍历完一层后进行反向，这会带来额外的开销。可以利用双端队列的特性，例如 Java 的 Deque，通过控制右插入还是左插入进而根据层序控制遍历方向。

# 代码

这样可以避免每层 `reverse` 带来的开销，但逻辑相对繁复了不少。

如果接受 `reverse` 带来的额外开销，代码会简洁不少。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public List<List<Integer>> decorateRecord(TreeNode root) {
        if (root == null) return List.of();
        List<List<Integer>> res = new ArrayList<>();
        Deque<TreeNode> queue1 = new ArrayDeque<>();
        Deque<TreeNode> queue2 = new ArrayDeque<>();
        List<Integer> vals = new ArrayList<>();
        queue1.addFirst(root);
        int counter = 1;
        boolean direction = true;  // 规定为 true 时向右端插入子节点

        while (!queue1.isEmpty()) {
            if (direction) {
                TreeNode node = queue1.removeLast();
                vals.add(node.val);
                if (node.left != null) {
                    queue2.addFirst(node.left);
                }
                if (node.right != null) {
                    queue2.addFirst(node.right);
                }
            } else {
                TreeNode node = queue1.removeFirst();
                vals.add(node.val);
                if (node.right != null) {
                    queue2.addLast(node.right);
                }
                if (node.left != null) {
                    queue2.addLast(node.left);
                }
            }

            counter--;
            if (counter == 0) {
                res.add(new ArrayList<>(vals));
                vals.clear();
                Deque<TreeNode> tmp = queue1;
                queue1 = queue2;
                queue2 = tmp;
                queue2.clear();
                counter = queue1.size();
                direction = !direction;
            }
        }

        return res;
    }
}
```

