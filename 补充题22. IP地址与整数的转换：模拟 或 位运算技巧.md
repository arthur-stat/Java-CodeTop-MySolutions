题目简述：

> 原理：ip地址的每段可以看成是一个0-255的整数，把每段拆分成一个二进制形式组合起来，然后把这个二进制数转变成
>  一个长整数。
> 举例：一个ip地址为10.0.3.193
> 每段数字       相对应的二进制数
> 10          00001010
> 0          00000000
> 3          00000011
> 193         11000001 
>
> 组合起来即为：00001010 00000000 00000011 11000001,转换为10进制数就是：167773121，即该IP地址转换后的数字就是它了。 
>
> 数据范围：保证输入的是合法的 IP 序列

题目链接：[整数与IP地址间的转换](https://www.nowcoder.com/questionTerminal/66ca0e28f90c42a196afd78cc9c496ea)

# 模拟

## 思路

可以直接模拟，即按问题描述那样先将点分十进制 IP 字符串或十进制数转为中间二进制表示，再进而转为对应的十进制数或点分十进制 IP 字符串。

这样的思路是最简单、直接、暴力的，而且也是可行的。Java 记得用 `long` 避免溢出，C++ 可以使用 32 位无符号整数。

## 代码

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {

    private static final long[] POW2 = {
        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,
        65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216,
        33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648L
    };

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNext()) { // 注意 while 处理多个 case
            String ip = in.nextLine();
            if (!in.hasNextLong()) break;
            long number = in.nextLong();

            System.out.println(parseStr(ip));
            System.out.println(parseInt(number));
        }
    }

    private static long parseStr(String ip) {
        String[] ips = ip.split("\\.");
        String[] binary = new String[4];
        for (int i = 0; i < 4; i++) {
            binary[i] = Long.toBinaryString(Long.valueOf(ips[i]));
        }

        long res = 0;
        int bit = 0;
        for (int i = 3; i >= 0; i--) {
            int j;
            for (j = binary[i].length() - 1; j >= 0; j--) {
                res += (binary[i].charAt(j) - '0') * POW2[bit++];
            }
            bit = (4 - i) * 8;
        }
        return res;
    }

    private static String parseInt(long number) {
        char[] bits = new char[32];
        for (int i = 31; i >= 0; i--) {
            if (number >= POW2[i]) {
                number -= POW2[i];
                bits[i] = '1';
            } else {
                bits[i] = '0';
            }
        }

        String[] binary = new String[4];
        for (int i = 3; i >= 0; i--) {
            StringBuilder sb = new StringBuilder();
            for (int j = 7; j >= 0; j--) {
                sb.append(bits[8 * i + j]);
            }
            binary[3 - i] = sb.toString();
        }
        
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < 4; i++) {
            res.append(Integer.parseInt(binary[i], 2));
            res.append('.');
        }
        res.setLength(res.length() - 1);

        return res.toString();
    }
}
```

# 位运算

## 思路

请参考 [IP地址与int整数的转换](https://mp.weixin.qq.com/s/UWCuEtNS2kuAuDY-eIbghg)

## 代码

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNext()) { // 注意 while 处理多个 case
            while (in.hasNext()) {
                String ip = in.next();
                if (!in.hasNextLong()) break;
                long num = in.nextLong();

                System.out.println(ipToUInt32(ip));
                System.out.println(uInt32ToIp(num));
            }
        }
    }

    static long ipToUInt32(String ip) {
        String[] p = ip.split("\\.");
        long a = Integer.parseInt(p[0]);
        long b = Integer.parseInt(p[1]);
        long c = Integer.parseInt(p[2]);
        long d = Integer.parseInt(p[3]);
        return (a << 24) | (b << 16) | (c << 8) | d;
    }

    static String uInt32ToIp(long x) {
        long a = (x >>> 24) & 0xFF;
        long b = (x >>> 16) & 0xFF;
        long c = (x >>> 8)  & 0xFF;
        long d =  x         & 0xFF;
        return a + "." + b + "." + c + "." + d;
    }
}
```

