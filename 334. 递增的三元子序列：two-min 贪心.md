题目简述：

> 给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。
>
> 如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。

题目链接：[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

# two-min 贪心

## 动态规划？

这个问题如果视为 LIS（[300. 递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)（的长度或个数））问题的子问题，那么时间复杂度会很高，在给定的数据范围 `1 <= nums.length <= 5 * 10^5` 下 $O(n^2)$ 的实现必然超时，$O(n\log n)$ 的实现则可以通过测试，但我觉得思路上没有下面的方案直接。

最优的方案是这里的所谓 two-min 贪心。

## 贪心思路

这个算法实现是我想出来的，似乎并不是标准的所谓 two-min 贪心的实现，主要区别在于我额外使用一个变量 `prev` 表示历史信息，更常见的 two-min 贪心实现似乎不会这样额外处理。

我的想法是：使用两个数 `a, b` 维护当前已知的 `b` 值最小的递增子序列，当扫描到一个新的元素 `num`，

- 若 `num > b`，则找到了一个递增三元子序列 `[a, b, num]`，于是返回 `true`

- 若 `num > a` 且 `num < b`，则 `num` 比 `b` 更可能成为未来某个递增三元子序列中的一员，于是让 `num` 替代 `b`；

- 若 `num < a`，需要考虑让 `num` 替换 `a`，但这里使用 `prev` 保存当前的下界，因为：

  1. 对于已存在的 `[a, b]`，只要未来某个元素 `future` 大于 `b`，那么 `[a, b, future]` 就能组成递增三元子序列；

  2. 对于 `num`，由于 `num < a`，未来完全可能存在两个不等的元素 `c, d` 均大于 `num` 使得 `[num, c, d]`  能够组成递增三元子序列，但 `c, d` 中任何一员都可以小于等于 `b`，使得 `[a, b]` 无法与 `c, d` 组成递增三元子序列。

  其中，第二种情况对应令 `num` 替代 `a`，但我们不能忽略第一种情况，因此我的想法是用一个变量 `prev` 保存当前递增二元子序列第三个值的下界，即令 `prev = b`。这样，每次在判断 `num > b` 时，同时判断是否有 `num > prev`，只要任何一方成立，那么就意味着我们找到了一个递增的三元子序列，因此可以返回 `true`。

## 与 LIS 动态规划的联系？

其实上述贪心思路本质上就是 LIS（[300. 递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)）的 $O(n\log n)$ 实现针对长度 $3$ 的特化。在 LIS 的 $O(n\log n)$ 实现中，$O(\log n)$ 的时间复杂度来自于二分查找寻找长度最大的结尾小于当前元素的递增子序列。在本问题中，由于要寻找的只是递增三元子序列，因此二分查找的实现中实际上只需要保存两个递增子序列：长度为 1 的递增子序列，以及长度为 2 的递增子序列。显然，该情况下不必再二分查找，可以直接比对。因此这部分时间开销为 $O(1)$，最后算法在该问题下总的时间开销也为 $O(n)$。

上述贪心思路其实就是做了这样的直接比对：

1. 第一种情况对应长度为 2 的递增子序列；
2. 第二种情况对应长度为 1 的递增子序列。

所以，完全可以先实现时间复杂度 $O(n\log n)$ 的 LIS 算法，然后将算法应用至本问题，当找到长度为 3 的递增子序列时直接返回 `true`，否则整趟遍历完也不会找到长度大于等于 3 的递增子序列，最终返回 `false` 时，每次二分查找的时间开销也为 $O(1)$。

## 我的实现

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int a = Integer.MAX_VALUE;
        int b = Integer.MAX_VALUE;
        int prev = Integer.MAX_VALUE;

        for (int num : nums) {
            if (num > b || num > prev) return true;

            if (num < a) {
                prev = Math.min(prev, b);
                a = num;
                b = Integer.MAX_VALUE;
                
            } else if (num > a && num < b) {
                b = num;
            }
        }

        return false;
    }
}
```

## 标准 two-min 贪心实现

这个实现是 GPT 5 - thinking 给出的。与我们的方案没有任何本质区别。

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int first = Integer.MAX_VALUE;
        int second = Integer.MAX_VALUE;
        for (int x : nums) {
            if (x <= first) first = x;
            else if (x <= second) second = x;
            else return true;
        }
        return false;
    }
}
```
