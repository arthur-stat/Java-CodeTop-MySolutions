题目简述：

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> 请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
>
> **示例 1：**
>
> - 输入：nums = [100,4,200,1,3,2]
> - 输出：4
> - 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

题目链接：[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

# 前言

本问题的算法要实现 $O(N)$ 的时间复杂度，基本上都需要使用哈希表或并查集。

# 哈希表

先使用哈希表实现去重，然后遍历不重复元素。假设遍历到了 $n$，如果 $n$ 已被访问（哈希表的值不为 $0$）或 $n+1$ 不在哈希表中则跳过，否则说明 $n$ 是一段未访问过的连续序列的终末元素，那么就从 $n$ 开始向前寻找这一段连续序列，不断自减 `--n` 并更新哈希表中相应键的值为逆序长度，直到找到该连续序列的起始（即再自减一次就不在哈希表中了），更新最长连续序列记录 `maxLen`。

本方案保证每个元素只被访问一次，因此算法的时间复杂度为 $O(N)$，空间复杂度为 $O(N)$。

```java
class Solution {
    public int longestConsecutive(int[] nums) {

        HashMap<Integer, Integer> map = new HashMap<>();
        List<Integer> list = new ArrayList<>();

        for (int num : nums) {
            if (!map.containsKey(num)) {
                map.put(num, 0);
                list.add(num);
            }
        }

        int maxLen = 0;

        while (!list.isEmpty()) {
            int n = list.removeLast();
            if (map.get(n) == 0) {
                if (map.containsKey(n + 1)) continue;
                map.put(n, 1);
                int len = 1;
                while (map.containsKey(--n)) {
                    map.put(n, ++len);
                }
                maxLen = Math.max(maxLen, len);
            }
        }

        return maxLen;
    }
}
```

如果只需要最长连续序列的长度而不需要所有的具体连续序列，则可以将 HashMap 改为 HashSet 并将向前查找逆序长度改为向后查找正序长度，即访问到 $n$ 时如果 $n-1$ 在哈希表中则跳过，否则说明 $n$ 是一段未访问过的连续序列的起始元素，自增 `++n` 并删掉哈希表中已访问的 $n$ 以保证不重复访问。

这种方案和第一个方案没有本质区别，时间复杂度也为 $O(N)$。

```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> set = new HashSet<>();

        for (int num : nums) set.add(num);

        int maxLen = 0;

        for (int n : nums) {
            if (set.contains(n - 1)) continue;

            int len = 1;
            while (set.contains(++n)) {
                set.remove(n - 1);
                len++;
            }
            
            maxLen = Math.max(maxLen, len);
        }

        return maxLen;
    }
}
```

# 并查集

本问题也显然是非常适合并查集的问题，因为既不要求序列既不要各元素在原数组中连续，又不要求保持各元素在原数组中的相对位置，天然符合「集合」的特性。

我们首先进行一次遍历，将所有值都加入到并查集中，每个值初始化对应自身的集合。然后再进行第二次遍历，检查 `num` 相邻的两个值 `num - 1` 与 `num + 1` 是否存在于并查集中，如果存在则合并两个值对应的集合。最终，最大的集合即为最长连续序列内的元素。

该流程可以优化，具体来说对于 `num` 我们保持只检查并合并 `num + 1` 或 `num - 1` 中固定的一个，因为并查集作为逻辑上的集合数据结构是不存在方向的，`a` 合并到 `b` 与 `b` 合并到 `a` 没有本质上的区别（只是为了避免退化到链表导致 `find` 效率大大降低才优先让秩更小的集合合并到秩更大的集合上），同时检查并合并 `num + 1` 与 `num - 1` 当然也是没问题的，但这样做只会徒增无效的计算开销。

算法的时间复杂度为 $O(N)$，空间复杂度为 $O(N)$，但常数因子较第一种方案更大，因为进行了多轮遍历。

```java
class Solution {

    private static class UnionFind {

        private Map<Integer, Integer> parent;
        private Map<Integer, Integer> rank;
        private Map<Integer, Integer> size;
        private int maxSize;

        public UnionFind() {
            parent = new HashMap<>();
            rank = new HashMap<>();
            size = new HashMap<>();
            maxSize = 0;
        }

        // 初始化时，让每个节点「各自为政」，每个值对应一个集合
        public void add(int val) {
            if (!parent.containsKey(val)) {
                parent.put(val, val);
                rank.put(val, 0);
                size.put(val, 1);
                maxSize = 1;
            }
        }

        // 递归地查找根节点（路径压缩）
        public int find(int val) {
            // 如果非根节点
            if (parent.get(val) != val) {
                parent.put(val, find(parent.get(val)));
            }
            return parent.get(val);
        }

        // 按秩合并两个根节点
        public void union(int a, int b) {
            if (!parent.containsKey(a) || !parent.containsKey(b)) return;
            int rootA = find(a);
            int rootB = find(b);
            if (rootA == rootB) return;

            int rankA = rank.get(rootA);
            int rankB = rank.get(rootB);
            if (rankA < rankB) {
                parent.put(rootA, rootB);
                maxSize = Math.max(size.merge(rootB, size.get(rootA), Integer::sum), maxSize);
            } else if (rankA > rankB) {
                parent.put(rootB, rootA);
                maxSize = Math.max(size.merge(rootA, size.get(rootB), Integer::sum), maxSize);
            } else {
                parent.put(rootA, rootB);
                rank.merge(rootB, 1, Integer::sum);
                maxSize = Math.max(size.merge(rootB, size.get(rootA), Integer::sum), maxSize);
            }
        }

        public int getMaxSize() {
            return maxSize;
        }
    }

    public int longestConsecutive(int[] nums) {
        UnionFind unionFind = new UnionFind();
        for (int num : nums) unionFind.add(num);

        for (int num : nums) {
            // unionFind.union(num - 1, num);  // 只合并 num + 1 就行
            unionFind.union(num + 1, num);
        }

        return unionFind.getMaxSize();
    }
}
```
