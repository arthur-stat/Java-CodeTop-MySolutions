题目简述：

> 给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> - `0 <= a, b, c, d < n`
> - `a`、`b`、`c` 和 `d` **互不相同**
> - `nums[a] + nums[b] + nums[c] + nums[d] == target`
>
> 你可以按 **任意顺序** 返回答案 。

题目链接：[18. 四数之和](https://leetcode.cn/problems/4sum/)

# 双指针基本思路

如果不要求去重，那么本问题的最优解是比较好写的双指针算法。首先对数组排序，考虑四个指针 `low`、`left`、`right` 与 `high`，规定 `low < left < right < high`，然后在最外层用一个 for 循环遍历 `low`，中层再用一个 for 循环遍历 `left`，这样如果只考虑 `left`、`right` 与 `high` 问题就变为了三数之和。

例如，可以这样设计算法：

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        // low < left < right < high
        for (int low = 0; low < n - 3; low++) {
            for (int left = low + 1; left < n - 2; left++) {
                int right = left + 1;
                int high = n - 1;

                while (right < high) {
                    int sum = nums[low] + nums[left] + nums[right] + nums[high];

                    if (sum < target) {
                        right++;
                    } else if (sum > target) {
                        high--;
                    } else {
                        res.add(List.of(nums[low], nums[left], nums[right], nums[high]));
                        right++;
                        high--;
                    }
                }
            }
        }

        return res;
    }
}
```

如果允许使用集合去重，由于排序后数据是有序的，可以直接按字面量去重。

若希望在搜索时就做到不计重复解，那么就需要做一些额外的工作了。

# 计数去重思路

对于四元组 `(low, left, right, high)`，由于存在线性约束对应值的和为 `target`，因此只要保证其中三个索引对应的值不重复，就可以保证四元组不重复。

容易知道，`low` 只要跳过重复值就可以避免一部分重复计数，即 `low` 的 for 循环跳过重复值即可避免部分重复计数，这是因为 `low` 如果将访问的下一个值与当前值相同，那么下一个值作为 `low` 的值所有可能的组合已经在当前 `low` 值中被考虑到了——目前的算法中 `left` 终究会自 `low + 1` 开始遍历所有的可能。所以添加逻辑 `if (low > 0 && nums[low - 1] == nums[low]) continue;`。

但仅仅对 `low` 的 for 循环做跳过处理是不足够的，因为即使我们保证 `low` 的 for 循环不重复，`(left, right, high)` 也可能重复，例如 `nums` 为 `[2, 2, 2, 2, 2]` 时。按我们目前算法的逻辑，即使固定 `low = 0`，也无法完全避免重复计数。

由于 `low` 重复值产生的重复计数我们已经处理了，现在我们把注意力移至 `left` 上。实际上 `left` 和 `low` 在 “地位” 上是几乎相同的，他们均作为外层 for 循环遍历的指针，区别于内层循环手动维护的 `right` 以及 `high`。因此针对 `left` 也应用 `if (left > low + 1 && nums[left - 1] == nums[left]) continue;` 的逻辑即可。

现在我们讨论最内层的 `right` 和 `high` 如何去重。显然地——四个指针中已经有两个确保了不重复，那么剩下的 `right` 与 `high` 我们任选其一避开重复值即可。

根据我们的去重思路，更新算法：

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        // low < left < right < high
        for (int low = 0; low < n - 3; low++) {

            if (low > 0 && nums[low - 1] == nums[low]) continue;
            
            for (int left = low + 1; left < n - 2; left++) {

                if (left > low + 1 && nums[left - 1] == nums[left]) continue;

                int right = left + 1;
                int high = n - 1;

                while (right < high) {
                    int sum = nums[low] + nums[left] + nums[right] + nums[high];

                    if (sum < target) {
                        right++;
                    } else if (sum > target) {
                        high--;
                    } else {
                        res.add(List.of(nums[low], nums[left], nums[right], nums[high]));
                        do {
                            right++;
                        } while (right < n && nums[right - 1] == nums[right]);
                        do {
                            high--;
                        } while (high >= 0 && nums[high + 1] == nums[high]);
                    }
                }
            }
        }

        return res;
    }
}
```

算法的时间复杂度为 $O(n^3)$，空间复杂度为 $O(\log n)$，空间开销主要来自于排序的递归栈。如果不考虑递归栈和返回结果占用的空间，那么空间复杂度为 $O(1)$。

# 最终算法实现

理论上上述算法已经能正常工作了，但力扣上的测试用例有一个很蠢的输入是 `nums` 为 `[1000000000,1000000000,1000000000,1000000000]`、`target` 为 `-294967296`……这种测试用例意义何在呢？

为在力扣上 AC，需要用 `long` 存储 `sum`。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        // low < left < right < high
        for (int low = 0; low < n - 3; low++) {

            if (low > 0 && nums[low - 1] == nums[low]) continue;
            
            for (int left = low + 1; left < n - 2; left++) {

                if (left > low + 1 && nums[left - 1] == nums[left]) continue;

                int right = left + 1;
                int high = n - 1;

                while (right < high) {
                    long sum = (long) nums[low] + nums[left] + nums[right] + nums[high];

                    if (sum < target) {
                        right++;
                    } else if (sum > target) {
                        high--;
                    } else {
                        res.add(List.of(nums[low], nums[left], nums[right], nums[high]));
                        do {
                            right++;
                        } while (right < n && nums[right - 1] == nums[right]);
                        do {
                            high--;
                        } while (high >= 0 && nums[high + 1] == nums[high]);
                    }
                }
            }
        }

        return res;
    }
}
```

# 继续优化

目前算法 AC 时花费 16ms，我们可以进一步优化，使算法 AC 时仅花费 2ms。理论最坏时间复杂度是无法再优化的，但合理剪枝仍可在大多数情况下大大减少算法的执行耗时。

关键在于：

- `if ((long)nums[low] + nums[low+1] + nums[low+2] + nums[low+3] > target) break;`
- `if ((long)nums[low] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue;`
- `if ((long)nums[low] + nums[left] + nums[left+1] + nums[left+2] > target) break;`
- `if ((long)nums[low] + nums[left] + nums[n-2] + nums[n-1] < target) continue;`

将这四条剪枝优化语句添加到我们此前的算法实现中：

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        for (int low = 0; low < n - 3; low++) {
            if (low > 0 && nums[low - 1] == nums[low]) continue;

            if ((long)nums[low] + nums[low+1] + nums[low+2] + nums[low+3] > target) break;
            if ((long)nums[low] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue;

            for (int left = low + 1; left < n - 2; left++) {
                if (left > low + 1 && nums[left - 1] == nums[left]) continue;

                if ((long)nums[low] + nums[left] + nums[left+1] + nums[left+2] > target) break;
                if ((long)nums[low] + nums[left] + nums[n-2] + nums[n-1] < target) continue;

                int right = left + 1;
                int high = n - 1;

                while (right < high) {
                    long sum = (long) nums[low] + nums[left] + nums[right] + nums[high];

                    if (sum < target) {
                        right++;
                    } else if (sum > target) {
                        high--;
                    } else {
                        res.add(List.of(nums[low], nums[left], nums[right], nums[high]));
                        do {
                            right++;
                        } while (right < n && nums[right - 1] == nums[right]);
                        do {
                            high--;
                        } while (high >= 0 && nums[high + 1] == nums[high]);
                    }
                }
            }
        }

        return res;
    }
}
```

算法就只花费 2ms 便能 AC！效率提升整整八倍。