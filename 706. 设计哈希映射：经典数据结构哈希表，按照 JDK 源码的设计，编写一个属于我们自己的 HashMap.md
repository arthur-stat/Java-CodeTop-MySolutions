题目简述：

> 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。
>
> 实现 `MyHashMap` 类：
>
> - `MyHashMap()` 用空映射初始化对象
> - `void put(int key, int value)` 向 HashMap 插入一个键值对 `(key, value)` 。如果 `key` 已经存在于映射中，则更新其对应的值 `value` 。
> - `int get(int key)` 返回特定的 `key` 所映射的 `value` ；如果映射中不包含 `key` 的映射，返回 `-1` 。
> - `void remove(key)` 如果映射中存在 `key` 的映射，则移除 `key` 和它所对应的 `value` 。

题目链接：[706. 设计哈希映射](https://leetcode.cn/problems/design-hashmap/)

# HashMap

## 思路

类似 JDK 提供的 HashMap 实现，只不过不考虑树化（红黑树），这样实现上能简化不少。

核心结构为：

- 单向链表节点对象 `Node<K, V>`，存储 `hash`、`key`、`value` 以及 `next`；
- 存储各单向节点头节点的数组，称为 bucket；
- 负载因子 loadFactor，当 `size > threshold` 时扩容一倍，其中阈值 `threshold = capacity * loadFactor`。

具体实现为：

- 计算哈希值时最好对 `key.hashCode()` 做扰动以利用上高位信息，例如 `h ^ (h >>> 16)`；

- 对于扰动后的哈希值 `h`，通过 `(capacity - 1) & h` 计算 key 在 bucket 内的索引 `index`；

  <u>这一点严格依赖于容量为 2 的幂，否则应改为取模运算。</u>

- 如果发生哈希碰撞，则将新节点添加至链表尾部；

- 当需要扩容时，对于原来数组中各个链表上的节点，通过判断 `h & oldCapacity` 只可能有两种情况：
  - `h & oldCapacity == 0`，则留在原链表中（`index`）；
  - `h & oldCapacity != 0`，则迁移至 `index + oldCapacity`。
  
  判断 `h & oldCapacity` 的原因是当容量为 2 的幂时翻倍后 `capacity` 将会多出一个二进制位参与位运算且 `capacity` 只有一个比特位为 `1`，因此旧 `capacity` 恰好是一个掩码。
  
  我们可以对原每条链表一次遍历找出两条子链（根据是否有 `h & oldCapacity == 0`），再一次拼接至新 bucket。
  
  <u>这一点严格也依赖于扩容时容量翻倍且新容量保持为 2 的幂。</u>

这是一个不保证线程安全、未实现树化的经典实现，支持自动扩容。JDK 的 HashMap 会在 `size > 64` 时考虑红黑树化。

## 代码

如果不考虑自动扩容，代码总体上还是很简洁的。

其中扩容的 `lo` 与 `hi` 的设计值得一提，JDK 也是这样做的。

```java
class MyHashMap {

    private Node[] bucket;
    private int size;
    private int capacity;
    private double loadFactor;

    public MyHashMap() {
        bucket = new Node[16];
        size = 0;
        capacity = 16;
        loadFactor = 0.75;
    }
    
    public void put(int key, int value) {
        Node head = bucket[index(key)];
        if (head == null) {
            bucket[index(key)] = new Node(key, value, int32minxing(key), null);
            size++;
            tryExpand();
            return;
        }
        if (head.key == key) {
            head.value = value;
            return;
        }

        while (head.next != null && head.next.key != key) {
            head = head.next;
        }

        if (head.next != null && head.next.key == key) {
            head.next.value = value;
            return;
        }

        head.next = new Node(key, value, int32minxing(key), null);
        size++;
        tryExpand();
    }
    
    public int get(int key) {
        Node head = bucket[index(key)];
        while (head != null && head.key != key) {
            head = head.next;
        }
        return head == null ? -1 : head.value;
    }
    
    public void remove(int key) {
        Node head = bucket[index(key)];
        if (head == null) return;
        if (head.key == key) {
            bucket[index(key)] = head.next;
            size--;
            return;
        }

        while (head.next != null && head.next.key != key) {
            head = head.next;
        }
        if (head.next == null || head.next.key != key) return;

        head.next = head.next.next;
        size--;
    }

    // 如果支持泛型对象，方法内应改 key 为 key.hashCode()
    private int index(int key) {
        return (capacity - 1) & int32minxing(key);
    }

    // 32 位整数的哈希扰动
    private int int32minxing(int num) {
        return num ^ (num >>> 16);
    }

    private void expand() {
        Node[] tmp = bucket;
        bucket = new Node[capacity * 2];
        Node loHead = new Node(0, 0, 0, null);
        Node hiHead = new Node(0, 0, 0, null);
        Node lo = loHead;
        Node hi = hiHead;
        
        for (int i = 0; i < capacity; i++) {
            Node head = tmp[i];
            while (head != null) {
                if ((head.hash & capacity) == 0) {
                    lo.next = head;
                    lo = head;
                } else {
                    hi.next = head;
                    hi = head;
                }
                head = head.next;
            }

            lo.next = null;
            hi.next = null;
            bucket[i] = loHead.next;
            bucket[i + capacity] = hiHead.next;
            loHead.next = null;
            hiHead.next = null;
            lo = loHead;
            hi = hiHead;
        }

        capacity *= 2;
    }

    private void tryExpand() {
        if (size > capacity * loadFactor) expand();
    }

    private static final class Node {
         
        final int hash;
        final int key;
        int value;
        Node next;

        public Node(int key, int value, int hash, Node next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
}

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */
```

# 布隆过滤器 HashMap

JDK 提供的 HashMap 并不包含布隆过滤器，但我们可以为我们的 HashMap 添加布隆过滤器。

关于布隆过滤器是什么，请参考 [一文讲透“布隆过滤器”](https://cloud.tencent.com/developer/article/1688747)。
