题目简述：

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
>
> **注意：**答案中不可以包含重复的三元组。

题目连接：[15. 三数之和](https://leetcode.cn/problems/3sum/)

# 1题、哈希表两数之和

我们先来看看两数之和：

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。

我们当然可以直接遍历扫描一下，这个办法是个人都想得到：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length - 1;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n + 1; j++) {
                if (nums[i] + nums[j] == target) return new int[] {i, j};
            }
        }
        return new int[]{nums[n], nums[n]};
    }
}
```

但这样子时间复杂度有点高，嵌套了循环，时间复杂度是 $O(n^2)$，我们可以利用哈希表空间高效率地换时间。

具体来说，因为target是确定的，那么在我们刚才的嵌套双层循环中，已知nums[i]时其实只需要判断target-nums[i]在不在集合中就行——因此，可以把整个nums元素的字面量作为哈希表的key，把元素的索引作为value，重复字面量的索引只计一次，然后我们直接把target-nums[i]当成key去查哈希表就行了，如果target-nums[i]不在那说明能和nums[i]凑成两数之和为target的数不在nums里。这样，我们就只需要一个迭代i的单层for循环即可。

但光是这样子还不行，因为每个元素不能用两次，比如 ` [3, 4, 2]`、target取6，那么按我们刚才的逻辑会认为3+3=6，3在一个和中被用了两次。咋去重呢？很简单，我们在通过i扫描nums时每次把i前面的元素纳入哈希表中（而不是一开始就把numns全部的元素纳入哈希表中），这样就可以避免这个问题了。至于索引到底取哪次的，无关紧要，反正不会重复就是了——何况题目后面还说了可以认为每个输入对应的索引对答案唯一。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 1; i < nums.length; i++) {
            map.put(nums[i-1], i-1);
            if (map.containsKey(target - nums[i])) return new int[]{map.get(target - nums[i]), i};
        }
        return new int[0];
    }
}
```

如果不考虑哈希冲突，这个算法的时间复杂度是 $O(n)$，不可能再低了，毕竟我们至少要遍历一次才能拿到数组的全部信息。

# 15题、类似两数之和做法解三数之和以及去重踩坑

根据两数之和的经验，如果我们直接三层for循环嵌套扫描时间复杂度 $O(n^3)$ 太高了，因此我们可以用哈希表以空间换时间。参照两数之和的方法，我们可以先定义两层for循环，分别对应指针i和j，每次扫描时把上一个元素纳入哈希表（注意j>i，因此把nums[i-1]纳入哈希表就一定不会重复取数），然后把-nums[i]-nums[j]作为key去查哈希表。

但是我们要特别注意题干的这句话：

> 答案中不可以包含重复的三元组。

这很坑，没这个要求其实代码几行就可以写完。例如 `[0, -1, 1, 0, 1]` ，那很显然我取第1、2、3索引的数 `[0, -1, 1]` 或者第2、3、4索引的数 `[-1, 1, 0]` 都符合和为0的要求——但是“不可以包含重复的三元组”，我们不能把他俩都放到结果数组中，因为这俩二级数组被认为是（字面量）重复的。所以我们必须想办法去重。

我的方案是对每个符合和为0、未重复取数的三元数组先排个序，这样他们字面量就唯一了，但我们接下来不能简单地把其中某一个数——比如第一位数放到HashSet中判断是否重复，这样的话就会错误地把 `[-4, 2, 2]` 和 `[-4, 1, 3]` 当作重复的三元数组。我采取的办法是把他们变成字符串，因为之前排过序了，所以字面量重复的三元数组的大小顺序是确定的，那把他们以“,”分隔转为字符串、再把字符串作为HashSet的key就能确保检查出字面量重复的三元数组了。

代码中check就是用来存字符串并检查重复三元数组的。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        ArrayList<List<Integer>> res = new ArrayList<>();
        HashSet<String> check = new HashSet<>();


        for (int i = 1; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                set.add(nums[i - 1]);
                if (set.contains(-nums[i]-nums[j])) {
                    int[] abc = {nums[i], nums[j], -nums[i]-nums[j]};
                    Arrays.sort(abc);
                    String checkStr = String.format("(%d,%d)", abc[0], abc[1]);
                    if (!check.contains(checkStr)) {
                        res.add(new ArrayList<>(Arrays.asList(abc[0], abc[1], abc[2])));
                        check.add(checkStr);
                    }
                }
            }
        }

        return res;
    }
}
```

如果说两数之和中target确定，所以其中一个数确定那另一个满足条件数的字面量就被唯一确定，那么在三数之和中由于要求三者和为0，如果其中两个数确定就能唯一确定第三个满足条件数的字面量，说这是双指针也行。这个算法时间复杂度是 $O(n^2)$，时间复杂度看起来还行但实际上运行要花超多的时间，我跑了三次，有两次都超时，一次通过但险些超时（1586ms）。因此我们这个算法还不行，有待改进。

# 三数之和优化，排序+正经双指针，其实用了三个指针

实际上我们可以先排个序，排序的时间复杂度是 $O(n\log n)$，和 $O(n^2)$ 相比 $O(n\log n)$ 显得就有点微不足道了，但其实排序后的数组能够帮助我们减少很多计算量，所以排序是非常值得且划算的。

具体来说，我们首先对数组排序，然后定义一个首指针i和一个尾指针j，他俩一开始分别指向在首部和尾部，再定义一个循环中递增的指针k，k初始时为i+1，其值会随i的更新而更新。精髓就在这了：这三个指针是位于一个有序数组上的。那么让i和j逐渐往中间“缩”，k遍历二者之间的数，就可以了。至于sum>0、=0、<0分别如何移动i、j、k，是不难思考的，talk is cheap，看代码就行。

这个解法巧妙在利用了有序，直接同时实现了去重（其实是完全避免了重复）和减枝，没有用到哈希表（考虑到哈希冲突代价其实不小）。排序的时间开销相比于 $O(n^2)$ 微乎其微，但却能为我们节省海量的计算。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // 排序是关键
        List<List<Integer>> res = new ArrayList<>();
        
        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 跳过重复的a
            if (nums[i] > 0) break; // 剪枝优化
            
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    // 跳过重复的b和c
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return res;
    }
}
```

新代码通过测试只需要30ms。