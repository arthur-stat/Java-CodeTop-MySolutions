题目简述：

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回 *滑动窗口中的最大值* 。

题目链接：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

# 思路

这是一道非常典型的数据结构题，是单调队列的模板题。

每种数据结构都有其一些典型的用途。例如，单调栈适合解决下一个更大 / 更小元素（及举例）的问题，优先队列适合应对需要堆排序的场景（譬如动态中位数），那么单调队列则非常适合解决本问题，是本问题的最优解。因此，本问题——滑动窗口的最大值，即动态维护区间最值，可谓是单调队列这一数据结构的模板题目。

---

类似单调栈，单调队列保证队列内的元素是单调的。这就保证了单调队列能直接找出区间内的最值。

单调队列动态维护区间最值还有两个关键点：**存储索引**以及**丢弃过期元素**。其中，存储索引而非值就是为了便于判断元素是否已超出当前窗口，因此重点是丢弃过期元素的逻辑。

假设滑动窗口的区间宽度为 $k$，那么当新元素入队时，首先要维护单调性：从队尾开始，将比它 “更不优” 的元素（例如在最大值队列中比它小的元素，在最小值队列中比它大的元素）依次弹出，再把新元素入队。接着，还需要判断队首元素是否过期：如果队首的索引小于窗口左边界 $i-k+1$，就将其出队。这样就能保证队列中所有元素都在滑动窗口内。

考虑到每次只会有一个新元素入队，而出队数量不确定，因此出队分为两类：

- **（按值）维护单调性时**：可能弹出多个队尾元素；
- **（按索引）检查过期时**：只需要检查并弹出队首（因为过期元素一定在队首），**弹出的顺序与维护单调性时相反**。

经过这两步处理，队列中剩下的元素既保证了单调性，也保证了索引合法性，因此队首就能正确反映当前滑动窗口内的最大值或最小值。

---

注意单调队列的单调方向，这取决于我们需要动态维护区间最大值还是动态维护区间最小值。

单调队列的实现依赖于双端队列，例如 Java 中的 `Deque`。这与单调栈不一样，单调栈只需要基于普通栈对 `pop()` 补充维护单调的逻辑即可。也正因为基于双端队列实现，所以无论是动态维护区间最大值还是最小值，让队列内是单调递增或是单调递减均是可以的，这无关紧要，关键在于入队和出队的具体逻辑。

# 代码

算法的时间复杂度摊还 $O(1)$，空间复杂度为 $O(k)$。

```java
class MonoQueue {

    private Deque<Integer> q;
    private int[] nums;
    private int k;
    private int count;  // 下一个入队元素的索引

    public MonoQueue(int[] nums, int k) {
        this.nums = nums;
        this.k = k;
        q = new ArrayDeque<>(k + 1);
        init();
        count = k - 1;
    }

    public int offerAndGetMax() {
        offer(count++);
        check();
        return nums[q.peekLast()];
    }

    public int getCount() {
        return count;
    }

    private void offer(int index) {
        while (!q.isEmpty() && nums[index] > nums[q.peekFirst()]) {
            q.removeFirst();
        }

        q.addFirst(index);
    }

    private void check() {
        if (count - q.peekLast() - 1 == k) {
            q.removeLast();
        }
    }

    private void init() {
        for (int i = 0; i < k - 1; i++) {
            offer(i);
        }
    }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length - k + 1;
        int[] res = new int[len];
        MonoQueue monoQueue = new MonoQueue(nums, k);

        for (int i = 0; i < len; i++) {
            res[i] = monoQueue.offerAndGetMax();
        }

        return res;
    }
}
```

