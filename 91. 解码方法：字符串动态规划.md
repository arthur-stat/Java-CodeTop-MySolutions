题目简述：

> 一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：
>
> `"1" -> 'A'`
>
> ` "2" -> 'B'`
>
> `...`
>
> `"25" -> 'Y'`
>
> `"26" -> 'Z'`
>
> 然而，在 **解码** 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（`"2"` 和 `"5"` 与 `"25"`）。
>
> 例如，`"11106"` 可以映射为：
>
> - `"AAJF"` ，将消息分组为 `(1, 1, 10, 6)`
> - `"KJF"` ，将消息分组为 `(11, 10, 6)`
> - 消息不能分组为 `(1, 11, 06)` ，因为 `"06"` 不是一个合法编码（只有 "6" 是合法的）。
>
> 注意，可能存在无法解码的字符串。
>
> 给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。如果没有合法的方式解码整个字符串，返回 `0`。
>
> 题目数据保证答案肯定是一个 **32 位** 的整数。

题目连接：[91. 解码方法](https://leetcode.cn/problems/decode-ways/)

# 前言

面向测试用例找状态转移。。。

# 思路

看到问题的描述，我的首个反应是动态规划。原因大概其一是只需要返回解码方法总数，其二是如果考虑回溯算法似乎有太多情况要处理，并不方便。

设 $dp[i-1]$ 表示前 $i$ 个字符的解码方法总数。我们应当想办法找出状态间的转移，避免在模拟下不断地回溯。

- 如果 `s[i]` 不为 `'0'`，则 `s[i]` 可被独立解释为一个字母，<u>于是排除掉独立解码的 `s[i]`，至少有 $dp[i-1]$ 种解码方案</u>。进一步地，
  - 如果 `s[i-1]` 为 `'1'`，则 `s[i-1]s[i]` 可被一起解释为一个字母，<u>排除掉 `s[i-1]s[i]` 的结合，则会新增 $dp[i-2]$ 种解码方案</u>，因此 $dp[i]=dp[i-1]+dp[i-2]$；
  - 如果 `s[i-1]` 为 `'2'` 且 `s[i]` 在 `'1'` 至 `'6'` 之间，则 `s[i-1]s[i]` 同样可被一起解释为一个字母，因此 $dp[i]=dp[i-1]+dp[i-2]$；
  - 否则 `s[i]` 不能与 `s[i-1]` 被一起解释为一个字母，因此 $dp[i]=dp[i-1]$。
- 如果 `s[i]` 为 `'0'`，则 `s[i]` 不可被独立解释为一个字母，
  - 如果 `s[i-1]` 为 `'1'` 或 `'2'`，则 `s[i-1]s[i]` 可被一起解释为一个字母。<u>排除掉 `s[i-1]s[i]` 的结合</u>，于是 $dp[i]=dp[i-2]$；
  - 否则 `'s[i]'` 不能与 `s[i-1]` 被一起解释为一个字母，于是编码非法。

初始化条件：

- 如果 `s[0]` 为 `'0'`，返回 $0$；
- 否则，$dp[0]=1$。

显然也可以考虑滚动数组实现 $O(1)$ 的空间复杂度。

# 代码

时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int numDecodings(String s) {
        if (s.charAt(0) == '0') return 0;
        int n = s.length();
        char cc = s.charAt(0);
        int dp0 = 1;  // dp[i-2]
        int dp1 = 1;  // dp[i-1]
        int dp2 = 0;  // dp[i]

        for (int i = 1; i < n; i++) {
            char c = s.charAt(i);
            if (c != '0') {
                if (cc == '1') {
                    dp2 = dp1 + dp0;
                } else if (cc == '2' && c <= '6') {
                    dp2 = dp1 + dp0;
                } else {
                    dp2 = dp1;
                }
            } else {
                if (cc == '1' || cc == '2') {
                    dp2 = dp0;
                } else {
                    return 0;
                }
            }

            cc = c;
            dp0 = dp1;
            dp1 = dp2;
        }

        return dp1;
    }
}
```

