题目简述：

> 给你一个整数数组 `nums` ，数组中共有 `n` 个整数。**132 模式的子序列** 由三个整数 `nums[i]`、`nums[j]` 和 `nums[k]` 组成，并同时满足：`i < j < k` 和 `nums[i] < nums[k] < nums[j]` 。
>
> 如果 `nums` 中存在 **132 模式的子序列** ，返回 `true` ；否则，返回 `false` 。

题目链接：[456. 132 模式](https://leetcode.cn/problems/132-pattern/)

# Binary Indexed Tree

## 思路

这个问题用单调栈逆向扫描的算法性能是最高的。

但这初见时很难想到，尽管只要意识到本问题可以用单调栈解决那么思路将会非常清晰。第一次尝试解决本问题时，比较容易想到的我认为是考虑 BIT 维护前缀信息。

我们都知道 BIT 的本质用法——以 $O(\log n)$ 的查询与维护开销成本为代价，动态维护前缀和数组。不过，`nums` 的前缀和的信息对于本问题当然是没有太大帮助的，这里我们将考虑 BIT 的另一种典型的用法：值域统计，而不仅仅是动态维护原数组的前缀和信息。更准确来说，BIT 归根结底还是用于动态维护前缀和信息的，只不过我们可以通过维护一些统计量数组的前缀和，比如原数组在某个计算方式下的频率数组，进而实现值域统计。

常见的值域统计有：

- 排名查询（多少个数小于等于当前数）
- 逆序对计数（维护频率数组的前缀和，例如 [LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 与 [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)）
- 区间中是否存在落在某个范围的数，或这些数的数量（即本问题 [456. 132 模式](https://leetcode.cn/problems/132-pattern/)）

值域统计通常需要离散化，或者说是对值域进行编码。

注意到 132 模式中 13 与 12 实际上都是逆序对，因此知道 BIT 可以计算逆序对后，或许这能启发我们对本问题考虑 BIT。

首先进行离散化，将 `nums` 的值域进行编码，稍后 BIT 将作用于值域数组，而不直接作用于 `nums`：

```java
private Map<Integer, Integer> encode(int[] nums) {
    int[] copy = nums.clone();
    Arrays.sort(copy);
    Map<Integer, Integer> encoder = new HashMap<>();
    int rank = 0;
    for (int num : copy) {
        if (encoder.putIfAbsent(num, rank) == null) rank++;
    }
    return encoder;
}
```

然后，对于值域中的某个数值 `nums[i]`，我们考虑其为 132 模式中的 3。那么，我们需要一个左侧最小元素数组 `leftMin`，该数组能够以 $O(1)$ 的时间复杂度直接帮助我们获取到 `nums[i]` 左侧的最小元素的值。为什么是左侧最小元素，而不是别的其他元素呢？因为要使固定的 3 能够匹配到更多的 2，我们就需要让 1 尽可能小。当 1 是 3 左侧元素中的最小值时，2 便能够考虑全部的候选解。

```java
private int[] getLeftMin(int[] nums) {
    int[] leftMin = new int[nums.length];
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < nums.length; i++) {
        leftMin[i] = min;
        min = Math.min(min, nums[i]);
    }
    return leftMin;
}
```

接下来就是 BIT 的拿手好戏。我们逆向扫描 `nums`，对于当前扫描元素 `nums[i]`，我们希望知道已扫描元素（即 `nums[i]` 右侧的元素）中是否存在 `nums[j]` 满足：

1. `nums[j] < nums[i]`
2. `nums[j] > leftMin[i]`

因此，BIT 只需要在扫描中动态维护**对于一个值域中的值有多少个已扫描元素小于该值**，那么

1. `bit.query(rank_of_num)` 能够查询出满足 `nums[j] < nums[i]` 的元素数量，记为 `a`
2. `bit.query(rank_of_leftMin + 1)` 能够查询出满足 `nums[j] <= leftMin[i]` 的元素数量，记为 `b`

那么 `a - b` 就是满足 `leftMin[i] < nums[j] < nums[i]` 的元素数量，即以 `nums[i]` 为 3 的 132 模式数。

## 代码

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
class Solution {

    public static class BIT {

        private final int[] bit;
        private final int N;

        public BIT(int length) {
            bit = new int[length + 1];
            N = length;
        }

        // 1-based
        public int query(int i) {
            int res = 0;
            while (i > 0 && i <= N) {
                res += bit[i];
                i -= i & -i;
            }
            return res;
        }

        // 1-based
        public void update(int i, int delta) {
            while (i <= N) {
                bit[i] += delta;
                i += i & -i;
            }
        }
    }

    public static Map<Integer, Integer> encode(int[] nums) {
        int[] copy = nums.clone();
        Arrays.sort(copy);
        Map<Integer, Integer> encoder = new HashMap<>();
        int rank = 0;
        for (int num : copy) {
            if (encoder.putIfAbsent(num, rank) == null) rank++;
        }
        return encoder;
    }

    public static int[] getLeftMin(int[] nums) {
        int[] leftMin = new int[nums.length];
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            leftMin[i] = min;
            min = Math.min(min, nums[i]);
        }
        return leftMin;
    }

    public boolean find132pattern(int[] nums) {
        int[] leftMin = getLeftMin(nums);
        Map<Integer, Integer> rank = encode(nums);
        BIT bit = new BIT(nums.length);

        for (int i = nums.length - 1; i >= 0; i--) {
            int rankOfNum = rank.get(nums[i]) + 1;
            if (leftMin[i] < nums[i]) {
                int rankOfLeftMin = rank.get(leftMin[i]) + 1;
                int a = bit.query(rankOfNum);
                int b = bit.query(rankOfLeftMin + 1);
                if (a - b > 0) return true;
            }
            bit.update(rankOfNum + 1, 1);
        }

        return false;
    }
}
```

# 单调栈

## 思路

这个问题用逆向扫描的单调栈是效率最高的算法，能够实现 $O(n)$ 的时间复杂度，但是比较巧妙，不太好想到。反之我初见时是完全没想到的。

做法是反向扫描，保证单调栈内元素（自栈底至栈顶）递减，当需要弹出栈顶时意味着当前元素大于栈顶，于是满足了 32 模式。要找是否存在满足条件的 1，复用上文给出的 `leftMin` 实现即可。

原理是一样的，`leftMin` 作为 1 是让 2 的候选解范围尽可能大的最优选择。

其实只要知道本问题可以用逆向扫描的单调栈解决，那么思路是非常清晰的，代码也是非常好写的，难点就是在于初见时如何想到 “哦，我们应该用单调栈”。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        int[] leftMin = getLeftMin(nums);
        int[] stack = new int[nums.length];
        int stackTop = -1;

        for (int i = nums.length - 1; i >= 0; i--) {
            while (stackTop > -1 && stack[stackTop] < nums[i]) {
                if (leftMin[i] < nums[i] && leftMin[i] < stack[stackTop]) {
                    return true;
                } else {
                    stackTop--;
                }
            }
            stack[++stackTop] = nums[i];
        }

        return false;
    }

    private int[] getLeftMin(int[] nums) {
        int[] leftMin = new int[nums.length];
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            leftMin[i] = min;
            min = Math.min(min, nums[i]);
        }
        return leftMin;
    }
}
```

