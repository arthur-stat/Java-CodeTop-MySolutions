题目简述：

> 给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。
>
> 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
>
> 请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
>
> **注意**：不允许旋转信封。

题目链接：[354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

# 思路

对于 `envelopes` 信封数组，首先按其宽度升序排序、***当宽度相同时按高度降序排序***，然后对排序后的信封数组取其高度数组，高度数组的最长严格递增子序列（LIS）即为问题的解。

如果对 LIS 的二分搜索优化的分析（时间开销 $O(n^2)\to O(n\log n)$）不熟悉，请移步至我为 [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 写的题解。

# 代码

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (a, b) -> {
            int w = Integer.compare(a[0], b[0]);
            if (w != 0) return w;
            return Integer.compare(b[1], a[1]);
        });

        return LIS(envelopes);
    }

    public int LIS(int[][] sorted) {
        int n = sorted.length;
        if (n <= 1) return n;
        int[] tails = new int[n];
        tails[0] = sorted[0][1];
        int len = 1;

        for (int i = 0; i < n; i++) {
            int val = sorted[i][1];

            int lo = 0;
            int hi = len - 1;
            while (lo <= hi) {
                int mid = lo + (hi - lo) / 2;
                if (tails[mid] < val) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            if (hi + 1 == len) len++;
            tails[hi + 1] = val;
        }

        return len;
    }
}
```

