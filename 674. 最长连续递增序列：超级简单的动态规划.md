题目简述：

> 给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。
>
> **连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

题目链接：[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

# 思路

没有难度的动态规划问题。

设 $dp[n]$ 为以 `nums[n]` 结尾的最长连续递增子序列的长度，则
$$
dp[n]=\left\{\begin{align}&dp[n-1]+1,&&\mathrm{nums}[n]>\mathrm{nums}[n-1]\\\\&1,&&\mathrm{nums}[n]\leqslant\mathrm{nums}[n-1]\end{align}\right.
$$

# 代码

算法的时间复杂度为 $O(n)$，使用滚动数组优化空间开销，空间复杂度为 $O(1)$。

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int n = nums.length;
        int dp1 = 1;
        int dp2 = 0;
        int maxDp = 1;
        
        for (int i = 1; i < n; i++) {
            dp2 = nums[i] > nums[i - 1] ? dp1 + 1 : 1;
            dp1 = dp2;
            maxDp = Math.max(maxDp, dp1);
        }

        return maxDp;
    }
}
```
