题目简述：

> 给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。
>
> 返回一个数组 `[r1, c1, r2, c2]`，其中 `r1`, `c1` 分别代表子矩阵左上角的行号和列号，`r2`, `c2` 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。
>
> **注意：**本题相对书上原题稍作改动

题目链接：[面试题 17.24. 最大子矩阵](https://leetcode.cn/problems/max-submatrix-lcci/)

# 思路

> 注意！是元素总和最大的子矩阵，不是元素总和最大的正方形！！！这导致我在这里卡了好久都没有思路……

本题其实是 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 的二维版本，在那里我们使用的是所谓的 Kadane 算法求解——其实就是一个十分简单但有效的动态规划。

那么，对应到这个问题我们如何求解呢？当意识到本问题是 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)  的二维化后，一个自然的想法就是想办法如何降维，从而将问题转变为简单的 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 情形。

循着 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 的思路设计算法整体框架：对于确定的行上界 $\mathrm{top}$ 与行下界 $\mathrm{bottom}$，设 $dp[i]$ 表示 `matrix` 在行上界 $\mathrm{top}$ 与行下界 $\mathrm{bottom}$ 限制下自第 `matrix[*][0]` 列至第 `matrix[*][i]` 列的总和最大子矩阵的总和，那么针对一个确定了行上界 $\mathrm{top}$ 与行下界 $\mathrm{bottom}$ 的子问题就完全转化为 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 问题：$dp[i]=\max\{dp[i-1]+\mathrm{colSum}[i],\,\mathrm{colSum}[i]\}$，其中 $\mathrm{colSum}[i]$ 的含义为第 `matrix[*][i]` 列上从 $\mathrm{top}$ 至 $\mathrm{bottom}$ 元素的累加和。

换句话说，我们将问题拆解为了若干个子问题，而每个子问题都是一维的，每个子问题都可以视为一个 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 问题，用 Kadane 动态规划算法求解即可，进而最终实现了原问题的降维处理。

注意到当 $\mathrm{top}=\mathrm{bottom}=1$ 时，本问题完全退化为 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 的情景。我们需要枚举所有可能的 $\mathrm{top}$ 与 $\mathrm{bottom}$，从而找出元素总和最大的子矩阵。

如果还不理解，请结合代码，我相信代码甚至会更直观一点。

# 代码

使用滚动数组优化一维 Kadane 子问题的空间开销，最终算法的时间复杂度为 $O(m^2n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int[] getMaxMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] res = new int[4];
        int maxMatrixSum = Integer.MIN_VALUE;

        for (int top = 0; top < m; top++) {
            for (int bottom = top; bottom < m; bottom++) {
                
                // dp init
                int dp1 = getColSumInRange(matrix, top, bottom, 0);
                int dp2;
                if (dp1 > maxMatrixSum) {
                    setRes(res, top, 0, bottom, 0);
                    maxMatrixSum = dp1;
                }
                int leftCol = 0;

                for (int i = 1; i < n; i++) {
                    int colSum = getColSumInRange(matrix, top, bottom, i);
                    if (colSum > dp1 + colSum) {
                        dp2 = colSum;
                        leftCol = i;
                    } else {
                        dp2 = dp1 + colSum;
                    }

                    if (dp2 > maxMatrixSum) {
                        setRes(res, top, leftCol, bottom, i);
                        maxMatrixSum = dp2;
                    }

                    int tmp = dp1;
                    dp1 = dp2;
                    dp2 = tmp;
                }
            }
        }

        return res;
    }

    private int getColSumInRange(int[][] matrix, int top, int bottom, int col) {
        int sum = 0;
        for (int row = top; row <= bottom; row++) {
            sum += matrix[row][col];
        }
        return sum;
    }

    private void setRes(int[] res, int arg1, int arg2, int arg3, int arg4) {
        res[0] = arg1;
        res[1] = arg2;
        res[2] = arg3;
        res[3] = arg4;
    }
}
```

# 小改进

上述算法中 `getColSumInRange` 进行了大量重复计算，`getColSumInRange` 方法本身也存在时间开销。我们可以预计算每列的前缀行累加和，这样在初始化每列的行前缀和矩阵后，`getColSumInRange` 每次调用都只需要计算两数之差，时间复杂度为 $O(1)$。

原算法 AC 时花费 939ms，改进后 AC 时花费 57ms。

代价是空间复杂度 $O(mn)$，以空间换时间。

```java
class Solution {
    
   // 缓存每列的行前缀和
    private int[][] colPrefixSum;

    public int[] getMaxMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] res = new int[4];
        int maxMatrixSum = Integer.MIN_VALUE;

        // init
        initPrefixColSumForRow(matrix);

        for (int top = 0; top < m; top++) {
            for (int bottom = top; bottom < m; bottom++) {

                // dp init
                int dp1 = getColSumInRange(top, bottom, 0);
                int dp2;
                if (dp1 > maxMatrixSum) {
                    setRes(res, top, 0, bottom, 0);
                    maxMatrixSum = dp1;
                }
                int leftCol = 0;

                for (int i = 1; i < n; i++) {
                    int colSum = getColSumInRange(top, bottom, i);
                    if (colSum > dp1 + colSum) {
                        dp2 = colSum;
                        leftCol = i;
                    } else {
                        dp2 = dp1 + colSum;
                    }

                    if (dp2 > maxMatrixSum) {
                        setRes(res, top, leftCol, bottom, i);
                        maxMatrixSum = dp2;
                    }

                    int tmp = dp1;
                    dp1 = dp2;
                    dp2 = tmp;
                }
            }
        }

        return res;
    }

    private void initPrefixColSumForRow(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        colPrefixSum = new int[m][n];

        for (int j = 0; j < n; j++) {
            colPrefixSum[0][j] = matrix[0][j];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {
                colPrefixSum[i][j] = colPrefixSum[i - 1][j] + matrix[i][j];
            }
        }
    }

    private int getColSumInRange(int top, int bottom, int col) {
        return top == 0 ? colPrefixSum[bottom][col] : colPrefixSum[bottom][col] - colPrefixSum[top - 1][col];
    }

    private void setRes(int[] res, int arg1, int arg2, int arg3, int arg4) {
        res[0] = arg1;
        res[1] = arg2;
        res[2] = arg3;
        res[3] = arg4;
    }
}
```

