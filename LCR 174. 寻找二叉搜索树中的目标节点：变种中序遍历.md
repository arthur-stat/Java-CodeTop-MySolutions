题目简述：

> 某公司组织架构以二叉搜索树形式记录，节点值为处于该职位的员工编号。请返回第 `cnt` 大的员工编号。

题目连接：[LCR 174. 寻找二叉搜索树中的目标节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

# 思路

如果把问题改为 “返回第 `cnt` 小的员工编号”，那么最普通的中序遍历即可解决。

现在的要求是 “返回第 `cnt` 大的员工编号”，在不使用额外空间的情况下，我们可以进行两次 DFS，第一次找出节点的总数量 `n`，第二次找出第 `n - cnt + 1` 小的节点。这样不改变时间复杂度，只是常数因子增大。

或者，允许使用额外数组的话，那么使用一个数组记录中序遍历的结果，最后直接数组的第 `n - cnt + 1` 个值就好了。

但这样实现都不够完美。如何尽可能少的遍历同时不使用额外的数组呢？

很简单！考虑中序遍历的变种就好了。一般我们讲二叉树的中序遍历，认为是 “左 → 中 → 右” 的顺序，对于 BST 能够得到第 k 小的元素，注意这里存在对称性，那我们按 “右 → 中 → 左” 的顺序遍历，得到的就是第 k 大的元素了。

# 递归实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    int count;
    int cnt;
    int res;

    public int findTargetNode(TreeNode root, int cnt) {
        count = 0;
        this.cnt = cnt;
        dfs(root);
        return res;
    }

    public void dfs(TreeNode node) {
        if (node.right != null) dfs(node.right);

        count++;
        if (count == cnt) {
            res = node.val;
            return;
        }

        if (node.left != null) dfs(node.left);
    }
}
```

# 迭代实现

```java
class Solution {

    int count;
    int cnt;
    int res;

    public int findTargetNode(TreeNode root, int cnt) {
        count = 0;
        this.cnt = cnt;
        dfs(root);
        return res;
    }

    public void dfs(TreeNode root) {
        Deque<TreeNode> s = new ArrayDeque<>();
        s.push(root);

        while (root != null || !s.isEmpty()) {
            if (root != null) {
                s.push(root);
                root = root.right;
                continue;
            }

            TreeNode node = s.pop();
            count++;
            if (count == cnt) {
                res = node.val;
                return;
            }

            root = node.left;
        }
    }
}
```

