题目简述：

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> **进阶：**你能尽量减少完成的操作次数吗？

题目连接：[283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)

# 思路

一般涉及数组的问题，通常要考虑是否可以应用双指针。像冒泡排序那样也能实现目的，但操作次数太多了。对于这个问题，沿着双指针的思路思考，可以得到高效的算法。

这个问题应用双指针的关键是如果我们考虑交换操作（swap），那么无论如何也无法高效解决问题，因为我们在交换一个零元素与一个非零元素后就破坏了非零元素间的相对顺序，要恢复顺序则又要进行许多额外操作。考虑交换，就陷入思维陷阱了。

正确的思路是不要交换，而是直接让一个指针指向下一个非零元素应存放的位置（`nextNonZero`），然后逐个扫描就行了，只要扫描到非零元素就把该元素放到 `nextNonZero` 位置上。我们不关心此前这个非零元素的位置在哪、其上元素是零还是不是零，因为这里实际上是一个快慢指针：`cur` 是快指针，`nextNonZero` 是慢指针，那么由这两个指针实际上划分了三个区间：

```bash
     A         B          C
|_________|_________|___________|
     nextNonZero   cur
```

其中，

- 区间 A 全部是我们操作过后的、可以保证均为非零元素且保持原有相对顺序的；
- 区间 B 已扫描但未做改动，其中的元素可能为零，可能非零，我们并不能断言；
- 区间 C 尚未扫描。

这样，当 `cur` 扫描完成、即区间 C 为空时，我们就保证了区间 A 中的元素均非零且保持原有相对顺序。而且不难证明，区间 A 中就包含了原数组中全部非零元素。至于区间 B 其中的内容是什么，我们不关心——实际上他就是原来该位置上的元素，未曾改变。所以我们把区间 B 全部赋 0 就行了。于是，大功告成了！

# 代码

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int nextNonZero = 0;  // 指向下一个非零元素应存放的位置
        int n = nums.length;

        for (int cur = 0; cur < n; cur++) {
            if (nums[cur] == 0) continue;
            nums[nextNonZero] = nums[cur];
            nextNonZero++;
        }

        for (int cur = nextNonZero; cur < n; cur++) nums[cur] = 0;
    }
}
```

