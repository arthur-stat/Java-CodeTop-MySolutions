题目简述：

> 给定一个长度为 `n` 的**环形整数数组** `nums` ，返回 *`nums` 的非空 **子数组** 的最大可能和* 。
>
> **环形数组** 意味着数组的末端将会与开头相连呈环状。形式上， `nums[i]` 的下一个元素是 `nums[(i + 1) % n]` ， `nums[i]` 的前一个元素是 `nums[(i - 1 + n) % n]` 。
>
> **子数组** 最多只能包含固定缓冲区 `nums` 中的每个元素一次。形式上，对于子数组 `nums[i], nums[i + 1], ..., nums[j]` ，不存在 `i <= k1, k2 <= j` 其中 `k1 % n == k2 % n` 。

题目链接：[918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

# 思路

如果只是计算普通数组的子数组最大和，那么就是 [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 的情况，考虑动态规划，即 Kadane 算法，能够实现 $O(n)$ 的时间复杂度与 $O(1)$ 的空间复杂度（滚动数组）。

对于非循环数组的情况，定义 $dp[i]$ 表示以 `nums[i]` 结尾的最大和连续子数组的和，则状态转移方程为
$$
dp[i]=\max\big\{dp[i-1]+\mathrm{nums}[i],\,\mathrm{nums}[i]\big\}
$$
但对于循环数组的情况，我们又该如何应对呢？

注意到对于循环数组来说，他的子数组要么是在数组的其中一段，要么是将数组分为三段然后取其左右两段。

为了更形象地说明，我们画个图做示意：
$$
\begin{align}
&\overbrace{\ \ \ \ \ \ \ \ \ }^{\text{sub\,1}}\ \ \ \ \ \ \ \ \ \ \  \ \ \overbrace{\ \ \ \ \ \ \ \ \ \ \ \ \ \ }^{\text{sub\,3}}\\
&\begin{array}{|c|}\hline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\\hline
\end{array}\\
&\ \ \ \ \ \ \ \ \ \,\underbrace{\ \ \ \ \ \ \ \ \ \ \ \ }_{\text{sub\,2}}
\end{align}
$$
即，普通数组的子数组只可能是 $\text{sub\,2}$ 的形式，但循环数组的子数组除了可能是 $\text{sub\,2}$ 的形式外，还可能是 $\text{sub\,1}+\text{sub\,3}$ 的形式，我们需要同时考虑到这种情况。

对于 $\text{sub\,2}$ 形式的子数组，我们按照常规 Kadane 算法计算即可；对于 $\text{sub\,1}+\text{sub\,3}$ 形式的子数组，该如何处理呢？很简单，由于数组的所有元素总和 $sum$ 是固定的，因此取与之互补的 $\text{sub\,2}$ 子数组，用 $sum$ 减去 $\text{sub\,2}$ 子数组的元素总和即可，这样就能得到 $\text{sub\,1}+\text{sub\,3}$ 的元素总和。

所以我们依然可以仅考虑常规数组的子数组 $\text{sub\,2}$，但需要同时维护最大和子数组与最小和子数组：

- 最大和子数组对应 $\text{sub\,2}$ 为最大和子数组的情况，属于常规 Kadane 算法；
- 最小和子数组对应 $\text{sub\,2}$ 为最小和子数组的情况，这等价于 $\text{sub\,1}+\text{sub\,3}$ 为循环数组的最大和子数组的情况。

最大和子数组对应 $\text{sub\,2}$ 的状态转移考虑常规 Kadane 算法，为
$$
dp1[i]=\max\big\{dp1[i-1]+\mathrm{nums}[i],\,\mathrm{nums}[i]\big\}
$$
最小和子数组对应 $\text{sub\,2}$ 的状态转移为
$$
dp2[i]=\min\big\{dp2[i-1]+\mathrm{nums}[i],\,\mathrm{nums}[i]\big\}
$$
最后在 $dp1$ 的最大值与 $sum-dp2$ 的最大值中选择一个，结果即为循环数组的最大和子数组的和。

一个小细节是当 `nums` 内元素均非正时 $dp2$ 对应的 $\text{sub\,2}$ 将取到整个 `nums` 数组，但这是不允许的，否则表示循环数组的最大和子数组 $\text{sub\,1}+\text{sub\,3}$ 将取到空数组，对应的元素总和为 $0$——但题干要求的是应返回非空的循环子数组最大和。这种情况应单独处理，直接返回数组中的最大值，可以通过 $dp2$ 是否等于 $sum$ 进行判断。

读者可以进一步想想为什么 $dp1$ 就不需要这样单独处理。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int max_dp1 = nums[0];
        int min_dp2 = nums[0];
        int dp1 = 0;
        int dp2 = 0;
        int sum = 0;

        for (int num : nums) {
            dp1 = Math.max(dp1 + num, num);
            max_dp1 = Math.max(max_dp1, dp1);
            dp2 = Math.min(dp2 + num, num);
            min_dp2 = Math.min(min_dp2, dp2);
            sum += num;
        }

        return (min_dp2 != sum) ? Math.max(max_dp1, sum - min_dp2) : max_dp1;
    }
}
```