题目简述：

> 给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。
>
> 假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。
>
> 你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。
>
> **进阶：**
>
> - 如何证明 `nums` 中至少存在一个重复的数字?
> - 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

题目连接：[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

# 没有头绪……

如果允许修改数组，至少是临时修改，负号标记法或原地哈希都可以轻松做到 $O(n)$ 时间复杂度与 $O(1)$ 空间复杂度。

如果允许最坏 $O(n\log n)$ 的时间复杂度，快速选择算法也可以轻松解决。

甚至直接付出 $O(n\log n)$ 的代价进行排序，然后再遍历一次，找相邻的等值元素。

再或者是寻找唯一不重复的数，那么直接异或一遍即可。

对于现在的情况，该怎么办呢？

# Floyd 判圈算法

我没想出来，看了别人的解法觉得很精妙。在此记录。

这个方法似乎被称为什么 Floyd 判圈算法，那我们就称他为这个吧。

这个方法很清奇，其思路是：由于数组中只存在一种重复的数字，而其他的数字都是唯一的；同时，`n + 1` 个数字都在 `[1, n]` 范围内，因此可以把数组暂且看作单向链表，数组上的各数字的索引看成节点，`next` 指针就取数字的字面量值。这样，如果不存在重复值，则我们从任何一点出发必然不存在环路（最终一定会下标越界，视为最后一个节点的 `next` 为 `null`）；但是一旦有重复值，则必然会形成环路，然后我们对这个 “链表” 用快慢指针检测环路就好了。

快慢指针找到环路的入口后，利用公式
$$
\text{起点到入口的长度}+\text{环内剩余距离}=\text{整个环长的整数倍}
$$
让慢指针回到 `0` 重新开始移动，并且此时令快指针与慢指针按相同速度每次一步的速度移动，最终再次相遇时就是重复值。原理和 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 倒是一样的。

---

<u>注意，映射取 `nums[x] - 1` 的话有可能会导致原地踏步，例如 `nums[0]` 等于 `1` 时，取 `nums[x]` 就没问题，而且题目能保证不会越界。</u>

推荐直接移步至 [287.寻找重复数 | Kirsche](https://leetcode.cn/problems/find-the-duplicate-number/solutions/58841/287xun-zhao-zhong-fu-shu-by-kirsche/)。

# 代码

