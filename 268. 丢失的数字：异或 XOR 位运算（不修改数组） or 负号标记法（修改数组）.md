题目简述：

> 给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。
>
> **提示：**
>
> - `nums` 中的所有数字都 **独一无二**
>
> **进阶：**你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

题目链接：[268. 丢失的数字](https://leetcode.cn/problems/missing-number/)

# 异或 XOR 位运算（不修改数组）

这应该是本问题的最佳方案，主要是边界条件少（或者说就没有边界条件），代码写起来很优雅。

## 思路

这种思路是把问题转为 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)。在 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 中，我们一遍异或就找出只出现一次的数字；对于本问题，我们先令初始化为 0 的变量与 `nums` 中的所有元素异或一遍，再和 `[0, n]` 内的每个元素异或一遍，那么问题就转化为了 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)。

在逻辑上，可以认为我们为 `nums` 拼接了一个元素从 `0` 以步长 1 单调递增至 `n` 的数组，然后将这个数组作为问题 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 的输入，寻找只出现一次的数字。

## 代码

```java
class Solution {
    public int missingNumber(int[] nums) {
        int x = 0;
        for (int num : nums) x ^= num;
        for (int i = 1; i <= nums.length; i++) x ^= i;
        return x;
    }
}
```

# 负号标记法（修改数组）

这个方案是我最初想到的方案，完全能 AC，也是复杂度数量级最优方案之一，但是需要维护的逻辑相对多了一点。

## 思路

负号标记法也可以解决本问题，而且也能实现线性时间复杂度且仅使用额外常数空间。由于 `nums` 中的每个数都是有范围的，因此遍历时直接让元素的值作为索引，使索引对应的元素取相反数，这样进行第一次遍历后，我们再进行第二次遍历扫描，这一次哪个数字还是正数，它对应的索引就是缺失的那个数——因为如果该数在数组中，那么在第一次遍历取索引对应元素相反数时，该位置的元素就应该为负数。

不过注意本问题取值范围包含 0，再考虑到数字最大为 `n` 但 `nums` 长度也为 `n`，因此可以单独用一个变量表示是否已扫描到字面量 `n` 或 `n` 被取反（再减一）后的数，对于字面量小于 `n` 的元素再正常取反后减一。这里减一是因为 0 取反后还是 0，但我们希望用负号进行标记，因此再减一使其转为负数。

实际上这是一种把元素的值当作哈希表 key 做哈希映射的想法。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。常数时间开销相对大一点点。

```java
class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        boolean lackN = true;

        for (int i = 0; i < n; i++) {
            if (nums[i] == n || nums[i] == -n - 1) {
                lackN = false;
            } else {
                if (nums[i] >= 0) {
                    nums[nums[i]] = -nums[nums[i]] - 1;
                } else {
                    int index = -(nums[i] + 1);
                    nums[index] = -nums[index] - 1;
                }
            }
        }

        if (lackN) return n;
        for (int i = 0; i < n; i++) {
            if (nums[i] >= 0) return i;
        }

        return -1;
    }
}
```
