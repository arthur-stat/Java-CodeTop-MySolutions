题目简述：

> 使用下面描述的算法可以扰乱字符串 `s` 得到字符串 `t` ：
>
> 1. 如果字符串的长度为 1 ，算法停止
> 2. 如果字符串的长度 > 1 ，执行下述步骤：
>    - 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 `s` ，则可以将其分成两个子字符串 `x` 和 `y` ，且满足 `s = x + y` 。
>    - **随机** 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，`s` 可能是 `s = x + y` 或者 `s = y + x` 。
>    - 在 `x` 和 `y` 这两个子字符串上继续从步骤 1 开始递归执行此算法。
>
> 给你两个 **长度相等** 的字符串 `s1` 和 `s2`，判断 `s2` 是否是 `s1` 的扰乱字符串。如果是，返回 `true` ；否则，返回 `false` 。

题目链接：[87. 扰乱字符串](https://leetcode.cn/problems/scramble-string/)

# 思路

本问题是一个字符串动态规划问题，如果是初见可能比较难想到应当考虑动态规划，即使能想到动态规划或许一时半会也不太容易想到应定义三维状态。

定义 $dp[i][j][k]$ 表示自 `s1[i]` 与 `s2[j]` 起分别的两个长为 `k` 的子串是否互为扰乱字符串。对于 `dp[i][j][k]`，我们考虑两子串的所有可能的分割。根据定义不难知道，假如 `a` 与 `c` 互为扰乱字符串、`b` 与 `d` 互为扰乱字符串，那么 `a + b` 与 `c + d` 也互为扰乱字符串，我们利用这一点，将两个子串视为潜在的 `a + b` 以及 `c + d`，尝试找出合法的 `a`、`b`、`c`、`d`。此处存在最优子结构，因为对于任何小于 `k` 的 `t`，`dp[i'][j'][t]` 均可以视为 `dp[i][j][k]` 的子问题的解。

注意要考虑所有情况，枚举分割 `t` 时要同时考虑交换与不交换两种情况。

因此，有状态转移方程
$$
dp[i][j][k]=\underbrace{\bigvee_{0<t<n}\big(dp[i][j][t]\land dp[i+t][j+t][k-t]\big)}_{\text{not swap}}\ \ \lor\ \,\underbrace{\bigvee_{0<t<n}\big(dp[i][j+k-t][t]\land dp[i+t][j][k-t]\big)}_{\text{swapped}}
$$

# 代码

算法的时间复杂度为 $O(n^4)$，空间复杂度为 $O(n^3)$。

```java
class Solution {
    public boolean isScramble(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        int n = s1.length();

        boolean[][][] dp = new boolean[n][n][n + 1];

        // init
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j][0] = true;
                if (s1.charAt(i) == s2.charAt(j)) dp[i][j][1] = true;
            }
        }

        for (int k = 2; k <= n; k++) {
            for (int i = 0; i + k - 1 < n; i++) {
                for (int j = 0; j + k - 1 < n; j++) {
                    for (int t = 1; t < k; t++) {
                        boolean res = (dp[i][j][t] && dp[i + t][j + t][k - t])
                                   || (dp[i][j + k - t][t] && dp[i + t][j][k - t]);
                        if (res) {
                            dp[i][j][k] = true;
                            break;
                        }
                    }
                }
            }
        }

        return dp[0][0][n];
    }
}
```

