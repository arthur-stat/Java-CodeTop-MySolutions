题目简述：

> 给你无向 **连通** 图中一个节点的引用，请你返回该图的 **深拷贝**（克隆）。
>
> 图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。
>
> ```java
> class Node {
>     public int val;
>     public List<Node> neighbors;
> }
> ```
>
>  
>
> **测试用例格式：**
>
> 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。
>
> **邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。
>
> 给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。

题目链接：[133. 克隆图](https://leetcode.cn/problems/clone-graph/)

# 无向图的 BFS 克隆

## 思路

因为给定的图是连通的无向图，所以可以考虑进行一遍 BFS，这是最直观的方案。

用一个哈希表做旧节点到新节点的映射，然后按下述流程进行一轮 BFS：

1. 从队列中取出一个旧节点，我们可以保证已存在该旧节点至新节点的映射；

2. 将该旧节点的所有邻居映射至新节点的邻居，如果映射不存在则进行下述操作，
   - 新建新节点的邻居节点并更新映射；
   - 同时这意味着该旧节点的邻居节点尚未被访问，因此令该旧邻居节点入队。
   
   现在我们可以确保旧节点的邻居均能够映射到新节点的邻居了，因此将所有新节点的邻居加入到新节点的邻居列表中；
   
3. 第二步保证了我们此时回到第一步后从队列取出的旧节点必然存在旧节点至新节点的映射，因此直接回到第一步即可，此处无需再检查是否存在旧节点至新节点的映射——否则会额外多出一次没有意义的哈希查找。直到队列为空时，终止算法。

这样就可以只进行一轮遍历的情况下完成无向图的克隆了。

如果考虑 BFS，那么每当我们处理完一个旧节点，就可以保证他对应的新节点的所有邻居均已被填充。

## 代码

算法的时间复杂度为 $O(V+E)$，空间复杂度为 $O(V)$。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Node copy = new Node(node.val);

        Map<Node, Node> oldToNew = new HashMap<>();
        oldToNew.put(node, copy);
        Deque<Node> queue = new ArrayDeque<>();
        queue.offer(node);
        
        while (!queue.isEmpty()) {
            Node oldNode = queue.poll();
            Node newNode = oldToNew.get(oldNode);

            for (Node oldNeighbor : oldNode.neighbors) {
                Node newNeighbor = oldToNew.get(oldNeighbor);
                if (newNeighbor == null) {
                    newNeighbor = new Node(oldNeighbor.val);
                    oldToNew.put(oldNeighbor, newNeighbor);
                    queue.offer(oldNeighbor);
                }
                newNode.neighbors.add(newNeighbor);
            }

        }

        return copy;
    }
}
```

# 无向图的 DFS 克隆

## 思路

也可以考虑 DFS。同样需要一张哈希表做旧节点到新节点的映射，对于一个旧节点，遍历旧节点的邻居列表，

- 如果旧节点的邻居至新节点的邻居映射存在，则直接将新节点邻居加入到新节点的邻居列表；
- 否则新建新节点的邻居节点并更新映射，然后递归调用该邻居节点，递归返回时再将该新节点邻居加入到新节点的邻居列表。

## 代码

算法的时间复杂度为 $O(V+E)$，空间复杂度为 $O(V)$。

```java
class Solution {

    private Map<Node, Node> oldToNew;

    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Node copy = new Node(node.val);
        oldToNew = new HashMap<>();
        oldToNew.put(node, copy);
        dfs(node);
        return copy;
    }

    private void dfs(Node node) {
        List<Node> list = oldToNew.get(node).neighbors;

        for (Node neighbor : node.neighbors) {
            Node fresh = oldToNew.get(neighbor);
            if (fresh == null) {
                fresh = new Node(neighbor.val);
                oldToNew.put(neighbor, fresh);
                dfs(neighbor);
            }
            list.add(fresh);
        }
    }
}
```
