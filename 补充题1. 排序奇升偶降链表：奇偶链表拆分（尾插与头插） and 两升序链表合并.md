题目简述：

> 给定一个奇数位升序，偶数位降序的链表，返回对其排序后的链表。
>
> 题面解释：例如链表 1->3->2->2->3->1 是奇数位升序偶数位降序的链表，而 1->3->2->2->3->2 则不符合题目要求。
>
> 数据范围：链表中元素个数满足 $1\leqslant n\leqslant 10000$，链表中的元素大小满足 $1\leqslant val\leqslant 100000$

题目链接：[NC207 排序奇升偶降链表](https://www.nowcoder.com/practice/3a188e9c06ce4844b031713b82784a2a)

# 思路

首先按 [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/) 的逻辑将链表拆分为奇链表与偶链表，其中奇链表偶插，偶链表由于原本是降序的，因此考虑头插，这样最终拆分出的偶链表也是升序的。

现在我们就有两个升序链表了，这就对应了 [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) 的情况，考虑链表的双指针算法。

因此本问题实际上可以被拆解为两个子问题，一个是链表奇偶拆分，一个是合并有序链表。

# 代码

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    public ListNode sortLinkedList (ListNode head) {

        // 拆分奇偶链表
        ListNode dummyOdd = new ListNode(0);
        ListNode dummyEven = new ListNode(0);
        ListNode odd = dummyOdd;
        int counter = 1;
        while (head != null) {
            if (counter % 2 == 1) {
                odd.next = head;
                odd = odd.next;
                head = head.next;
                odd.next = null;
            } else {
                ListNode tmp = head.next;
                if (dummyEven.next != null) {
                    head.next = dummyEven.next;
                    dummyEven.next = head;
                    head = tmp;
                } else {
                    dummyEven.next = head;
                    head = head.next;
                    dummyEven.next.next = null;
                }
            }
            counter++;
        }

        // 合并两个升序链表
        ListNode dummy = new ListNode(0);
        ListNode node = dummy;
        odd = dummyOdd.next;
        ListNode even = dummyEven.next;
        while (odd != null && even != null) {
            if (odd.val <= even.val) {
                node.next = odd;
                node = odd;
                odd = odd.next;
                node.next = null;
            } else {
                node.next = even;
                node = even;
                even = even.next;
                node.next = null;
            }
        }

        if (odd != null) node.next = odd;
        if (even != null) node.next = even;

        return dummy.next;
    }
}
```

