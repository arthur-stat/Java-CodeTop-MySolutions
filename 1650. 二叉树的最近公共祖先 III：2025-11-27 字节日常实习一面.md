题目简述：

> 给定一棵二叉树中的两个节点 p 和 q，返回它们的最近公共祖先节点（LCA）。
>
> 每个节点都包含其父节点的引用（指针）。Node 的定义如下：
>
> ```java
> class Node {
>     public int val;
>     public Node left;
>     public Node right;
>     public Node parent;
> }
> ```
>
> 根据维基百科中对最近公共祖先节点的定义：“两个节点 p 和 q 在二叉树 T 中的最近公共祖先节点是后代节点中既包括 p 又包括 q 的最深节点（我们允许一个节点为自身的一个后代节点）”。一个节点 x 的后代节点是节点 x 到某一叶节点间的路径中的节点 y。

题目链接：[1650. 二叉树的最近公共祖先 III](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/description/)

LeetCode Wik 链接：[1650. 二叉树的最近公共祖先 III](https://leetcode.doocs.org/lc/1650/)

> Note: 2025/11/27 字节日常实习一面考了我这道题。虽然是 mid 难度的题目，但是过于冷门，尽管我做完了 Top 500，但这道题至少是 Top 1000+（CodeTop 上有记录的面试考察记录仅一次，截止至 2025/11/28），我根本就没有见过这个问题，也没有相似的题目（[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 仅需后序遍历，与本问题方法完全不同）。我不觉得我能在面试的那点时间内想出来这道题的正确解法，虽然我觉得我的项目和八股答得还不错，但算法的确在事实上没有写出来正确结果，被字节挂掉也算应该。不过毕竟我是 28 届，继续努力吧。

# 思路

与 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 不同，本问题中输入没有给定根节点，因此不能直接考虑后序遍历了。与此同时，本问题中的节点是双向的，节点中含有指向父节点的指针，因此我们需要考虑特殊的遍历方式。

正解是双指针。置两个

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(\log n)$，其中空间复杂度主要来自于递归栈开销。

```java

```