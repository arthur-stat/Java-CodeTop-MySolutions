题目简述：

> 给定一个 **排序好** 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。
>
> 整数 `a` 比整数 `b` 更接近 `x` 需要满足：
>
> - `|a - x| < |b - x|` 或者
> - `|a - x| == |b - x|` 且 `a < b`

题目链接：[658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

# 思路

由于 `arr` 是排序好的，因此可以先二分查找找出数组中首个大于等于 `x` 的数，接着再以该数为起点，双指针法从该点起中心外扩，直到拓展出 `k` 个元素。这里要注意到，实际上这 `k` 个元素在 `arr` 中正是一段连续的子数组。

# 代码

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int N = arr.length;
        int l = 0;
        int r = N - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] < x) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        int i = l - 1;
        int j = l;
        while (j - i - 1 < k) {
            if (i >= 0 && j < N) {
                if (closer(arr, x, i, j)) {
                    i--;
                } else {
                    j++;
                }
            } else if (i >= 0) {
                i--;
            } else {
                j++;
            }
        }

        Integer[] res = new Integer[k];
        for (int m = 0; m < k; m++) {
            res[m] = arr[i + m + 1];
        }

        return Arrays.asList(res);
    }

    private boolean closer(int[] arr, int x, int i, int j) {
        int dist_i = Math.abs(arr[i] - x);
        int dist_j = Math.abs(arr[j] - x);
        if (dist_i < dist_j) {
            return true;
        } else if (dist_i > dist_j) {
            return false;
        } else {
            return i < j;
        }
    }
}
```

