题目简述：

> 给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。
>
> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

题目链接：[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

# 思路

“买卖股票” 这一家子问题都是动态规划（贪心算法）问题，并且逐渐推广。

1. [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)，一维动态规划
2. [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)，贪心算法
3. [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)，二维动态规划

本问题可以直接视为 [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) 的推广，只不过从最多可完成 `2` 笔交易变为了最多可完成 `k` 笔交易，这不会让问题发生根本性质变，因此这仍然是一个二维动态规划问题，只不过状态参数的取值范围更大。

设状态 $dp[i][j]$ 表示在第 $i$ 天或第 $i$ 天前共完成 $j$ 笔交易能获得的最大利润，则考虑在第 $i$ 天是否决定完成一笔交易（售出一支持有的股票），有状态转移
$$
dp[i][j]=\max\Big\{dp[i-1][j],\,\max_k\big\{dp[i-k][j-1]+\big(\mathrm{prices}[i]-\mathrm{prices}[k]\big)\big\}\Big\}
$$
这样根据状态转移方程实现的动态规划算法时间复杂度为 $O(kn^2)$，因为有一个 “回溯” 的过程，即 $\displaystyle\max_k$。事实上，这样设计出的算法在 AC 时花费 187ms，与下文的算法花费 2ms相比，几乎是天壤之别。

一个更好的思路是考虑双状态动态规划，使用两个 $dp$ 数组。

---

我们考虑两个 $dp$ 数组，

- 定义 $dp_1[i][j]$ 表示在第 $i$ 天或第 $i$ 天前共完成 $j$ 笔交易且在第 $i$ 天未持有股票能获得的最大利润；
- 定义 $dp_2[i][j]$ 表示在第 $i$ 天或第 $i$ 天前共完成 $j$ 笔交易且在第 $i$ 天持有一支股票能获得的最大利润。

这样，就有状态转移
$$
dp_1[i][j]=\max\{dp_1[i-1][j],\,dp_2[i-1][j]+\mathrm{prices}[i]\}
$$

$$
dp_2[i][j]=\max\{dp_2[i-1][j],\,dp_1[i-1][j-1]-\mathrm{prices}[i]\}
$$

这样设计出的算法时间复杂度为 $O(kn)$，大大减小了。

按照 [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) 的思路，本问题实际上应该是一个三维 DP。不过我们将其简化为双状态模型，那么这就是一个二维 DP——因为第三维只表示当前是否持有股票，这是一个二值的变量，可以将其抽象为双状态数组。

# 代码

利用滚动数组优化空间开销，算法的时间复杂度为 $O(kn)$，空间复杂度为 $O(k)$。

三维 DP / 双状态二维 DP 的滚动数组有点不好写，主要是两个滚动数组相互依赖。方便简单的实现当然是不考虑 DP 数组，显式填充整张 DP 表。

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n <= 1 || k == 0) return 0;

        // 剪枝
        if (k >= n / 2) {
            int ans = 0;
            for (int i = 1; i < n; i++) if (prices[i] > prices[i - 1]) ans += prices[i] - prices[i - 1];
            return ans;
        }

        final int NEG = Integer.MIN_VALUE / 4;

        int[] prev1 = new int[k + 1];
        int[] prev2 = new int[k + 1];
        int[] dp1 = new int[k + 1];
        int[] dp2 = new int[k + 1];
        Arrays.fill(prev1, NEG);
        Arrays.fill(prev2, NEG);

        prev1[0] = 0;
        if (k >= 1) prev2[1] = -prices[0];

        for (int i = 1; i < n; i++) {
            Arrays.fill(dp1, NEG);
            Arrays.fill(dp2, NEG);

            dp1[0] = prev1[0];

            for (int j = 1; j <= k; j++) {
                dp1[j] = Math.max(prev1[j], prev2[j] + prices[i]);
                dp2[j] = Math.max(prev2[j], prev1[j - 1] - prices[i]);
            }

            int[] tmp1 = prev1;
            int[] tmp2 = prev2;
            prev1 = dp1;
            prev2 = dp2;
            dp1 = tmp1;
            dp2 = tmp2;
        }

        return Arrays.stream(prev1).max().getAsInt();
    }
}
```

