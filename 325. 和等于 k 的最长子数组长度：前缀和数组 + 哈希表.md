题目简述：

> 给一个数组 `nums` 和目标值 `k`，找到数组中最长的子数组，使其中的元素和为 k。如果没有，则返回 0。

题目链接：[和等于 k 的最长子数组长度](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/description/)

LintCode 题目链接：[911 · 最大子数组之和为k](https://www.lintcode.com/problem/911/description)

# 思路

前缀和数组 + 哈希表，其中哈希表的用法参考 [两数之和](https://leetcode.cn/problems/two-sum/description/)，没啥好说的，很常规很常规的前缀和相关题目。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
public class Solution {
    /**
     * @param nums: an array
     * @param k: a target value
     * @return: the maximum length of a subarray that sums to k
     */
    public int maxSubArrayLen(int[] nums, int k) {
        int n = nums.length;
        int[] presum = new int[n + 1];
        Map<Integer, Integer> valToIndex = new HashMap<>();
        valToIndex.put(0, 0);
        int res = 0;
        for (int i = 0; i < n; i++) {
            presum[i + 1] = presum[i] + nums[i];
            valToIndex.putIfAbsent(presum[i + 1], i + 1);
            Integer j = valToIndex.get(presum[i + 1] - k);
            if (j != null) res = Math.max(res, i - j + 1);
        }
        return res;
    }
}
```

