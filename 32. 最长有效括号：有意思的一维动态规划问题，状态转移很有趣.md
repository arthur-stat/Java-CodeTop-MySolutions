题目简述：

> 给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

题目链接：[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

# 动态规划

为简化表示并确保分析与代码在值上的一致性，这部分采取 0-based 计数。即，“第 0 个” 实际上对应的是 ”第 1 个“。

这个问题也可以不应用动态规划，但我觉得用动态规划的算法是最自然的。

## 思路

当我看到 “最长有效” 这个词汇，我就想到可能可以利用动态规划解决。

我们先来定义状态。如果要用动态规划算法解决，可尝试定义状态 $dp[i]$ 为以第 $i$ 个字符结尾的最长有效括号子串长度。

> 为什么想到定义状态 $dp[i]$ 为以第 $i$ 个字符结尾的最长有效括号子串长度而不是截止至第 $i$ 个字符的最长有效括号子串长度呢？因为截止至此刻的全局最优解对我们当下是不充分的，即使知道 $\forall j<i,\ dp[j]$，也无法推断出 $dp[i]$。

显然，

- 若第 $i$ 个字符为 `'('`，则 $dp[i]=0$；
- 若第 $i$ 个字符为 `')'`，由于自第 $i-dp[i-1]$ 个字符起至第 $i-1$ 个字符已经构成了长度为 $dp[i-1]$ 的有效括号子串，因此我们考察第 $i-dp[i-1]-1$ 个字符。
  - 若第 $i-dp[i-1]-1$ 个字符为 `'('`，则恰匹配第 $i$ 个字符 `')'`，因此 $dp[i]=dp[i-1]+dp\big[i-dp[i-1]-2\big]+2$，其中 $dp[i-1]+2$ 是恰好 “消耗” 掉第 $i$ 个字符 `')'` 时的有效括号子串长度，$dp\big[i-dp[i-1]-2\big]$ 是 “拼接” 上 “消耗” 部分的总有效括号子串长度，若第 $i-dp[i-1]-2$ 个字符不存在（索引越界）则对 $dp\big[i-dp[i-1]-2\big]$ 取零特殊处理；
  - 否则，必然不存在以第 $i$ 个字符 `')'` 结束的有效括号子串，$dp[i]=0$，这包括了不存在第 $i-dp[i-1]-1$ 个字符（索引越界）的情况。我们可以用反证法证明，假设此时不存在第 $i-dp[i-1]-1$ 个字符（索引越界），那么结论是平凡的；反之，第 $i-dp[i-1]-1$ 个字符为 `')'` 且存在以第 $i$ 个字符 `')'` 结束的最长有效括号子串，可进一步可以推导出该最长有效子串内至少嵌套了两段紧邻但互相独立的有效括号子串：一段自第 $i-dp[i]+2$ 个字符起至第 $i-dp[i-1]-1$ 个字符结束，一段自第 $i-dp[i-1]$ 个字符起至第 $i-1$ 个字符结束。然而，根据 $dp[i-1]$ 的定义，$dp[i-1]$ 应表示以第 $i-1$ 个字符结尾的最长有效括号子串长度，那么显然自第 $i-dp[i]+2$ 个字符起至第 $i-dp[i-1]-1$ 个字符结束的子串可以与自第 $i-dp[i-1]$ 个字符起至第 $i-1$ 个字符结束的子串 “拼接”，这意味着第一段子串应当为空，即 $i-dp[i]+2=i-dp[i-1]\Leftrightarrow dp[i]=dp[i-1]+2$。显然，只有第 $i-dp[i-1]-1$ 个字符为 `'('` 且 $dp\big[i-dp[i-1]-2\big]=0$ 才有可能出现这一情况，这与假设的前提条件矛盾。

初始化条件为 $dp[0]=0$，问题的解为 $\max\limits_{i} dp[i]$。

## 代码

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        int[] dp = new int[n];
        // dp[0] = 0;
        int maxDp = 0;

        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == ')') {
                int a = i - dp[i - 1] - 1;
                if (a >= 0 && s.charAt(a) == '(') {
                    dp[i] = a >= 1 ? dp[i - 1] + dp[a - 1] + 2 : dp[i - 1] + 2;
                    maxDp = Math.max(maxDp, dp[i]);
                }
            }
            // else {
            //     dp[i] = 0;
            // }
        }

        return maxDp;
    }
}
```
