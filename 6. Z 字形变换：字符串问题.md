题目简述：

> 将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。
>
> 比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：
>
> ```
> P   A   H   N
> A P L S I I G
> Y   I   R
> ```
>
> 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。
>
> 请你实现这个将字符串进行指定行数变换的函数：
>
> > `string convert(string s, int numRows);`

题目链接：[6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)

# 直接模拟

## 思路

最直接的思路当然就是按题目的意思进行模拟，尽管这样子效率很低。一个简单可行的方案是用一个 `char[][]` 保存 Z 字形排列，然后再逐行从左至右扫描有效字符并构建结果字符串。

对于给定行数 $n$，一个完整的 Z 字形排列单元包含 $2*n-2$ 个元素，占据 $n-1$ 列。最节约脑力的办法是初始化 `char[][]` 为 $n$ 行、$\left\lceil\frac{n}{2n-2}\right\rceil\times(n-1)$ 列。

## 代码

时间复杂度与空间复杂度均为 $O(rn)$。

AC 时花费了 38ms，显然这很差劲。

```java
class Solution {
    public String convert(String s, int numRows) {
        if (numRows == 1 || s.length() <= 1) return s;
        int n = s.length();
        int unitSize = 2 * numRows - 2;
        int numCols = numRows - 1;
        char[][] z = new char[numRows][(int) Math.ceil((double) n / unitSize) * numCols];

        int i = 0;
        int numUnits = 0;
        main_loop:
        while (true) {
            // 向下排列
            for (int row = 0; row < numRows; row++) {
                z[row][numUnits * numCols] = s.charAt(i++);
                if (i >= n) break main_loop;
            }

            // 向右上方排列
            for (int count = 0; count < numRows - 2; count++) {
                z[numRows - count - 2][numUnits * numCols + count + 1] = s.charAt(i++);
                if (i >= n) break main_loop;
            }

            numUnits++;
        }

        StringBuilder sb = new StringBuilder();
        for (int row = 0; row < z.length; row++) {
            for (int col = 0; col < z[0].length; col++) {
                if (z[row][col] != '\0') sb.append(z[row][col]);
            }
        }

        return sb.toString();
    }
}
```

# 模拟改进

## 思路

实际上我们并不需要真的把 Z 字型表示出来，这不仅浪费时间，也浪费空间。

一个更好的解决方案是将每行的字符都用一个相应的 StringBuilder 进行构建，这样可以直接把字符添加到对应的行，最后将各行结果按顺序拼接起来即可。

## 代码

时间复杂度与空间复杂度均为 $O(n)$。

AC 时只花费了 5ms。

```java
class Solution {
    public String convert(String s, int numRows) {
        int n = s.length();
        StringBuilder[] row = new StringBuilder[numRows];
        for (int i = 0; i < numRows; i++) {
            row[i] = new StringBuilder();
        }

        int index = 0;
        main_loop:
        while (true) {
            for (int i = 0; i < numRows; i++) {
                row[i].append(s.charAt(index++));
                if (index >= n) break main_loop;
            }

            for (int i = numRows - 2; i > 0; i--) {
                row[i].append(s.charAt(index++));
                if (index >= n) break main_loop;
            }
        }

        for (int i = 1; i < numRows; i++) {
            row[0].append(row[i]);
        }

        return row[0].toString();
    }
}
```

