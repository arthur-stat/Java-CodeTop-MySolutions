题目简述：

> 给你一个字符数组 `chars` ，请使用下述算法压缩：
>
> 从一个空字符串 `s` 开始。对于 `chars` 中的每组 **连续重复字符** ：
>
> - 如果这一组长度为 `1` ，则将字符追加到 `s` 中。
> - 否则，需要向 `s` 追加字符，后跟这一组的长度。
>
> 压缩后得到的字符串 `s` **不应该直接返回** ，需要转储到字符数组 `chars` 中。需要注意的是，如果组长度为 `10` 或 `10` 以上，则在 `chars` 数组中会被拆分为多个字符。
>
> 请在 **修改完输入数组后** ，返回该数组的新长度。
>
> 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。

题目链接：[443. 压缩字符串](https://leetcode.cn/problems/string-compression/)

# 思路

关于字符串的双指针的模拟问题。

# 代码

其实在实现上，

- 要么提取处理缩写的逻辑为一个方法，这样处理尾字符时不会显得逻辑重复；
- 要么按段推进，而不是每次与后一个元素比较。

这样实现的代码会更优雅些。现在的实现单独处理尾字符且和循环中的处理代码重复较多，显得冗余，但目前算法是正确的，效率也很高，可用性这块没有问题。

```java
class Solution {

    private static final int[] POW10 = {
        1,
        10,
        100,
        1_000,
        10_000,
        100_000,
        1_000_000,
        10_000_000,
        100_000_000,
        1_000_000_000
    };

    public int compress(char[] chars) {
        int i = 0;  // 压缩字符串的下一个写入位置
        int len = chars.length;
        int count = 1;

        for (int j = 0; j < len - 1; j++) {
            if (chars[j] != chars[j + 1]) {
                chars[i++] = chars[j];

                if (count > 1 && count <= 9) {
                    chars[i++] = (char) (count + '0');
                    count = 1;
                } else if (count > 1) {
                    int tmp = count;
                    int place = 0;
                    while (tmp > 0) {
                        tmp /= 10;
                        place++;
                    }

                    while (place > 0) {
                        int digit = count / POW10[place - 1];
                        chars[i++] = (char) (digit + '0');
                        count -= digit * POW10[place - 1];
                        place--;
                    }
                }
                count = 1;
            } else {
                count++;
            }
        }

        chars[i++] = chars[len - 1];
        if (count > 1) {
            int tmp = count;
            int place = 0;
            while (tmp > 0) {
                tmp /= 10;
                place++;
            }

            while (place > 0) {
                int digit = count / POW10[place - 1];
                chars[i++] = (char) (digit + '0');
                count -= digit * POW10[place - 1];
                place--;
            }
        }
        return i;
    }
}
```

