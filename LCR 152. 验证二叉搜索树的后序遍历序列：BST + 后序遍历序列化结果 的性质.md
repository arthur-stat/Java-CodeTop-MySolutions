题目简述：

> 请实现一个函数来判断整数数组 `postorder` 是否为二叉搜索树的后序遍历结果。

题目链接：[LCR 152. 验证二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

# 主要思路

后序遍历的特点是：左 → 右 → 中，而 BST 的特点是：左子节点的值小于当前节点的值，当前节点的值小于右子节点的值。

这里有一个重要引理：

- 一棵树是完全二叉树的充要条件是，在最后一层保证满足完全二叉树局部性质且序列化时不写入最后一层空节点的情况下对其他层写入空节点，层序遍历或后序遍历的结果中不存在空节点。

值得注意的是，

- 前序遍历与中序遍历不存在该性质；
- 完全二叉树的层序遍历可以通过遍历结果的任意一个索引值，直接计算其父节点与两个子节点的索引；
- 完全二叉树的后序遍历则无法直接通过索引值找出父节点与两个子节点的索引，因为子树大小不均匀。

那我们如何通过 `postorder` 判断是否每个节点都满足左子节点的值小于当前节点的值且当前节点的值小于右子节点的值呢？

似乎做到这一点很难——在子节点而非子树的视角下。我们需要转换视角。

---

这很容易，因为我们不必知道每个节点的左子节点与右子节点究竟是谁。

我们只要注意到：

- 后序遍历的序列中，一个节点左侧的元素必然均为其子树，且左右子树严格分段，第一部分是属于左子树，剩下的部分属于右子树；
- 如果一棵树是 BST，那么其充要条件是任意一个节点的值均大于其左子树任何节点的值，同时任意一个节点的值均小于其右子树任何节点的值；
- 因此，`postorder` 是 BST 的后序遍历结果的充要条件是对于其中任何一个元素，不妨设为 `postorder[i]`，则从 `postorder[0]` 起至 `postorder[i-1]` 的各元素必须满足其值要么小于 `postorder[i]`、要么大于 `postorder[i]`，且一旦自某处开始大于 `postorder[i]`，不妨设 `postorder[j] > postorder[i]`，那么自 `postorder[j+1]` 起至 `postorder[i-1]` 的元素均应大于 `postorder[i]`。

我们可以逐个元素遍历并嵌套循环判断其是否符合上述性质（沿用元素视角），这样实现的算法时间复杂度为 $O(n^2)$；也可以递归解决，即找到左右子树后判断其左右子树是否也满足该性质（子树视角），这样实现的算法平均时间复杂度为 $O(n\log n)$。

---

还有一个更高效、$O(n)$ 时间复杂度的使用单调栈的方案。

> **倒序扫描后序数组**
>
> - 后序遍历最后一个元素是整棵树的根。
> - 如果我们从右往左扫，序列就变成了 **[根 | 右子树 | 左子树]** 的形式。
>
> **单调递增栈维护“右子树”路径**
>
> - 扫描过程中，用栈保存当前还没找到“父节点”的右子树节点。
> - 栈保持**单调递增**：因为在 BST 的右子树里，靠近根的节点值更大。
>
> **root 上界约束**
>
> - 每当我们遇到一个比栈顶小的元素，说明已经结束了当前右子树，开始往左子树走。
> - 此时不断弹栈，最后一个弹出的值就是“新的根”，更新为 `root`。
> - 接下来遍历的元素必须 **小于 root**（因为进入了左子树）。
> - 如果发现某个数 `> root`，说明它出现在左子树但比根还大，直接返回 `false`。
>
> **遍历结束返回 true**

这样能很好地利用树的局部和全局的关系。

# 实现一：子树分治递归

 算法的均摊时间复杂度为 $O(n\log n)$，最坏时间复杂度为 $O(n^2)$。

```java
class Solution {

    private int[] postorder;

    public boolean verifyTreeOrder(int[] postorder) {
        this.postorder = postorder;
        return f(0, postorder.length - 1);
    }

    private boolean f(int start, int end) {
        if (start >= end) return true;

        int root = postorder[end];
        int left = start - 1;  // 左子树的最后一个节点

        while (postorder[left + 1] < root) {
            left++;
        }

        for (int right = left + 1; right < end; right++) {
            if (postorder[right] < root) return false;
        }
        

        if (!f(start, left)) return false;
        if (!f(left + 1, end - 1)) return false;
        return true;
    }
}
```

# 实现二：逐元素 O(n²) 嵌套循环

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。逐个元素遍历并嵌套循环判断是否满足上文给出的性质。

这一实现是我首个想到、着手实现并 AC 的方案。

```java
class Solution {
    public boolean verifyTreeOrder(int[] postorder) {
        int n = postorder.length;
        boolean rightSubtree;

        for (int i = 0; i < n; i++) {
            rightSubtree = false;
            for (int j = 0; j < i; j++) {
                if (postorder[j] > postorder[i]) {
                    rightSubtree = true;
                } else if (rightSubtree) {
                    return false;
                }
            }
        }

        return true;
    }
}
```

# 实现三：单调栈

```java
class Solution {
    public boolean verifyTreeOrder(int[] postorder) {
        Deque<Integer> stack = new ArrayDeque<>();
        int root = Integer.MAX_VALUE;

        // 倒序扫描
        for (int i = postorder.length - 1; i >= 0; i--) {
            int cur = postorder[i];
            // 左子树的值必须小于根
            if (cur > root) return false;

            // 找到左子树边界后，更新 root
            while (!stack.isEmpty() && stack.peek() > cur) {
                root = stack.pop();
            }

            stack.push(cur);
        }
        return true;
    }
}
```

