题目简述：

> 给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
>
> 请你找出符合题意的 **最短** 子数组，并输出它的长度。
>
> **进阶：**你可以设计一个时间复杂度为 `O(n)` 的解决方案吗？

题目链接：[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

# 基数排序

## 思路

你就说对于 32 位有符号整数，基数排序算不算 $O(n)$ 时间复杂度的方案吧。

对 `nums` 使用基数排序，然后对比排序后数组与原数组，考虑两个相向双指针，一个指向首位、一个指向末位，两个指针同时向中间聚拢，但分别在发现首个排序后数组与原数组同索引上值不相同时停止移动指针。当两个指针同时停下时，两个指针范围内的子数组就是最短需要排序以使得全局有序的子数组。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int[] sorted = sort(nums);
        int i = 0;
        int j = nums.length - 1;

        while (i < nums.length) {
            if (nums[i] != sorted[i]) break;
            i++;
        }

        while (j >= 0) {
            if (nums[j] != sorted[j]) break;
            j--;
        }

        return Math.max(j - i + 1, 0);
    }

    private int[] sort(int[] nums) {
        int n = nums.length;
        int[] sorted = nums.clone();
        int[] tmp = new int[n];
        int[] buckets = new int[256 + 1];

        for (int i = 0; i < n; i++) sorted[i] ^= Integer.MIN_VALUE;

        for (int i = 0; i < 4; i++) {
            Arrays.fill(buckets, 0);

            for (int j = 0; j < n; j++) {
                buckets[(sorted[j] >>> 8 * i & 0xff) + 1]++;
            }

            for (int k = 0; k < 256; k++) {
                buckets[k + 1] += buckets[k];
            }

            for (int j = 0; j < n; j++) {
                int index = buckets[sorted[j] >>> 8 * i & 0xff]++;
                tmp[index] = sorted[j];
            }

            int[] swap = sorted;
            sorted = tmp;
            tmp = swap;
        }

        for (int i = 0; i < n; i++) sorted[i] ^= Integer.MIN_VALUE;
        return sorted;
    }
}
```

# 单调栈

## 思路

利用单调栈，找出每个元素的下一个严格更小元素以及上一个严格更大元素。

假设元素 `nums[i]` 的下一个严格更小元素为 `nums[j]`（NLE），意味着这段区间是局部无序的，那么我们就可以确定目标子数组至少要包含 `nums[i]` 至 `nums[j]` 的全部元素才可能使目标子数组翻转后恰可能使得数组全局有序；同理，假设元素 `nums[i]` 的上一个严格更大元素为 `nums[j]`（PGE），意味着这段区间也是局部无序的，于是我们可以确定目标子数组至少应包含 `nums[j]` 至 `nums[i]` 的全部元素才可能使目标子数组翻转后恰可能使得数组全局有序。

所以我们一共进行三次扫描：

1. 第一次扫描确定 NLG；
2. 第二次扫描确定 PGE；
3. 第三次扫描确定目标子数组的最小范围。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int[] nle = new int[n];  // next less element
        int[] pge = new int[n];  // prev gter emement
        Arrays.fill(pge, -1);

        int[] stack = new int[n];
        int top = -1;

        // NLE
        for (int i = 0; i < n; i++) {
            while (top > -1 && nums[i] < nums[stack[top]]) {
                nle[stack[top--]] = i;
            }
            stack[++top] = i;
        }

        top = -1;

        // PGE
        for (int i = n - 1; i >= 0; i--) {
            while (top > -1 && nums[i] > nums[stack[top]]) {
                pge[stack[top--]] = i;
            }
            stack[++top] = i;
        }

        // search result
        int start = n - 1;
        int end = 0;
        for (int i = 0; i < n; i++) {
            if (nle[i] != 0) {
                start = Math.min(start, i);
                end = Math.max(end, nle[i]);
            }
            if (pge[i] != -1) {
                start = Math.min(start, pge[i]);
                end = Math.max(end, i);
            }
        }

        if (n <= 1) return 0;  // 如果局部无序则子数组长度至少为 2，但 n = 1 时除外，单独处理

        return Math.max(end - start + 1, 0);
    }
}
```

# 双指针

## 思路

进行两次遍历扫描，分别是从左往右扫描与从右往左扫描。

从左往右扫描：

- 维护已扫描元素最大值变量 `maxVal`；
- 若发现 `nums[i] < maxVal`，说明 `nums[i]` 在错误的位置上（它比前面某个更大的数还要小），故需要将右边界 `right` 更新为 `i`；
- 最终 `right` 即为最右边的异常位置。

从右往左扫描：

- 维护已扫描元素最小值变量 `minVal`；
- 若发现 `nums[i] > minVal`，说明 `nums[i]` 在错误的位置上（它比后面某个更小的数还要大），故需要将左边界 `left` 更新为 `i`。
- 最终 `left` 即为最左边的异常位置；

最终 `left` 与 `right` 分别为目标子数组的起始位置与结束位置。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int left = 0;
        int right = -1;

        int maxVal = nums[0];
        for (int i = 1; i < n; i++) {
            if (nums[i] < maxVal) {
                right = i;
            } else {
                maxVal = nums[i];
            }
        }

        int minVal = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > minVal) {
                left = i;
            } else {
                minVal = nums[i];
            }
        }

        if (right == -1) return 0;

        return Math.max(right - left + 1, 0);
    }
}
```

