题目简述：

> 一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？
>
> ##### **输入描述:**
>
> > 第一行输入一个N，表示栈中元素的个数
> > 第二行输入N个整数 $a_i$ 表示栈顶到栈底的各个元素
>
> ##### **输出描述:**
>
> > 输出一行表示排序后的栈中栈顶到栈底的各个元素。

题目链接：[[编程题]用一个栈实现另一个栈的排序](https://www.nowcoder.com/questionTerminal/ff8cba64e7894c5582deafa54cca8ff2)

# 思路

用栈模拟插入排序，维护栈 `s2` 有序：

- 从 `s1` 中弹出栈顶，如果被弹出的元素大于 `s2` 的栈顶，则将其压入 `s2`；
- 否则，若被弹出的元素小于 `s2` 的栈顶，则不断弹出 `s2` 的栈顶并压入 `s1`，直到 `s2` 的栈顶小于该元素。

> 我最初想到模拟选择排序去了，显然这不适合双栈。还是模拟排序更好。

# 代码

算法的最坏时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextLine()) { // 注意 while 处理多个 case
            int n = Integer.parseInt(in.nextLine());
            String[] strs = in.nextLine().split(" ");

            Deque<Integer> s1 = new ArrayDeque<>();
            Deque<Integer> s2 = new ArrayDeque<>();

            for (int i = strs.length - 1; i >= 0; i--) {
                s1.push(Integer.parseInt(strs[i]));
            }

            while (!s1.isEmpty()) {
                int tmp = s1.pop();

                while (!s2.isEmpty() && s2.peek() > tmp) {
                    s1.push(s2.pop());
                }

                s2.push(tmp);
            }

            while (!s2.isEmpty()) {
                System.out.print(s2.pop());
                if (!s2.isEmpty()) System.out.print(" ");
            }
        }
    }
}
```

