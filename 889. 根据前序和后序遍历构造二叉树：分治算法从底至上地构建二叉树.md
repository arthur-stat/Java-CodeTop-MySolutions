题目简述：

> 给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。
>
> 如果存在多个答案，您可以返回其中 **任何** 一个。

题目链接：[889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

# 思路

本问题与 [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) 和 [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) 是完全类似的，可以先阅读我关于这两个问题撰写的题解后再尝试本问题。

关键还是利用前序遍历和后序遍历的特点以确定每个节点的左右子树，进而考虑分治算法。

前序遍历的顺序是 “中 -> 左 -> 右”，后序遍历的顺序是 “左 -> 右 -> 中”，

我们如何找到左右子树的分界点呢？利用前序遍历的特点，可以知道如果左子树存在，那么左子树也满足 “中 -> 左 -> 右” 的递归结构，因此根节点的左子节点就是前序遍历中根节点的下一个节点；同理，利用后序遍历的特点，可以知道如果右子树存在，那么右子树也满足 “左 -> 右 -> 中” 的递归结构，因此根节点的左子节点就是后序遍历中根节点的上一个节点。

现在的问题是：如何确定左右子树是否存在？这也很简单：假设只存在一棵子树，不妨假设只存在左子树，那么根节点先序遍历右侧的节点与根节点后序遍历左侧的节点必然均为左子树的根节点，因此两节点的值相同，但题干明确说明了所有节点的值不相同，因此凭此就可以断言此时只存在左子树。仅存在右子树的情况同理，总之我们可以确定这种情况下只存在一棵子树。由于前序遍历与后序遍历的子树部分顺序均为 “左 -> 右”，因此单凭前序遍历与后序遍历结果我们是无法唯一确定究竟存在哪棵子树的，这也是为什么题目表示 “如果存在多个答案，您可以返回其中任何一个”，那么我们就都统一认为此时存在左子树好了。

如果是中序遍历与另一种遍历的组合，就可以唯一确定一棵树了，这就是 [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) 和 [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) 的情况。

借此划分出后，就可以递归地从下至上地构造子树了。

# 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    private int[] preorder;
    private int[] postorder;

    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        this.preorder = preorder;
        this.postorder = postorder;
        int n = preorder.length;
        return dfs(0, n - 1, 0, n - 1);
    }

    private TreeNode dfs(int pre_i, int pre_j, int post_i, int post_j) {
        if (pre_i > pre_j || post_i > post_j) return null;

        TreeNode root = new TreeNode(preorder[pre_i]);
        if (pre_i == pre_j) return root;

        int val_l = preorder[pre_i + 1];    // 左子节点的值
        int val_r = postorder[post_j - 1];  // 右子节点的值

        if (val_l == val_r) {
            root.left = dfs(pre_i + 1, pre_j, post_i, post_j - 1);
            return root;
        }

        int pre_l_end = pre_i + 1;
        while (preorder[pre_l_end + 1] != val_r) pre_l_end++;

        int post_r_start = post_j - 1;
        while (postorder[post_r_start - 1] != val_l) post_r_start--;

        root.left = dfs(pre_i + 1, pre_l_end, post_i, post_r_start - 1);
        root.right = dfs(pre_l_end + 1, pre_j, post_r_start, post_j - 1);

        return root;
    }
}
```

