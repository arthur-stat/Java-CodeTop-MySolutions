题目简述：

> 给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。
>
> 返回 *你可以获得的最大乘积* 。

题目链接：[343. 整数拆分](https://leetcode.cn/problems/integer-break/)

# 动态规划

标准的动态规划的时间复杂度为 $O(n^2)$，相较于贪心算法并不是本问题的最优解。

## 思路

直觉上，本问题具有无后效性，可能可以尝试动态规划。

定义状态 $dp[n]$ 为拆分 $n$ 我们能获得的最大乘积，假设 $n$ 能被拆分为 $a+b$，且 $dp[a]$ 与 $dp[b]$ 已知，那么无论 $a$、$b$ 又能被进一步如何拆分，根据定义，$dp[a]$ 必然是 $a$ 被进一步拆分能获得的最大乘积，$dp[b]$ 必然是 $b$ 被进一步拆分能获得的最大乘积。遍历所有可能的 $(a,b)$，如果 $a,b$ 能被进一步拆分，根据正整数乘法的性质与 $dp$ 的定义，
$$
dp[n]=\max\big\{dp[n-a]\times dp[a]:0<a<n\big\}
$$
考虑 $a,b$ 中的一方不应再拆分，不妨设 $a$ 不应再被拆分，则
$$
dp[n]=\max\big\{dp[n-a]\times a:0<a<n\big\}
$$
最后若 $a,b$ 均不应再被拆分，则
$$
dp[n]=\max\big\{(n-a)\times a:0<a<n\big\}
$$
综上所述，
$$
dp[n]=\max\Big\{\max\big\{dp[n-a]\times dp[a],\ dp[n-a]\times a\ ,(n-a)\times a\big\}:0<a<n\Big\}
$$
初始化 $dp[1]=1$。

## 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            int tmp = 0;
            for (int j = 1; j < i; j++) {
                tmp = Math.max((i - j) * j, Math.max(dp[i - j] * j, Math.max(tmp, dp[j] * dp[i - j])));
            }
            dp[i] = Math.max(tmp, i - 1);
        }

        return dp[n];
    }
}
```

当然这份代码可以进一步改良，例如利用对称性使 $j$ 只遍历到 $i$ 的一半就结束——但在 `2 <= n <= 58` 的数据范围下影响很小。如果数据范围很大，DP 的 $O(n^2)$ 时间复杂度也让这些小改良显得微不足道，因此没有太大必要。

# 贪心算法

贪心算法可以做到 $O(1)$ 的时间复杂度，但需要先证明一个引理。

## 思路

引理：当 $n>4$，拆分 $n=3+(n-3)$ 将使乘积局部与全局最大化。当 $n$ 无法拆分出 $3$ 或拆分 $3$ 将导致剩余常数项 $1$，则拆分 $n=2+(n-2)$ 将使乘积局部与全局最大化。
