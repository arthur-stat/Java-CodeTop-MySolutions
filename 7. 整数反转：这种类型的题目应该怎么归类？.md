题目简述：

> 给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。
>
> 如果反转后整数超过 32 位的有符号整数的范围 `[−2^(31), 2^(31) − 1]` ，就返回 0。
>
> **假设环境不允许存储 64 位整数（有符号或无符号）。**

题目链接：[7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

# 思路

可以从左至右构建新数，以 $123$ 为例，

1. 首先对 $123$ 应用整数除法除 $100$ 得到 $1$，那么 $1$ 就是新数字的个位，然后 $123$ 减去 $1\times100$ 得到 $23$；
2. 接着对 $23$ 应用整数除法除 $10$ 得到 $2$，那么 $2$ 就是新数字的十位，然后 $23$ 减去 $2\times10$ 得到 $3$；
3. 再对 $3$ 应用整数除法除 $1$ 得到 $3$，那么 $3$ 就是新数的百位。

最终，新数字为 $1\times1+2\times10+3\times100=321$。

也可以从右至左构建新数，依然以 $123$ 为例，

1. 首先计算 `123 % 10` 得到 $3$，计临时新数为 $0\times10+3=3$，然后对 $123$ 应用整数除法除 $10$ 得到 $12$；
2. 接着计算 `12 % 10` 得到 $2$，计临时新数为 $3\times10+2=32$，然后对 $12$ 应用整数除法除 $10$ 得到 $1$；
3. 最后计算 `1 % 10` 得到 $1$，新数为 $32\times10+1=321$。

这样的好处是不用提前计算 `x` 的长度。

留下来的小问题仅仅是：如何高效判断反转数字是否会溢出。

---

我们考虑一个稍简单的情况，假设 `x` 为 7 位有符号整数，那么 `x` 的取值范围为 $[-128,128)$。显然，$127$ 是允许的，但 $127$ 的反转 $721$ 将溢出。由于 $n$ 位数反转后仍是 $n$ 位数，因此仅当 `x` 恰在十进制下数码位数量达到 32 位有符号整数的上限时才可能溢出，那么我们可以针对这一情况时单独判断反转是否将造成溢出：`x` 反转后的每一个数码都必须小于等于相应符号下到 32 位有符号整数上限的数字部分的数码，我们才认为不会溢出，否则视为溢出。

---

鉴于<u>当且仅当考虑除符号外的最高位时正数的加运算以及反转操作才可能溢出</u>，因此如果从左至右构建新数，在 Java 中其实我们有更好的方案判断是否溢出：

- 在最后一次相加开始以前，新数都不可能溢出，因为我们的操作都是低位整数的相加，而且如果 `x` 长度根本没有达到 32 位有符号整数长度的上限，那么反转根本就不可能溢出；
- 两正数相加，一旦溢出，结果必然为一个负数。

这两点向我们保证了，在最后一步判别新数是否为负即可等价判别新数是否溢出。

---

在 C/C++ 中，整数溢出是未定义行为。这种情况下只能对 `x` 从右至左构建新数，并且在每次构建时判断是否可能溢出。

# 代码

我们像 C/C++ 那样编写算法，不使用 Java 整数溢出的回绕特性。

这里在溢出判断有一些技巧。

```java
class Solution {
    public int reverse(int x) {
        

        int res = 0;
        int y = Math.abs(x);

        while (y > 0) {
            int number = y % 10;

            // 提前判断是否可能溢出
            if (res > Integer.MAX_VALUE / 10) return 0;
            if (res * 10 > Integer.MAX_VALUE - number) return 0;

            res = res * 10 + number;
            y /= 10;
        }

        // 不存在一个 int 反转后为 Integer.MIN_VALUE，即 -2147483648，否则该数针对 -1 * res 的逻辑需要单独处理
        return x < 0 ? -1 * res : res;
    }
}
```

会将溢出判断条件改为

```c++
if (res > INT_MAX / 10 || (res == INT_MAX / 10 && number > 7)) return 0;
if (res < INT_MIN / 10 || (res == INT_MIN / 10 && number < -8)) return 0;
```

即为该问题的经典的 C++ 写法。
