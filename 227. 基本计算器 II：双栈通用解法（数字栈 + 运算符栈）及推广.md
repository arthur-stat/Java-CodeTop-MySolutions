题目简述：

> 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。
>
> 整数除法仅保留整数部分。
>
> 你可以假设给定的表达式总是有效的。所有中间结果将在 `[-231, 231 - 1]` 的范围内。
>
> **注意：**不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。
>
> **提示：**
>
> - `1 <= s.length <= 3 * 105`
> - `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
> - `s` 表示一个 **有效表达式**
> - 表达式中的所有整数都是非负整数，且在范围 `[0, 231 - 1]` 内
> - 题目数据保证答案是一个 **32-bit 整数**

题目链接：[227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

# 思路

考虑两个栈，一个栈用作***数字栈***，另一个栈用作***运算符栈***。

如果扫描到运算符，意味着此时运算符左侧的第一个数字已构建完毕，并且其值为 `tmp`。此时检查栈顶，若栈顶是高优先级的 `*` 与 `/`，则将 `tmp` 与数字栈栈顶——即该高优先级运算符左侧的第一个数字进行运算，于是我们就将高优先级运算 `a * b` 或 `a / b` 合并为了一个结果数字。更新数字栈和运算符栈，分别弹出已经使用过的栈顶，然后将结果数字压入到数字栈中。接着将新数字与新运算符（当前扫描到的运算符）分别压入数字栈与运算符栈。其中，如果此前运算符栈栈顶并非高优先级元素，则新数字就是 `tmp`，这是我们刚刚构建出来的数字；否则新数字为合并后的计算结果，因为我们让构建出来的数字立即结合高优先级运算符进行计算了。

这样，（在不考虑边界条件的情况下）最终结果已不存在高优先级运算符 `*` 与 `/`，因为我们在遍历时已经将他们合并为结果数字了，于是栈中剩下的表达式便只有低优先级的 `+` 与 `-`——均为同一优先级，从左至右依次计算即可。

其中 `s = s + "+0";` 是为了避免单独处理边界情况，因为当匹配到运算符时才向前进行检查运算符栈栈顶是否为高优先级运算符、是否需要合并高优先级运算。

> **推广：多优先级运算符**
>
> 该算法能够自然地推广至多级运算符优先级的通用场景。其核心思想是：当扫描到一个新运算符时，不再只检查固定的高优先级符号，而是循环比较运算符栈顶与当前运算符的优先级和结合性。
>
> 只要**栈顶运算符的优先级高于当前运算符**，或**二者优先级相同但当前运算符为左结合**，就**立即执行弹栈并进行一次规约**。该过程持续进行，直到遇到左括号或条件不再满足，从而保证子表达式按照正确的优先级和结合性动态合并。最终，通过在末尾追加一个虚拟的最低优先级运算符，可以触发栈中残留运算符的全部规约，从而实现对任意多优先级中缀表达式的统一求值。
>
> 最终，栈中只会剩下最低优先级的一类运算符，对于同一优先级的运算，从左至右进行计算即可。
>
> 对于括号，匹配到左括号时将其视为最低优先级的哨兵直接压入运算符栈，匹配到右括号时便不断弹出运算符栈进行规约，直到弹出与之匹配的左括号。

---

除了双栈以外，逆波兰表达式也是一个很好的方案，这一方案的内容请移步至我对 [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 问题写的解析。

# 代码

```java
class Solution {
    public int calculate(String s) {
        s = s + "+0";
        int n = s.length();
        int tmp = 0;
        Deque<Integer> num = new ArrayDeque<>();
        Deque<Character> op = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') {
                tmp = tmp * 10 + (c - '0');
            } else if (c != ' ') {
                if (!op.isEmpty()) {
                    if (op.peek() == '*') {
                        tmp *= num.pop();
                        op.pop();
                    } else if (op.peek() == '/') {
                        tmp = num.pop() / tmp;
                        op.pop();
                    }
                }

                num.push(tmp);
                op.push(c);
                tmp = 0;
            }
        }

        num.push(tmp);

        int res = num.removeLast();
        while (!num.isEmpty()) {
            if (op.removeLast().equals('+')) {
                res += num.removeLast();
            } else {
                res -= num.removeLast();
            }
        }

        return res;
    }
}
```
