题目简述：

> 给定一个整数数组 `asteroids`，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。
>
> 对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。
>
> 找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。

题目链接：[735. 小行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

# 思路

解决本问题的关键是要意识到需要使用栈。

我也不知道该怎么解释思路，大概就是，如果一颗行星可以畅通无阻地向左移动，那么我们就把他移除、加入结果集；如果一个行星是向右移动的，我们暂时不知道他究竟能不能畅通无阻地向右移动，因此把他加入临时集。

然后，如果一个行星应向左移动但临时集不为空，意味着行星并不能畅通无阻地向左移动，因为此时他的左侧存在尚未被移除而只是加入临时集的行星，因此我们取出临时集中最靠近该左移动行星的一颗行星，比较两者并判断谁会被摧毁，最后再按情况讨论结果。

如何确保临时集中取出的右移动行星是离左移动行星最近的行星呢？这就是为什么我们考虑栈作为临时集的数据结构：栈的 LIFO 性质恰保证了最后被加入临时集的行星——即离左移动行星最近的已扫描行星，将会被第一个取出。

最后，结果集与临时集（栈）中剩下的元素就是碰撞后剩下的所有小行星，其中结果集中的行星均是向左移动的，临时集中的行星均是向右移动的。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Deque<Integer> right = new ArrayDeque<>();
        List<Integer> left = new ArrayList<>();

        main_loop:
        for (int size : asteroids) {
            if (size > 0) {
                right.push(size);
            } else {
                int leftSize = -size;
                while (!right.isEmpty()) {
                    int rightSize = right.peek();
                    if (leftSize > rightSize) {
                        right.pop();
                    } else if (leftSize == rightSize) {
                        right.pop();
                        continue main_loop;
                    } else {
                        continue main_loop;
                    }
                }
                left.add(leftSize);
            }
        }

        int[] res = new int[left.size() + right.size()];
        int count = 0;
        for (int size : left) res[count++] = -size;
        while (!right.isEmpty()) res[count++] = right.removeLast();

        return res;
    }
}
```

