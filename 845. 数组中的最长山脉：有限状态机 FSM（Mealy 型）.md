题目简述：

> 把符合下列属性的数组 `arr` 称为 **山脉数组** ：
>
> - `arr.length >= 3`
> - 存在下标 `i`（`0 < i < arr.length - 1`），满足
>   - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
>   - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`
>
> 给出一个整数数组 `arr`，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 `0` 。

题目链接：[845. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/)

# 思路

看到这个问题的描述，我想到可能可以考虑动态规划，毕竟 “最长的 xxx 子数组” 通常都具有最优子结构。

在尝试设计状态时，稍微一细想，我发现只需要维护三个状态就行了，那么本问题实际上就是一个 Mealy 型三状态 FSM 模型。

设计状态：

1. 处于山脉爬坡段
2. 处于山脉下坡段
3. 非法段，包括：高原、平原以及高原后的首个下坡段

一句话概括：即将开始爬坡时开始记录山脉累积长度，在下坡结束时结算山脉长度，如果处于非法段则重置山脉长度。

这个想法是非常直观且自然的，而且算法实现起来性能开销上也是最优的一档。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int longestMountain(int[] arr) {
        int n = arr.length;
        if (n < 3) return 0;
        /* 即将开始爬坡时开始记录山脉累积长度，在下坡结束时结算山脉长度，如果处于非法段则重置山脉长度 */
        int res = 0;
        int count = 0;

        /* 状态参数，0：刚才在山脉爬坡段，1：刚才在山脉下坡段，2：刚才在平地/高原或处于高原的下坡段 */
        int state;
        if (arr[0] < arr[1]) {
            state = 0;
            count = 1;
        } else if (arr[0] > arr[1]) {
            state = 2;
        } else {
            state = 2;
        }

        for (int i = 1; i < n - 1; i++) {
            switch (state) {

                case 0: {
                    if (arr[i] < arr[i + 1]) {
                        count++;
                    } else if (arr[i] > arr[i + 1]) {
                        state = 1;
                        count++;
                    } else {
                        state = 2;
                        count = 0;
                    }
                    break;
                }

                case 1: {
                    if (arr[i] < arr[i + 1]) {
                        count++;
                        res = Math.max(res, count);
                        state = 0;
                        count = 1;
                    } else if (arr[i] > arr[i + 1]) {
                        count++;
                    } else {
                        count++;
                        res = Math.max(res, count);
                        state = 2;
                        count = 0;
                    }
                    break;
                }

                case 2: {
                    if (arr[i] < arr[i + 1]) {
                        state = 0;
                        count = 1;
                    } else if (arr[i] > arr[i + 1]) {
                        state = 2;
                        count = 0;
                    }
                    break;
                }
            }
        }

        if (state == 1 && arr[n - 2] > arr[n - 1]) {
            res = Math.max(res, count + 1);
        }

        return res;
    }
}
```

