题目简述：

> 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` 。每个拨轮可以自由旋转：例如把 `'9'` 变为 `'0'`，`'0'` 变为 `'9'` 。每次旋转都只能旋转一个拨轮的一位数字。
>
> 锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。
>
> 列表 `deadends` 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
>
> 字符串 `target` 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 `-1` 。

题目链接：[752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/)

# 思路

本质上是状态图的 BFS 最短路问题。

从 “你需要给出解锁需要的最小旋转次数” 可以知道应该考虑 BFS 最短路，既然是 BFS，那么就需要设计队列——于是自然可以引出算法的具体设计了。

# 代码

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        if (target.equals("0000")) return 0;

        Set<String> deadendSet = new HashSet<>();
        for (String d : deadends) {
            deadendSet.add(d);
        }
        if (deadendSet.contains("0000")) return -1;

        Deque<int[]> deque = new ArrayDeque<>();
        Set<String> visited = new HashSet<>();
        deque.offer(new int[]{0, 0, 0, 0});
        visited.add("0000");
        int num = 1;

        int order = 0;
        while (!deque.isEmpty()) {
            int[] c = deque.poll();
            num--;

            for (int i = 0; i < 4; i++) {
                int cc = c[i];

                c[i] = cc == 9 ? 0 : cc + 1;
                String s = build(c);
                if (s.equals(target)) return order + 1;
                if (!deadendSet.contains(s) && !visited.contains(s)) {
                    deque.offer(c.clone());
                    visited.add(s);
                }

                c[i] = cc == 0 ? 9 : cc - 1;
                s = build(c);
                if (s.equals(target)) return order + 1;
                if (!deadendSet.contains(s) && !visited.contains(s)) {
                    deque.offer(c.clone());
                    visited.add(s);
                }

                c[i] = cc;
            }

            if (num == 0) {
                order++;
                num = deque.size();
            }
        }

        return -1;
    }

    private String build(int[] numbers) {
        return "" + numbers[0] + numbers[1] + numbers[2] + numbers[3];
    }
}
```

