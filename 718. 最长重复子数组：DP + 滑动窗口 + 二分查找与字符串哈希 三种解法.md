题目简述：

> 给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

题目链接：[718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

# 动态规划

这个问题作为动态规划问题是很典型的。

动态规划是最容易编程的，难度几乎没有，相比之下第二种方案滑动窗口不易处理好边界条件，第三种方案二分查找更难实现，尽管他们的性能都强于动态规划。

## 思路

设 $dp[i][j]$ 表示以 `nums1[i]` 与 `nums2[j]` 结尾的最长公共子数组长度，则
$$
dp[i][j]=\left\{\begin{align}
&0,&&\text{if \ \ nums1}[i]\neq\text{nums2}[j]\\\\
&dp[i-1][j-1]+1,&&\text{if \ \ nums1}[i]=\text{nums2}[j]
\end{align}\right.
$$
为方便处理 $dp[i-1][j-1]$，额外在首行前添加哨兵行、在首列前添加哨兵列，于是设 $dp[i][j]$ 表示以 `nums1[i-1]` 与 `nums2[j-1]` 结尾的最长公共子数组长度，

Base case：
$$
dp[i][0]=dp[0][j]=0
$$
最终结果：
$$
\text{res}=\max_{i,j}dp[i][j]
$$

## 基本代码

直接按照以上分析的逻辑实现即可，时间复杂度为 $O(mn)$，空间复杂度为 $O(mn)$。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int res = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        // dp[i][0] = dp[0][j] = 0

        for (int i = 1; i < nums1.length + 1; i++) {
            for (int j = 1; j < nums2.length + 1; j++) {
                dp[i][j] = nums1[i - 1] == nums2[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
                res = Math.max(res, dp[i][j]);
            }
        }

        return res;
    }
}
```

## 滚动数组改进

利用滚动数组减小空间开销，时间复杂度为 $O(mn)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int res = 0;
        int[] dpOld = new int[nums2.length + 1];
        int[] dpNew = new int[nums2.length + 1];

        for (int i = 1; i < nums1.length + 1; i++) {
            for (int j = 1; j < nums2.length + 1; j++) {
                dpNew[j] = nums1[i - 1] == nums2[j - 1] ? dpOld[j - 1] + 1 : 0;
                res = Math.max(res, dpNew[j]);
            }
            int[] tmp = dpOld;
            dpOld = dpNew;
            dpNew = tmp;
        }

        return res;
    }
}
```

# 滑动窗口

这个问题还可以用滑动窗口的办法解决。

## 思路

这里直接引用题解[滑动窗口解法](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solutions/28583/wu-li-jie-fa-by-stg-2/)中的图片，简洁直观：

![滑动窗口](images/718.gif)

也可以参考题解[java动态规划和滑动窗口解决](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solutions/310179/javadong-tai-gui-hua-jie-jue-qi-shi-jiu-shi-zui-ch/)中的示意图：

![示意图](images/718_1.png)

这个方法巧妙利用了***子数组必定在两个原数组中连续***的性质。具体需要注意的点见代码注释。

## 代码

滑动窗口的时间复杂度仍为 $O(mn)$，但空间复杂度为 $O(1)$。

```java
class Solution {
    int[] nums1;
    int[] nums2;

    public int findLength(int[] nums1, int[] nums2) {
        // 为方便处理，这里确保 nums1 是最长的数组
        if (nums1.length >= nums2.length) {
            this.nums1 = nums1;
            this.nums2 = nums2;
        } else {
            this.nums1 = nums2;
            this.nums2 = nums1;
        }
        int m = this.nums1.length, n = this.nums2.length, maxLength = 0;

        for (int offset = -n + 1; offset < m; offset++) {
            int start1 = Math.max(0, offset);
            int start2 = Math.max(0, -offset);
            int currentLen = Math.min(m - start1, n - start2);
            if (currentLen <= maxLength) continue;
            int currentMax = window(start1, start2, currentLen);
            maxLength = Math.max(maxLength, currentMax);
        }

        return maxLength;
    }

    /**
     * 获取滑动窗口内两个子数组的最长公共子数组长度，即示意图的红框部分
     *
     * @param n1  nums1 子数组起始索引
     * @param n2  nums2 子数组起始索引
     * @param len nums1 与 nums2 子数组的长度
     * @return 返回滑动窗口内两个子数组的最长公共子数组长度
     */
    private int window(int n1, int n2, int len) {
        int current = 0, maxLen = 0;
        for (int k = 0; k < len; k++) {
            if (nums1[n1 + k] == nums2[n2 + k]) {
                current++;
                maxLen = Math.max(maxLen, current);
            } else {
                current = 0;
            }
        }
        return maxLen;
    }
}
```

# 二分查找 + 字符串哈希

## 思路

对每个固定长度 $L$ 的子数组计算多项式哈希，定义
$$
H=(a_iB^{L-1}+a_{i+1}B^{L-2}+\cdots+a_{i+L-1})\mod{M}
$$
其中 $B$ 为所选取的基数，$M$ 为足够大的质数，例如经典的 `1_000_000_007L` 与 `1_000_000_009L`，应满足 $1<B<M$。通常 $B$ 会选择一个较大的随机数。

如果希望降低哈希碰撞的概率，可用考虑双哈希校验。

如果存在一个长度为 $L$ 的公共子数组，那么必然存在 $\forall L'<L$ 长度的公共子数组；如果不存在一个长度为 $L$ 的公共子数组，那么 $\forall L'>L$ 长度的公共子数组均不存在。此处存在单调性，因此可以利用二分查找算法迅速找到分界点。

## 代码

算法的时间复杂度为 $O\big((n+m)\cdot\log\min(n,m)\big)$，空间复杂度为 $O(m+n)$。

```java
class Solution {
    // 两个大模数（质数），以及两个基数（< 对应模数）
    static final long M1 = 1_000_000_007L;
    static final long M2 = 1_000_000_009L;
    static final long B1 = 911382323L;     // < M1
    static final long B2 = 972663749L;     // < M2

    public int findLength(int[] A, int[] B) {
        int n = A.length, m = B.length;
        int maxLen = Math.max(n, m);

        // 预计算幂
        long[] pow1 = new long[maxLen + 1];
        long[] pow2 = new long[maxLen + 1];
        pow1[0] = 1; pow2[0] = 1;
        for (int i = 1; i <= maxLen; i++) {
            pow1[i] = (pow1[i - 1] * B1) % M1;
            pow2[i] = (pow2[i - 1] * B2) % M2;
        }

        // 前缀哈希（h[i] 表示前 i 个元素的哈希）
        long[] h1A = buildPrefix(A, B1, M1);
        long[] h2A = buildPrefix(A, B2, M2);
        long[] h1B = buildPrefix(B, B1, M1);
        long[] h2B = buildPrefix(B, B2, M2);

        // 二分长度
        int low = 0, high = Math.min(n, m);
        while (low < high) {
            int mid = (low + high + 1) >>> 1;
            if (check(mid, h1A, h2A, h1B, h2B, pow1, pow2)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    // 构建前缀哈希
    private long[] buildPrefix(int[] arr, long B, long M) {
        long[] h = new long[arr.length + 1];
        for (int i = 0; i < arr.length; i++) {
            long v = arr[i];
            h[i + 1] = (h[i] * B + v) % M;
        }
        return h;
    }

    // 取子段 [l, r) 的哈希
    private long subHash(long[] pref, long[] pow, int l, int r, long M) {
        long res = (pref[r] - (pref[l] * pow[r - l]) % M);
        if (res < 0) res += M;
        return res;
    }

    // 检查是否存在长度为 L 的公共子数组
    private boolean check(int L,
                          long[] h1A, long[] h2A,
                          long[] h1B, long[] h2B,
                          long[] p1, long[] p2) {
        if (L == 0) return true;

        // 所有 A 的长度 L 子段哈希，放入集合
        HashSet<Long> set = new HashSet<>();
        for (int i = 0; i + L <= h1A.length - 1; i++) {
            long x1 = subHash(h1A, p1, i, i + L, M1);
            long x2 = subHash(h2A, p2, i, i + L, M2);
            long key = (x1 << 32) ^ x2;   // 把双哈希组合成一个 long 键
            set.add(key);
        }

        // 枚举 B 的长度 L 子段，是否与 A 有交集
        for (int j = 0; j + L <= h1B.length - 1; j++) {
            long y1 = subHash(h1B, p1, j, j + L, M1);
            long y2 = subHash(h2B, p2, j, j + L, M2);
            long key = (y1 << 32) ^ y2;
            if (set.contains(key)) return true;
        }
        return false;
    }
}
```

