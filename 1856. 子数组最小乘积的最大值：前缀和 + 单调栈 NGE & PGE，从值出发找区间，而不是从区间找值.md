题目简述：

> 一个数组的 **最小乘积** 定义为这个数组中 **最小值** **乘以** 数组的 **和** 。
>
> - 比方说，数组 `[3,2,5]` （最小值是 `2`）的最小乘积为 `2 * (3+2+5) = 2 * 10 = 20` 。
>
> 给你一个正整数数组 `nums` ，请你返回 `nums` 任意 **非空子数组** 的**最小乘积** 的 **最大值** 。由于答案可能很大，请你返回答案对 `109 + 7` **取余** 的结果。
>
> 请注意，最小乘积的最大值考虑的是取余操作 **之前** 的结果。题目保证最小乘积的最大值在 **不取余** 的情况下可以用 **64 位有符号整数** 保存。
>
> **子数组** 定义为一个数组的 **连续** 部分。

题目链接：[1856. 子数组最小乘积的最大值](https://leetcode.cn/problems/maximum-subarray-min-product/)

# 思路

要找滑动窗口的最小值，应考虑单调队列。要找最大或最小累和的子数组，应考虑 Kadane 算法，即动态规划。

可是，这两者却没有办法很好地结合起来以计算题干所定义的最小乘积，二者的计算分别是完全不同的过程。因此，我们必须转变思路。

> 暴力遍历就更不可取了，$O(n^2)$ 的时间复杂度在数据范围 `1 <= nums.length <= 10^5` 下一定会超时的。

---

我最初没有想到很好的思路，查看提示（考虑单调栈）的同时回顾了一下我以往的题解，想到了解法。

在 [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 问题中，我最初也是不知道如何高效求解，后来发现思路从一开始就误入歧途了，不应该尝试遍历所有区间然后去找每个区间的最小值的和，而应当根据每个值作为最小值去找对应的所有区间，这就需要利用单调栈以计算 NGE & PGE（或 NLE & PLE）。

本问题是类似地，我们不应暴力遍历所有区间寻找每个区间内元素的累和与最小值的乘积。观察问题，数组中所有元素均为正数且我们要求的是最大的最小乘积，这意味着对于一个区间，如果向两侧拓展后区间的最小值不会变得更小，那么区间的累和必然是会变得更大的，因此我们就可以得到一个更大的最小乘积。所以，类似 [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 的做法，我们应使用单调栈寻找每个值作为区间最小值的两侧的下一个更小元素（NLE & PLE），然后将两侧下一个更小元素作为端点形成的开区间内的元素计算累和，将该累和乘以最小值就得到了以当前元素作为区间最小元素的最小乘积。当我们遍历了每一个值作为对应区间内最小元素时并计算最大的最小乘积后，就能够得到全局的最小乘积。

当然，我们计算区间的累和时当然不能呆呆地逐个相加，这会带来大量的重复计算，最后最坏的总时间复杂度仍为 $O(n^2)$。对于部分和（区间和）的问题，当然离不开考虑前缀和数组，于是我们能够以 $O(1)$ 的时间复杂度得到区间上的累和。

有人说本问题是 [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 的「plus 版」。不，我认为不是这样的，虽然第 84 题也是经典的单调栈问题、也是经典的 NGE & PGE 问题，但我觉得那与本问题没有更多的共同点。本问题的思路更像 [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)，需要根据元素的值去找以该元素的值作为最小值的（尽可能长的）区间，而不是遍历所有区间再寻找每个区间的最小值。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int maxSumMinProduct(int[] nums) {
        int n = nums.length;
        long[] prefixSum = new long[n + 1];
        for (int i = 1; i <= n; i++) prefixSum[i] = prefixSum[i - 1] + nums[i - 1];

        int[] nle = new int[n];  // next less element
        int[] ple = new int[n];  // prev less element
        Arrays.fill(nle, n);
        Arrays.fill(ple, -1);
        int[] stack = new int[n];
        int top = -1;

        // NLE
        for (int i = 0; i < n; i++) {
            while (top > -1 && nums[stack[top]] > nums[i]) {
                nle[stack[top--]] = i;
            }
            stack[++top] = i;
        }

        // PLE
        top = -1;
        for (int i = n - 1; i >= 0; i--) {
            while (top > -1 && nums[stack[top]] > nums[i]) {
                ple[stack[top--]] = i;
            }
            stack[++top] = i;
        }

        // calculate res
        long res = 0;
        for (int i = 0; i < n; i++) {
            int l = ple[i];
            int r = nle[i];
            long sum = prefixSum[r] - prefixSum[l + 1];
            long sumMinProduct = nums[i] * sum;
            res = Math.max(res, sumMinProduct);
        }

        return (int) (res % (long) (1e9 + 7));
    }
}
```

