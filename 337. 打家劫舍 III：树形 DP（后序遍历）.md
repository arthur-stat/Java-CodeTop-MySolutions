题目简述：

> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。
>
> 除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。
>
> 给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

题目链接：[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

# 思路

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/) 和 [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/) 都是比较常规的动态规划问题，而本问题输入的数据结构不再是数组，而是一棵二叉树。

本问题是一个比较典型的树形 DP 问题。

无论是使用哈希表显式填 DP 表还是借助递归返回值隐式地填 DP 表（类似滚动数组），都推荐**后序遍历**，因为树是单向的，对于一个节点我们寻找其子节点很容易，而寻找其父节点则需要额外的逻辑处理。

# 哈希表 O(N) 空间开销实现

这种方法比较直观，类似于 [198. 打家劫舍](https://leetcode.cn/problems/house-robber/) 和 [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/) 中显式使用 `dp` 数组（而不是滚动数组隐含 `dp`），只不过这里我们用哈希表代替数组作为 DP 表。

算法的时间复杂度为 $O(N)$，空间复杂度为 $O(N+h)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    Map<TreeNode, Integer> dp;

    public int rob(TreeNode root) {
        // if (root == null) ...
        dp = new HashMap<>();
        dfs(root);
        return dp.get(root);
    }

    private void dfs(TreeNode node) {

        if (node.left != null) dfs(node.left);

        if (node.right != null) dfs(node.right);

        int loot1 = dp.getOrDefault(node.left, 0) + dp.getOrDefault(node.right, 0);
        int loot2 = node.val;
        if (node.left != null) loot2 += dp.getOrDefault(node.left.left, 0) + dp.getOrDefault(node.left.right, 0);
        if (node.right != null) loot2 += dp.getOrDefault(node.right.left, 0) + dp.getOrDefault(node.right.right, 0);

        dp.put(node, Math.max(loot1, loot2));
    }
}
```

# O(1) 空间开销实现

和滚动数组是相同的思想，只不过是针对树形 DP 的版本——因为我们考虑后序遍历时，计算当前节点的 dp 值只依赖于其子节点的状态，我们并不关心子节点的子节点、子节点的子节点的子节点等等其他节点的状态，所以并不需要显式用 HashMap 作为 DP 表存储所有节点的状态 / 结果，而可以直接利用递归的返回值传递子节点状态，进而计算当前节点的状态。

算法的时间复杂度为 $O(N)$，空间复杂度为 $O(h)$。

```java
class Solution {

    public int rob(TreeNode root) {
        int[] loot = dfs(root);
        return Math.max(loot[0], loot[1]);
    }

    // 返回 int[2]，内容分别为 选中该节点所能获得的最高金额 与 放弃该节点所能获得的最高金额
    private int[] dfs(TreeNode node) {

        if (node == null) return new int[]{0, 0};

        int[] l = dfs(node.left);
        int[] r = dfs(node.right);

        int[] loot = new int[2];
        loot[0] = node.val + l[1] + r[1];
        loot[1] = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);

        return loot;
    }
}
```

