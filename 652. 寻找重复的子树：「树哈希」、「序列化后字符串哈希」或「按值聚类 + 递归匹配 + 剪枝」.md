题目简述：

> 给你一棵二叉树的根节点 `root` ，返回所有 **重复的子树** 。
>
> 对于同一类的重复子树，你只需要返回其中任意 **一棵** 的根结点即可。
>
> 如果两棵树具有 **相同的结构** 和 **相同的结点值** ，则认为二者是 **重复** 的。

题目链接：[652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

# 按值聚类 + 递归比较 + 剪枝

## 思路

我们可以先将进行一次遍历，遍历过程中使用一张哈希表 `map` 将树值域中的值映射到节点集合，这一点是容易想到的，因为如果存在重复子树，那么首个必要条件就是两棵子树的根节点值必须相同。

然后，我们对相同值的根节点进行匹配，匹配算法可以考虑 DFS，匹配过程将验证两子树是否具有相同的结构与相同的对应节点值，如果匹配成功则将其中一个节点纳入到结果集中，同时在哈希表中删除其中一个节点以避免重复计数——题干明确要求 “对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可”。

相比下面的树哈希方案与序列化后的字符串哈希方案，本方案是确定性、充要的，能够保证结果一定是准确的。

## 基本实现

算法的最好情况时间复杂度为 $O(n^2)$，最坏情况时间复杂度（单链表）为 $O(n^3)$，空间复杂度为 $O(n)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        if (root == null) return null;

        Map<Integer, Set<TreeNode>> map = new HashMap<>();
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        int num = 1;
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            map.computeIfAbsent(node.val, key -> new HashSet<>()).add(node);
            num--;
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
            if (num == 0) num = queue.size();
        }

        List<TreeNode> res = new ArrayList<>();
        dfs(res, map, root);
        return res;
    }

    private boolean matches(TreeNode a, TreeNode b) {
        if ((a != null && b == null) || (a == null && b != null)) return false;
        if (a == null && b == null) return true;
        if (a.val != b.val) return false;
        return matches(a.left, b.left) && matches(a.right, b.right);
    }

    private void dfs(List<TreeNode> res, Map<Integer, Set<TreeNode>> map, TreeNode node) {
        if (node.left != null) dfs(res, map, node.left);
        if (node.right != null) dfs(res, map, node.right);

        Set<TreeNode> set = map.get(node.val);
        Iterator<TreeNode> iterator = set.iterator();
        while (iterator.hasNext()) {
            TreeNode other = iterator.next();
            if (other != node && matches(other, node)) {
                if (res.isEmpty() || res.getLast() != node) res.add(node);
                iterator.remove();
            } else if (other == node) {
                iterator.remove();
            }
        }
    }
}
```

## 剪枝实现

从正确性来说上述算法是可行的、没有错误的，但是面对一些测试用例会超时，典型的是例如二叉树退化为一个很长很长的值全部相同的单链表时，这种情况下按上述逻辑我们会进行许多次不必要的匹配。

这主要是因为上述算法是只要根节点的值相同就进行匹配，但没有利用上子树如果能匹配则还有一个必要条件就是两子树规模 `amount` 必须相等的信息。如果两子树规模的都不相等，那我们就完全没必要再调用匹配算法了，可以直接断言两子树不可能匹配，于是便实现了剪枝。这对于相同值单链表的情况能够极大地减少不必要的计算。

剪枝后的算法不会再报超时异常，完全能够 AC，时间开销在主流算法的开销内。

当然，下面的实现是在上述算法基础上经小小修改而来的，因此略显得臃肿，如果从一开始就考虑到这一剪枝策略，相信代码会更简洁。

算法的平均时间复杂度为 $O(n)$，最坏时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$，能够精确地比较子树结构与节点值。

```java
record Pair(TreeNode node, int amount) {}

class Solution {
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        if (root == null) return null;

        Map<Integer, Set<Pair>> valToSet = new HashMap<>();
        Map<TreeNode, Integer> nodeToAmount = new HashMap<>();
        postorder(valToSet, nodeToAmount, root);

        List<TreeNode> res = new ArrayList<>();
        dfs(res, valToSet, nodeToAmount, root);
        return res;
    }

    private int postorder(Map<Integer, Set<Pair>> valToSet, Map<TreeNode, Integer> nodeToAmount, TreeNode node) {
        if (node == null) return 0;
        int a1 = postorder(valToSet, nodeToAmount, node.left);
        int a2 = postorder(valToSet, nodeToAmount, node.right);
        valToSet.computeIfAbsent(node.val, key -> new HashSet<>()).add(new Pair(node, a1 + a2 + 1));
        nodeToAmount.put(node, a1 + a2 + 1);
        return a1 + a2 + 1;
    }

    private boolean matches(TreeNode a, TreeNode b) {
        if ((a != null && b == null) || (a == null && b != null)) return false;
        if (a == null && b == null) return true;
        if (a.val != b.val) return false;
        return matches(a.left, b.left) && matches(a.right, b.right);
    }

    private void dfs(List<TreeNode> res, Map<Integer, Set<Pair>> valToSet, Map<TreeNode, Integer> nodeToAmount, TreeNode node) {
        if (node.left != null) dfs(res, valToSet, nodeToAmount, node.left);
        if (node.right != null) dfs(res, valToSet, nodeToAmount, node.right);

        Set<Pair> set = valToSet.get(node.val);
        Iterator<Pair> iterator = set.iterator();
        int nodeAmount = nodeToAmount.get(node);
        while (iterator.hasNext()) {
            Pair other = iterator.next();

            if (other.amount() != nodeAmount) continue;

            if (other.node() != node && matches(other.node(), node)) {
                if (res.isEmpty() || res.getLast() != node) res.add(node);
                iterator.remove();
            } else if (other.node() == node) {
                iterator.remove();
            }
        }
    }
}
```

# 树哈希

## 思路

参考字符串哈希，我们可以为二叉树实现树哈希，从而快速判定是否存在相同结构与节点值的子树。具体来说，我们利用二叉树的递归定义，为子树的根节点 $root$ 定义哈希值：
$$
Hash(root)=A\cdot Hash(left)+B\cdot root+C\cdot Hash(right)
$$
其中 $A,B,C$ 选取三个质数，例如经典 32 位大质数 $10^9+7$、$10^9+9$ 以及 $10^9+21$，接着对 $Hash$ 结果取某个大质数的模，例如经典 64 位大质数 $10^{18}+3$。

这样就可以保证结构与节点值相同的子树，其哈希值也是相同的。

与字符串哈希一样，严格来讲子树哈希值相同是子树的结构与节点值相同的必要不充分条件，但绝大多数情况下可以相对粗糙地认为如果子树哈希值相同，则子树具有相同的结构与节点值。

**必须万分注意的是如果左子节点为空，可以赋值 $1$；如果左子节点为空，可以赋值 $2$，千万不能为二者赋同一值，更不可以全部赋 $0$（`getOrDefault(child, 0)`），否则会产生严重的哈希冲突，而这是本可以避免的，例如各节点值均为 $0$ 的树，这种情况下所有子树的哈希值均为 $0$，显然这是不合理的。**

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$，但存在极小的哈希冲突风险。

```java
class Solution {

    private static long A = (long) 1e9 + 7;
    private static long B = (long) 1e9 + 9;
    private static long C = (long) 1e9 + 21;
    private static long M = 1000000000000000003L;

    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        List<TreeNode> res = new ArrayList<>();
        Set<Long> usedHash = new HashSet<>();
        Set<Long> knownHash = new HashSet<>();
        Map<TreeNode, Long> nodeToHash = new HashMap<>();

        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode prev = null;

        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }

            TreeNode node = stack.peek();
            if (node.right != null && node.right != prev) {
                root = node.right;
            } else {
                prev = node;
                node = stack.pop();
                long l = nodeToHash.getOrDefault(node.left, 1L);
                long r = nodeToHash.getOrDefault(node.right, 2L);
                long h = hash(node, l, r);
                nodeToHash.put(node, h);
                if (!usedHash.contains(h) && knownHash.contains(h)) {
                    res.add(node);
                    usedHash.add(h);
                }
                knownHash.add(h);
            }
        }

        return res;
    }

    private long hash(TreeNode root, long leftHash, long rightHash) {
        return (B * root.val + A * leftHash + C * rightHash) % M;
    }
}
```

# 序列化后字符串哈希

## 思路

本方法其实才是我最先想到的方案，只不过想了想感觉实现稍显复杂且不够优雅（相较于树哈希），故最终决定先实现的是 “按值聚类” 的方案、然后实现了 “树哈希” 的方案。对于本方案，其思路非常简单，我们考虑一种能够唯一确定树结构的序列化方式，将树序列化为字符串后直接在其上应用字符串哈希算法就行了。实际上该方案和树哈希没有本质区别，而且还没有很好的利用上树的递归性质以简化实现，所以我觉得不算个很好的方案，这里只给出思路，我就不实现了。

对于唯一序列化的方式，可以考虑前序遍历中记录所有非空节点的子节点，哪怕子节点为空也要记录在案，这样就能唯一地根据序列化结果还原出原树。然后，我们对序列化结果考虑字符串哈希。
