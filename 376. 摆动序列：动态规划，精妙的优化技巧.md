题目简述：

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。
>
> **进阶：**你能否用 `O(n)` 时间复杂度完成此题?

题目链接：[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

# O(n²) 动态规划

## 思路

隐约察觉到本问题的解可能依赖于其子问题的解，因此可以考虑动态规划——即使这并不是最佳方案。

考虑定义 $dp1[i]$ 表示以 $nums[i]$ 为摆动序列的最后一个元素时最长的摆动序列的长度，并且如果该摆动序列能够继续增长，则下一个元素必须更大；定义 $dp2[i]$ 表示以 $nums[i]$ 为摆动序列的最后一个元素时最长的摆动序列的长度，并且如果该摆动序列能够继续增长，则下一个元素必须更小。有
$$
dp1[i]=\max\big\{dp2[j]+1:j<i,\,nums[j]>nums[i]\big\}
$$

$$
dp2[i]=\max\big\{dp1[j]+1:j<i,\,nums[j]<nums[i]\big\}
$$

最终两个 $dp$ 数组中的最大值就是问题的解。

本质上这是二维动态规划，但与 [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/) 一样地，第二个状态实际上只可能为两个值，因此为了简化表示，我们在这两个问题中都分别使用两个 $dp$ 数组从而为状态降维以更便于实现算法——虽然就算保留第二个状态也不会繁琐到哪里去，但肯定是现在的写法更简洁。

## 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        int[] dp1 = new int[n];
        Arrays.fill(dp1, 1);
        int[] dp2 = new int[n];
        Arrays.fill(dp2, 1);
        int res = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[i]) dp1[i] = Math.max(dp1[i], dp2[j] + 1);
                if (nums[j] < nums[i]) dp2[i] = Math.max(dp2[i], dp1[j] + 1);
            }
            res = Math.max(res, Math.max(dp1[i], dp2[i]));
        }

        return res;
    }
}
```

# O(n) 改进

## 思路

要实现 $O(n)$ 的时间复杂度，就应当想办法避免内层 `j` 循环。这需要我们转变思路。

注意到上文中动态规划的定义中，<u>实际上 $dp1[i]$ 只取决于 $dp2[i-1]$、$dp2[i]$ 只取决于 $dp1[i-1]$</u>（无论是从状态转移方程看，还是从摆动序列最原始的定义看，皆是如此）：

- 如果 $nums[i]<nums[i-1]$，则
  - $dp1[i]=dp2[i-1]+1$
  - $dp2[i]$ 如何变化我们并不知道，但没有必要通过内层 `j` 循环把他算出来，因为我们可以肯定他不会变得更大（可能更小，可能不变）
- 如果 $nums[i]>nums[i-1]$，则
  - $dp2[i]=dp1[i-1]+1$
  - $dp1[i]$ 如何变化我们并不知道，但没有必要通过内层 `j` 循环把他算出来，因为我们可以肯定他不会变得更大（可能更小，可能不变）
- 如果 $nums[i]=nums[i-1]$，则 $dp1[i]=dp1[i-1]$、$dp2[i]=dp2[i-1]$

读到这里，我想你可能已经有些恍然大悟了。$dp1[i]$ 如果可能变得更大，他只可能从 $dp2[i-1]$ 转移而来；$dp2[i]$ 如果可能变得更大，他只可能从 $dp1[i-1]$ 转移而来。以 $dp1[i]$ 可能变得更大为例，我们不知道也不关心 $dp2[i]$ 的值到底应该是什么，因为：

- 假设在下一步，即遍历到 $i+1$ 时 $dp2[i]$ 仍不会变得更大，则我们仍不关心他的取值，重复该过程，假设直到遍历至 $i+k$ 时 $dp2[i+k]$ 才可能变得更大；
- 当 $dp2[i+k]$ 变得比 $dp2[i-1]$ 更大，则他的值为 $dp1[i+k-1]+1$。由于在遍历过程中索引自 $i$ 起直到 $i+k-1$ 时，$dp2$ 都未曾变得更大，这说明在该过程中总是成立 $nums1[j]\leqslant nums[j-1]$（这里 $j\in[i,i+k)$），这表示虽然 $dp2$ 的值一直没有更新，但 $dp1$ 的值一直在被正确地更新，因此 $dp1[i+k-1]+1$ 必然是有效的，而 $dp2[i+k]$ 又只依赖于 $dp1[i+k-1]+1$，所以我们可以肯定 $dp2[i+k]$ 能够被正确更新；
- 并且，尽管在此前 $dp2$ 的值未被更新过，但我们可以保证对于 $j\in[i,i+k)$，$dp2[j]$ 必然小于等于 $dp2[i]$；对于本问题，我们又不必知道定义下的每个元素对应的 $dp2$ 实际值是什么——我们只关心 $dp2$ 的最大值，因此当 $nums[i]<nums[i-1]$ 时选择不更新、不关心 $dp2$ 而仅更新 $dp1$ 的操作是完全可行的，这使得我们不必进行内层 `j` 循环，节约了相当大的计算量；
- 同理，如果 $nums[i]>nums[i-1]$，只更新 $dp2$ 也是完全合法的。

这似乎有些环环相扣的意味。

也正因为 “$dp1[i]$ 只取决于 $dp2[i-1]$、$dp2[i]$ 只取决于 $dp1[i-1]$”，因此我们可以考虑滚动数组——于是在降低时间复杂度的同时，我们还能降低空间复杂度。

一句话概括：我们不必为每个元素真的计算出他确切的 $dp1[i],dp2[i]$ 的值，因为无论是最终结果还是可以利用的状态转移，都只需要二者中可能变得更大的那一个。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int dp1 = 1;
        int dp2 = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < nums[i - 1]) {
                dp1 = dp2 + 1;
            } else if ((nums[i] > nums[i - 1])) {
                dp2 = dp1 + 1;
            }
        }
        return Math.max(dp1, dp2);
    }
}
```
