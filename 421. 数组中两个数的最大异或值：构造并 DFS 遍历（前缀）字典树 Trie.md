题目简述：

> 给你一个整数数组 `nums` ，返回 `nums[i] XOR nums[j]` 的最大运算结果，其中 `0 ≤ i ≤ j < n` 。
>
> **提示：**
>
> - `1 <= nums.length <= 2 * 10^5`
> - `0 <= nums[i] <= 2^(31) - 1`

题目链接：[421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)

# DFS (前缀) 字典树 Trie

## 思路

问题保证了数组中只包含正值，因此我们可以只考虑原码，不考虑负数的补码。

观察异或的真值表（相同则假，相异则真）：
$$
\begin{array}{cc||c}
A & B & A \oplus B \\
\hline
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\end{array}
$$
可以知道，如果希望数组中两个数的异或值尽可能地大，就应该保证从最高位开始依次尽可能地使位异或结果为 $1$，这意味着两个数应尽可能从高位至低位相反，并且越是高位优先级越高。

接下来的一步是关键：如何做到让两个数尽可能地从高位至低位是相反的呢？其中一个答案就是考虑（前缀）字典树，即 Trie。

构造（前缀）字典树，然后遍历（前缀）字典树，尽可能选择两个较高位相异的字典元素计算异或结果。从树的角度说，就是考虑两个并行、同时的深度优先遍历，在每一层两个遍历都尝试选择值相反的节点。

## 代码

代码中 `prefix` 实际上就是正在构造的异或结果。我们是从最高位到最低位的顺序构造的。

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {

    private static class Node {

        int bit;
        Node left;   // bit 0
        Node right;  // bit 1

        Node(int bit) {
            this.bit = bit;
        }
    }

    private void build(Node root, int num) {
        for (int i = 31; i >= 0; i--) {
            int numBit = (num >>> i) & 1;
            if (numBit == 0) {
                if (root.left == null) root.left = new Node(0);
                root = root.left;
            } else {
                if (root.right == null) root.right = new Node(1);
                root = root.right;
            }
        }
    }

    private int dfs(int[] nums, Node a, Node b, int prefix, int i) {
        for (int j = i; i >= 0; i--) {
            if (a.left != null && a.right != null && b.left != null && b.right != null) {  // a, b 一共存在四个非空子节点
                prefix += 1 << i;
                int res1 = dfs(nums, a.left, b.right, prefix, i - 1);
                int res2 = dfs(nums, a.right, b.left, prefix, i - 1);
                return Math.max(res1, res2);
            } else if (a.left != null && a.right != null) {  // a, b 一共存在三个非空子节点
                prefix += 1 << i;
                if (b.right == null) {
                    a = a.right;
                    b = b.left;
                } else {
                    a = a.left;
                    b = b.right;
                }
            } else if (b.left != null && b.right != null) {
                prefix += 1 << i;
                if (a.right == null) {
                    a = a.left;
                    b = b.right;
                } else {
                    a = a.right;
                    b = b.left;
                }
            } else {  // a, b 一共存在两个非空子节点
                a = (a.right == null) ? a.left : a.right;
                b = (b.right == null) ? b.left : b.right;
                if ((a.bit ^ b.bit) == 1) prefix += 1 << i;
            }
        }

        return prefix;
    }

    public int findMaximumXOR(int[] nums) {
        Node root = new Node(-1);
        for (int num : nums) build(root, num);
        return dfs(nums, root, root, 0, 31);
    }
}
```

# 其他方法参考

## Trie 数组贪心匹配

[【宫水三叶の相信科学系列】详解为何能用「贪心」&「Trie」求解](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/solutions/778823/gong-shui-san-xie-noxiang-xin-ke-xue-xi-bmjdg/)

## 哈希表模拟前缀层

[【图解】简洁高效，一图秒懂！（Python/Java/C++/Go/JS/Rust）](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/solutions/2511644/tu-jie-jian-ji-gao-xiao-yi-tu-miao-dong-1427d/)
