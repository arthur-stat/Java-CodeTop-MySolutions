题目简述：

> 给定一个正整数 `n`，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中设置位（某数的二进制表示中值为 `1` 的二进制位）的个数（也被称为汉明重量）。
>
> **示例 1：**
>
> > 输入：n = 11
> > 输出：3
> > 解释：输入的二进制串 1011 中，共有 3 个设置位。
>
> **示例 2：**
>
> > 输入：n = 128
> > 输出：1
> > 解释：输入的二进制串 10000000 中，共有 1 个设置位。
>
> **进阶**：
>
> - 如果多次调用这个函数，你将如何优化你的算法？

题目链接：[191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

# 若不考虑位运算

无论如何是推荐位运算的，就算觉得 Brian Kernighan 技巧太抽象，至少 lowbit 也是应该掌握的，毕竟太常见、运用太广泛了。

但是这里也给出不考虑位运算的实现。

## 思路

不考虑位运算时，比较常规的思路是将数字或显式或隐式地转为二进制表示，然后逐位判断。

例如，我们可以每次都尝试减去使结果非负的最大的 $2$ 的幂，如果成功，这意味着对应二进制比特位为 $1$。

## 代码

在这份实现中，`bitwise()` 利用二分查找加速运算，返回 “减去使结果非负的最大的 $2$ 的幂” 的数字的比特 1 的位置，然后通过 `POW2` 映射到二进制——虽然二分查找在这里其实并没有必要，`POW2` 很短的，单纯是我想写。

注：实际上 Java 提供了返回比特 1 最高位的位置的方法 `Integer.highestOneBit(n)`。

```java
class Solution {

    private static final int[] POW2 = {
        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288,
        1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824
    };

    public int hammingWeight(int n) {
        int p = bitwise(0, POW2.length - 1, n);
        int r = p;
        int count = 0;

        while (true) {
            n -= POW2[p];
            count++;
            if (n <= 0) break;
            p = bitwise(0, r, n);
            r = p;
        }
        return count;
    }

    private int bitwise(int l, int r, int n) {
        while (POW2[l] <= POW2[r]) {
            int mid = (l + r) >> 1;
            if (POW2[mid] <= n) {
                l = mid + 1;
                if (l >= POW2.length) break;
            } else {
                r = mid - 1;
            }
        }
        return r;
    }
}
```

# Brian Kernighan 技巧

## 思路

这是一个位运算的技巧，令 `n &= (n - 1)`，则每次都会将最低位的比特 1 扭转为比特 0。

## 代码

```java
class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n &= (n - 1);
            count++;
        }
        return count;
    }
}
```

# lowbit 技巧

## 思路

`n & -n` 将返回 lowbit：获取整数 `n` 的二进制表示中最低位 1 所对应的数值。

那么每次都减去 lowbit，直到结果为 0 即可。

## 代码

```java
class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n -= lowbit(n);
            count++;
        }
        return count;
    }

    public int lowbit(int n) {
        return n & -n;
    }
}
```

# 硬件支持

## 思路

一些编程语言提供了直接调用硬件的实现。对于能够提供支持的机器，Java 可以直接调用 `Integer.bitCount()` 方法。

## 代码

```java
class Solution {
    public int hammingWeight(int n) {
        return Integer.bitCount(n);
    }
}
```

