题目简述：

> 给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

题目链接：[525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

# 思路

维护前缀和，对于 `0` 将其视为 `-1`，否则前缀和累加时无法维护 “`0` 比 `1` 多了多少个” 的信息。

假设前 `i` 个元素前缀和为 `a`，则意味着前 `i` 个元素中 `1` 比 `0` 多了 `a` 个；如果前 `j` 个元素前缀和为 `a`，则意味着前 `j` 个元素中 `1` 比 `0` 多了 `a` 个，这说明自第 `i+1` 个元素起至第 `j` 个元素的闭区间中，`0` 与 `1` 的数量是相同的。

这意味着前缀和的值能够提供我们相同数量的 `0` 和 `1` 的最长连续子数组的信息，并且整个前缀和的值域必然包含全局最长的连续子数组信息，所以我们想到用哈希表做前缀和数组的值域统计。

对于前缀和的值 `a`，用哈希表记录其首次出现的位置以及最后一次出现的位置，那么二者之差即为首尾位置前缀和为 `a` 的相同数量的 `0` 和 `1` 的最长连续子数组长度。

那么我们遍历前缀和的值域找出所有值对应的最长连续子数组长度，就可以得到全局最长连续子数组的长度。

# 代码

算法的时间复杂度是 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int findMaxLength(int[] nums) {
        Map<Integer, Pair> prefix = new HashMap<>();
        prefix.put(0, new Pair(-1, -1));
        int sum = 0;

        for (int i = 0; i < nums.length; i++) {
            sum += nums[i] == 1 ? 1 : -1;
            Pair pair = prefix.get(sum);
            if (pair == null) {
                prefix.put(sum, new Pair(i, i));
            } else {
                pair.last = i;
            }
        }

        int longest = 0;
        for (Pair pair : prefix.values()) {
            longest = Math.max(longest, pair.last - pair.first);
        }
        return longest;
    }

    private static class Pair {

        public int first;
        public int last;

        public Pair(int first, int last) {
            this.first = first;
            this.last = last;
        }
    }
}
```

# 小改进思路

其实我们只需要在首次遇见某个前缀和的值时用哈希表记录其对应的索引，然后在第二次遇见时直接结算子数组长度，并且尝试更新已知子数组长度的最大值即可。

这样子效率更高，避免了前缀和值域的一次遍历扫描取最大值，也不再需要 `Pair` 同时记录前缀和首次出现的索引与最后一次出现的索引。

# 小改进代码

算法的时间复杂度是 $O(n)$，空间复杂度为 $O(n)$，但常数时间开销更小。

```java
class Solution {
    public int findMaxLength(int[] nums) {
        Map<Integer, Integer> prefix = new HashMap<>();
        prefix.put(0, -1);
        int sum = 0;
        int longest = 0;

        for (int i = 0; i < nums.length; i++) {
            sum += nums[i] == 1 ? 1 : -1;
            Integer first = prefix.get(sum);
            if (first == null) {
                prefix.put(sum, i);
            } else {
                longest = Math.max(longest, i - first);
            }
        }

        return longest;
    }
}
```

