题目简述：

> 给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。
>
> **丑数** 就是质因子只包含 `2`、`3` 和 `5` 的正整数。

题目链接：[264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

# 思路

第一反应，感觉这更像是一个数论题？

一个数是丑数的充要条件是该数乘 2、乘 3 或乘 5 结果仍为丑数。**这似乎有些动态规划里状态转移的意味**，即一个丑数至多只可能由另外三个比他小的丑数分别乘 2、乘 3 与乘 5 得来。如何精确地找出这三个数呢？

于是我想到可以维护一个三元数组，分别对应乘 2、乘 3、乘 5 得到的丑数，取其中最小者为下一个丑数，然后更新三元数组，例如假设当前丑数由第二个数乘 3 得到，那么第二个数就应被替换为下一个丑数。

这样可以保证得到的下一个丑数是抛开已知丑数外的最小丑数。

> 其实这一过程就是一个一维 dp？

# 代码

算法的时空复杂度均为 $O(n)$。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] ugly = new int[]{0, 0, 0};
        List<Integer> uglyNumbers = new ArrayList<>(List.of(1));

        while (uglyNumbers.size() < n) {
            int u1 = uglyNumbers.get(ugly[0]) * 2;
            int u2 = uglyNumbers.get(ugly[1]) * 3;
            int u3 = uglyNumbers.get(ugly[2]) * 5;
            int u = Math.min(u1, Math.min(u2, u3));
            uglyNumbers.add(u);

            if (u1 == u) ugly[0]++;
            if (u2 == u) ugly[1]++;
            if (u3 == u) ugly[2]++;
        }

        return uglyNumbers.getLast();
    }
}
```
