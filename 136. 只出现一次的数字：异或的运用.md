题目简述：

> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

题目连接：[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

# 思路

仔细观察问题，让我感到似曾相识。那时的我还没有专门接触过计算机，大概是大一大二的时候吧，不知出于什么原因恰好尝试了这个问题，无果，查看答案后只觉神奇，当初实在无法理解题解是怎么想到异或的。

即使已经过去四五年，对那道题本身已经没有了具体的印象（但其实好像就是这道？），现在我已经能很自然地根据题意想到需要进行异或位运算了，因为要一次遍历得到结果，直接能想到我们需要某种取反操作，保证抵消掉偶数个元素的影响，留下奇数个元素。

我最先想到的其实是符号的取反——相反数，但稍微一细想就发现不可行。循着这个思路，我接下来就想到了异或——XOR。异或异或，相异才“OR”为真嘛！
$$
\begin{array}{|c|c|c|}\hline
A & B & A \oplus B \\\hline
0 & 0 & 0\\
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\\\hline
\end{array}
$$
从真值表能看出，异或符合我们对“取反操作”和“抵消”的全部期望：相同的位留下 0，不同的位留下 1。异或的一个特点是满足交换律，两个相同的元素不管位于什么位置，我们逐个取异或下来，结果都与略过这两个相同的元素是一样的，因为相同的元素相互抵消、结果为 0。代入到这个问题中，我们逐个取异或，最后留下的救赎那个只出现了一次的元素。

这个问题对当初只会用电脑上网的我——一个普通的数学系大学生来说，是一个很难的问题了。真令人感叹，恍恍惚惚，思绪似乎也跟着这道题回到了过去，回到了我的本科低年级时代。有点百感交集的意味，我也不知道这是怎么了。是因为对当下的自己并不满意而怀念过去吗？

不自觉在过去沉浸了一下。

# 代码

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int n : nums) {
            res ^= n;
        }
        return res;
    }
}
```

