题目简述：

> 给定字符串*S*，找到最多有k个不同字符的最长子串*T*。

题目链接：[386 · 最多有k个不同字符的最长子字符串](https://www.lintcode.com/problem/386/)

# 思路

滑动窗口扫一遍就行了，对于一个确定的右端点维护窗口内不同的字符至多有 $k$ 个，否则收缩左端点以维护整个窗口内至多存在 $k$ 个不同的字符。

计数考虑哈希表，但要注意 `s = ""` 与 `k = 0` 的边界条件，因为闭区间双指针 `left` 与 `right` 意味着至少包含一个字符。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
public class Solution {
    /**
     * @param s: A string
     * @param k: An integer
     * @return: An integer
     */
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if (s == null || s.isEmpty() || k <= 0) return 0;
        Map<Character, Integer> map = new HashMap<>();
        int unique = 0;
        int left = 0;
        int maxLeft = 0;
        int maxRight = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            if (map.merge(c, 1, Integer::sum).intValue() == 1) {
                unique++;
            }

            while (unique > k) {
                char cc = s.charAt(left++);
                if (map.merge(cc, -1, Integer::sum).intValue() == 0) {
                    map.remove(cc);
                    unique--;
                }
            }
            if (maxRight - maxLeft < right - left) {
                maxLeft = left;
                maxRight = right;
            }
        }

        return maxRight - maxLeft + 1;
    }
}
```

