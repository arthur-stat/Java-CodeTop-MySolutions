题目简述：

> 将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。
>
> 对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
>
> 特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

题目链接：[LCR 155. 将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

# 思路

实际上，就是要我们做一个中序遍历。

>  注：无论是递归还是显式栈，中序遍历均只能做到 $O(n)$ 的时间复杂度与 $O(n)$ 的最坏空间复杂度。除非考虑 Morris 遍历，这样可以实现 $O(1)$ 空间复杂度，但将会使问题极大的复杂化。

# 分析

一个直观的想法是用一个数组额外存储中序遍历的遍历结果，然后直接在数组中修改节点，因为如果在遍历的过程中修改节点，可能会破坏二叉搜索树原有的结果，从而影响遍历。

但事实是虽然使用额外的数组时间复杂度也是 $O(n)$，但这是稳定的 $O(n)$，而且常数因子较大，我们实际上完全可以就地修改。

中序遍历的顺序是 左 → 中 → 右，因此只要我们在 “中” 节点让其 `left` 指针指向前驱节点，并且让前驱节点的 `right` 指针指向 “中” 节点。由于左子树已访问完毕，因此这样修改并不会影响后续遍历，我们能够顺利地一边遍历一边修改节点而不会干扰遍历。

> 注意：对二叉搜索树而言，“中” 节点的 `left` 指针在大多数情况下并不指向前驱节点，所以最好显式维护 `prev` 以表示上一次访问的节点。

# 递归实现

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/

class Solution {

    Node prev;

    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        prev = null;
        Node last = getLast(root);
        Node head = getHead(root);
        dfs(root);
        circularize(head, last);
        return head;
    }

    private void dfs(Node node) {

        if (node.left != null) {
            dfs(node.left);
        }

        if (prev != null) prev.right = node;
        node.left = prev;
        prev = node;
        
        if (node.right != null) {
            dfs(node.right);
        }
    }

    private Node getHead(Node root) {
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }

    private Node getLast(Node root) {
        while (root.right != null) {
            root = root.right;
        }
        return root;
    }

    private void circularize(Node head, Node last) {
        head.left = last;
        last.right = head;
    }

}
```

# 迭代实现

> 中序遍历可以用两个嵌套的循环实现，也可以只用一个循环结合流程控制语句直接模拟递归的行为来实现。
>
> 只有后序遍历的迭代实现比较繁琐。
>
> 造成这个现象的原因是：对于后序遍历，栈结构本身不包含 “子树访问完成” 信息。

```java
class Solution {

    Node prev;

    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        prev = null;
        Node last = getLast(root);
        Node head = getHead(root);
        dfs(root);
        circularize(head, last);
        return head;
    }

    private void dfs(Node root) {

        Deque<Node> s = new ArrayDeque<>();

        while (root != null || !s.isEmpty()) {

            if (root != null) {
                s.push(root);
                root = root.left;
                continue;
            }

            Node cur = s.pop();
            if (prev != null) prev.right = cur;
            cur.left = prev;
            prev = cur;

            root = cur.right;
        }
    }

    private Node getHead(Node root) {
        while (root.left != null) {
            root = root.left;
        }

        return root;
    }

    private Node getLast(Node root) {
        while (root.right != null) {
            root = root.right;
        }

        return root;
    }

    private void circularize(Node head, Node last) {
        head.left = last;
        last.right = head;
    }

}
```

