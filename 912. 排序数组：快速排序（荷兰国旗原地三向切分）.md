题目简述：

> 给你一个整数数组 `nums`，请你将该数组升序排列。
>
> 你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

题目链接：[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

# 2025 年 7 月 29 日更

三向切分的原理可以看我针对 [75. 颜色分类](https://leetcode.cn/problems/sort-colors/) 写的题解，这个问题其实就是荷兰国旗问题，而荷兰国旗问题正是快排算法里三向切分的原理！

不需要死记硬背，只要记得下面这张原理图：
$$
\underbrace{0000000}_{\text{less area}}\ \ \ \mathrm{left}\ \ \ \underbrace{11111}_{\text{equal area}}\ \ \mathrm{mid}\ \ \underbrace{???????????}_{\text{unknown area}}\ \ \ \mathrm{right}\ \ \ \underbrace{222222222222}_{\text{greater area}}
$$
如果一时理解不了，去看看我在 [75. 颜色分类](https://leetcode.cn/problems/sort-colors/) 写的题解。其中详细说明了三路快排的原理（荷兰国旗问题）。

# 三向切分原地快排

算法的平均时间复杂度为 $O(n\log n)$、空间复杂度为 $O(\log n)$，最坏时间复杂度为 $O(n^2)$，空间开销主要来自于递归栈。

```java
class Solution {
    static Random rand = new Random(39);

    public int[] sortArray(int[] nums) {
        sort(nums, 0, nums.length - 1);
        return nums;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    private void sort(int[] nums, int low, int high) {
        if (high - low <= 0) return;

        int randomIndex = low + rand.nextInt(high - low + 1);
        int pivot = nums[randomIndex];
        // int randomIndex = high;
        // int pivot = nums[randomIndex];

        int less = low;
        int gter = high;
        int i = low;
        while (i <= gter) {
            if (nums[i] < pivot) {
                swap(nums, i, less);
                less++;
                i++;
            } else if (nums[i] > pivot) {
                swap(nums, i, gter);
                gter--;
            } else {
                i++;
            }
        }

        sort(nums, low, less - 1);
        sort(nums, gter + 1, high);
    }
}
```

时间开销与空间开销均优于90%提交的代码。
