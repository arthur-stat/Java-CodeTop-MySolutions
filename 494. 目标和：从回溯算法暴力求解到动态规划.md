题目简述：

> 给你一个非负整数数组 `nums` 和一个整数 `target` 。
>
> 向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：
>
> - 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。
>
> 返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。
>
> **提示：**
>
> - `1 <= nums.length <= 20`
> - `0 <= nums[i] <= 1000`
> - `0 <= sum(nums[i]) <= 1000`
> - `-1000 <= target <= 1000`

题目链接：[494. 目标和](https://leetcode.cn/problems/target-sum/)

# 回溯算法暴力求解

## 思路

这个问题如果只从能不能算出结果考虑显然可以直接用回溯算法暴力搜索。而且，查阅力扣给出的数据范围：

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

可以确定回溯算法暴力搜索的确不会超时。

## 代码

算法的时间复杂度为 $O(2^n)$，空间复杂度为 $O(n)$（递归栈开销）。

AC 时花费 578 ms。

```java
class Solution {

    private int[] nums;
    private int target;
    private int count;

    public int findTargetSumWays(int[] nums, int target) {
        this.nums = nums;
        this.target = target;
        count = 0;
        dfs(0, 0);
        return count;
    }

    private void dfs(int res, int i) {

        if (i == nums.length) {
            if (res == target) count++;
            return;
        }

        dfs(res + nums[i], i + 1);
        dfs(res - nums[i], i + 1);
    }
}
```

# 动态规划（记忆化搜索）

## 思路

注意到，在回溯算法暴力搜索的实现中，方法 `dfs` 的参数为 `res` 与 `i`，这意味着 `dfs` 的计算结果实际上只与 `res` 和 `i` 有关，在计算 `dfs` 的结果时我们并不关心究竟是哪条分支探索到了这里。此处体现了无后效性，因此可以考虑动态规划或记忆化搜索。

实际上，搜索树在第 $i$ 层时会形成 $2^i$ 条不同的搜索路径， 然而这 $2^i$ 条路径在许多情况下对应的 `res` 却远远没有 $2^i$ 这么多——在题目的限定条件下就更少了。假设 `nums[0]` 至 `nums[i]` 绝对值的最大值为 $\alpha_i=\displaystyle\sum^i_{j=1}\big\vert\mathrm{nums}[j]\big\vert$，那么这 $2^i$ 条路径对应的 `res` 取值范围至多为 $[-2\alpha_i,2\alpha_i]$。由于题目给定的数据范围 `0 <= nums[i] <= 1000`，因此根据抽屉原理，`res` 必然存在大量重复（毕竟 $2^i$ 和 $4\alpha_i$ 完全不在一个数量级）。这就确保了动态规划或记忆化搜索能够为我们节约大量时间。

> 其实本题的数据范围直接明说了 `0 <= sum(nums[i]) <= 1000`，我们的分析只是基于更一般的数据。

---

记忆化搜索的实现很简单——记忆 `dfs` 的参数即可，这里便略过了，实现不难——像 Python 直接在 `dfs` 上加一个 `@Cache` 装饰器即可。就算是 C++ 和 Java，由于题目给定了数据范围，因此甚至不需要使用 HashMap，直接用一个二维定长数组就可以实现参数映射的记忆化了（实际上就是动态规划的逆方向过程），效率非常高。

我们主要来推导一下动态规划的状态转移。

---

要以动态规划的方式解决这个问题，关键是意识到本问题符合 01 背包模型。01 背包原问题的重点是在对每个元素 “选与不选” 的情况下求最优化问题或对方案进行计数，其实如果我们把 “选” 和 “不选” 视为两种不同的选择 / 行为，那么就可以导出：***如果对每个元素都可以做出有限种的选择或行为，如果问题是一个最优化问题或是计数问题，那么这一问题就符合背包模型。***所以本问题也符合背包模型，因为对每个元素可以取其正值也可以取其负值，对应两种不同的选择或行为。明白了这一点，本问题的状态定义和状态转移方程就不难推导了——如果意识不到这个问题其实符合背包模型，那么状态定义的推导可能没那么简单。

根据背包模型，设 $dp[i][j]$ 表示针对第 $i$ 个元素及其之前的各元素所组合成的结果为 $j$ 的不同表达式的总数，则
$$
dp[i][j]=dp[i-1]\big[j-\mathrm{nums}[i]\big]+dp[i-1]\big[j+\mathrm{nums}[i]\big]
$$
从状态转移方程可以看出，显然本问题可以通过滚动数组优化空间开销。

## 代码

算法使用了滚动数组优化技巧，时间复杂度为 $O(n\alpha_n)$，空间复杂度为 $O(\alpha_n)$。

AC 时花费 9 ms。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int alpha = 0;
        for (int num : nums) alpha += Math.abs(num);
        int[] dp1 = new int[2 * alpha + 1];
        int[] dp2 = new int[2 * alpha + 1];

        // init
        dp1[nums[0] + alpha] += 1;
        dp1[-nums[0] + alpha] += 1;

        for (int i = 1; i < nums.length; i++) {
            int tmpval = Math.abs(nums[i]);
            for (int j = -alpha; j <= alpha; j++) {
                dp2[j + alpha] = 0;
                if (j - tmpval >= -alpha) dp2[j + alpha] += dp1[j - tmpval + alpha];
                if (j + tmpval <= alpha) dp2[j + alpha] += dp1[j + tmpval + alpha];
            }

            int[] tmparr = dp1;
            dp1 = dp2;
            dp2 = tmparr;
        }

        return target <= alpha && target >= -alpha ? dp1[target + alpha] : 0;
    }
}
```

针对本题的数据范围，明确说明了 `0 <= sum(nums[i]) <= 1000`，且 `nums[i]` 非负，因此可以用一些固定参数减少计算量。同时，尽量在早期时减少 `j` 的无效扫描。

这样实现的算法可以将时间开销进一步减少至 7 ms。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int alpha = nums[0];
        int[] dp1 = new int[2001];
        int[] dp2 = new int[2001];

        // init
        dp1[ nums[0] + 1000] += 1;
        dp1[-nums[0] + 1000] += 1;

        for (int i = 1; i < nums.length; i++) {
            alpha += nums[i];
            for (int j = -alpha; j <= alpha; j++) {
                dp2[j + 1000] = 0;
                int left  = j - nums[i] + 1000;
                int right = j + nums[i] + 1000;

                if (left >= 0 && left <= 2000)  dp2[j + 1000] += dp1[left];
                if (right >= 0 && right <= 2000) dp2[j + 1000] += dp1[right];
            }

            int[] tmparr = dp1;
            dp1 = dp2;
            dp2 = tmparr;
        }

        return (target >= -1000 && target <= 1000) ? dp1[target + 1000] : 0;
    }
}
```

还可以进一步优化以避免一些不必要的计算——这样可以把通过测试的时间开销再稳定压缩至 5 ms。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int alpha = 0;
        int[] dp1 = new int[2001];
        int[] dp2 = new int[2001];
        dp1[1000] = 1;

        for (int i = 0; i < nums.length; i++) {
            int newAlpha = alpha + nums[i];

            // 只清零本轮会写入的区间 [-newAlpha, newAlpha]
            int L = -newAlpha + 1000, R = newAlpha + 1000;
            Arrays.fill(dp2, L, R + 1, 0);

            // 只遍历上一轮可达区间 [-alpha, alpha]
            for (int j = -alpha; j <= alpha; j++) {
                int ways = dp1[j + 1000];
                if (ways == 0) continue;
                dp2[j + nums[i] + 1000] += ways;
                dp2[j - nums[i] + 1000] += ways;
            }

            int[] tmparr = dp1;
            dp1 = dp2;
            dp2 = tmparr;
            alpha = newAlpha;
        }

        return (target >= -1000 && target <= 1000) ? dp1[target + 1000] : 0;
    }
}
```

