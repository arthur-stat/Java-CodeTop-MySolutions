题目简述：

> 给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。
>
> 请你找出并返回只出现一次的那个数。
>
> 你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

题目链接：[540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

# 思路

二分查找。

如果不要求时间复杂度，则直接遍历一次，对每个元素取异或即可。要求时间复杂度 $O(\log n)$ 的情况下，就只能二分查找了。

对于这一特殊的有序数组，每个相同元素都是成对出现的，不难知道：

- 如果 `nums[2n]` 与 `nums[2n+1]` 相同，则意味着这一唯一的元素一定在 `nums[2n+1]` 右侧，即尚未出现在 `nums[2n]` 左侧；
- 如果 `nums[2n]` 与 `nums[2n+1]` 不同但 `nums[2n]` 与 `nums[2n-1]` 相同，则意味着这一唯一的元素一定在 `nums[2n+1]` 左侧；
- 如果 `nums[2n]` 与 `nums[2n+1]` 不同且 `nums[2n]` 与 `nums[2n-1]` 也不同，那么 `nums[2n]` 就是那全局唯一的元素。

# 代码

算法的时间复杂度为 $O(\log n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0;
        int r = nums.length / 2;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            int base = mid * 2;

            if (base + 1 < nums.length && nums[base] == nums[base + 1]) {
                l = mid + 1;
            } else if (base - 1 > 0 && nums[base] == nums[base - 1]) {
                r = mid - 1;
            } else {
                return nums[base];
            }
        }

        return -1;
    }
}
```

