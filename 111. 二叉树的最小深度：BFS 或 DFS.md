题目简述：

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。

题目链接：[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

# BFS

## 思路

注意最小深度的定义：从根节点到最近叶子节点的最短路径上的节点数量，因此当二叉树退化为链表，最小深度并不是 1，而是链表的长度。

BFS 比 DFS 更适合解决本问题，因为可以提前返回；但 DFS 也是可行的，只是需要完整遍历整棵树。

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        Deque<TreeNode> q = new ArrayDeque<>();
        q.offer(root);
        int thisLayerNum = 1;
        int nextLayerNum = 0;
        int layer = 1;

        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            thisLayerNum--;

            if (node.left == null && node.right == null) return layer;
            if (node.left != null) {
                q.offer(node.left);
                nextLayerNum++;
            }
            if (node.right != null) {
                q.offer(node.right);
                nextLayerNum++;
            }

            if (thisLayerNum == 0) {
                thisLayerNum = nextLayerNum;
                nextLayerNum = 0;
                layer++;
            }
        }

        return layer;
    }
}
```

# DFS

考虑先序遍历。

## 递归实现

```java
class Solution {

    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        return dfs(root, 1);
    }

    private int dfs(TreeNode node, int depth) {
        if (node.left == null && node.right == null) return depth;

        int a = Integer.MAX_VALUE;
        int b = Integer.MAX_VALUE;

        if (node.left != null) a = dfs(node.left, depth + 1);
        if (node.right != null) b = dfs(node.right, depth + 1);

        return Math.min(a, b);
    }
}
```

## 迭代实现

```java
class Solution {

    public int minDepth(TreeNode root) {

        if (root == null) return 0;
        int minDepth = Integer.MAX_VALUE;
        Deque<TreeNode> nodeStack = new ArrayDeque<>();
        Deque<Integer> depthStack = new ArrayDeque<>();
        nodeStack.push(root);
        depthStack.push(1);

        while (!nodeStack.isEmpty()) {
            TreeNode node = nodeStack.pop();
            int depth = depthStack.pop();

            if (node.left == null && node.right == null) minDepth = Math.min(minDepth, depth);

            if (node.right != null) {
                nodeStack.push(node.right);
                depthStack.push(depth + 1);
            }
            if (node.left != null) {
                nodeStack.push(node.left);
                depthStack.push(depth + 1);
            }
        }

        return minDepth;
    }
}
```