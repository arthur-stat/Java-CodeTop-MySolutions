题目简述：

> 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。
>
> 假设每一种面额的硬币有无限个。 
>
> 题目数据保证结果符合 32 位带符号整数。

题目链接：[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

# 前缀和思路

一个简单的想法就是预计算前缀和数组，然后生成从 0 到最大前缀和的随机数，如果该随机数大于某个前缀和但小于前一个前缀和，那么对应的加权随机索引就是前一个前缀和对应的索引。

显然，这里可以二分查找加速算法。

## 前缀和 + 遍历扫描

算法的时间复杂度为 $O(n)$。

AC 时耗时 84ms。

```java
class Solution {

    private int[] preSum;
    private Random rand;
    private int n;

    public Solution(int[] w) {
        n = w.length;
        preSum = new int[n + 1];
        int i = 1;
        for (int ww : w) {
            preSum[i] = preSum[i - 1] + ww;
            i++;
        }
        rand = new Random();
    }
    
    public int pickIndex() {
        int p = rand.nextInt(preSum[n]);
        for (int i = 0; i < n; i++) {
            if (preSum[i + 1] > p) return i;
        }
        return 0;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(w);
 * int param_1 = obj.pickIndex();
 */
```

## 前缀和 + 二分查找

算法的时间复杂度为 $O(\log n)$。

AC 时耗时 22ms，已经击败 99.49% 的代码了。

```java
class Solution {

    private int[] preSum;
    private Random rand;
    private int n;

    public Solution(int[] w) {
        n = w.length;
        preSum = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i - 1] + w[i - 1];
        }
        rand = new Random();
    }

    public int pickIndex() {
        int total = preSum[n];
        int p = rand.nextInt(total);
        int target = p + 1;
        int left = 1, right = n, ans = n;
        while (left <= right) {
            int mid = left + ((right - left) >>> 1);
            if (preSum[mid] < target) {
                left = mid + 1;
            } else {
                ans = mid;
                right = mid - 1;
            }
        }
        return ans - 1;
    }
}
```

# Alias 算法

仅作了解，除非对算法有超高的情热。

> ***1. 背景***
>
> 问题：给定一个权重数组 $w[0..n-1]$，权重和为 $W$。希望每次调用 `pickIndex()` 按比例 $\frac{w[i]}{W}$ 返回下标。
>
> - **前缀和 + 二分**：预处理 $O(n)$，每次采样 $O(\log n)$。
> - **别名法 (Alias Method)**：预处理 $O(n)$，每次采样 $O(1)$。
>
> ------
>
> ***2. 核心思想***
>
> 直觉上，如果能让每个桶（下标）都有 **均等的 $1/n$ 进入概率**，再在桶里做一个小二择一，就能 $O(1)$ 完成。
>
> Alias 法正是这么做的：
>
> 1. **归一化权重**
>     把每个权重乘上 $n$，得到一组数 $p[i]$，满足 $\sum p[i] = n$。
>
>    > 平均下来每个桶应该"承载"正好 1 单位的概率。
>    > 所以有的桶 $p[i] > 1$（大概率桶），有的 $p[i] < 1$（小概率桶）。
>
> 2. **构造两个队列**
>
>    - 小于 1 的放进 `small` 队列
>    - 大于等于 1 的放进 `large` 队列
>
> 3. **配对填充**
>     每次从 `small` 拿一个小概率桶 $i$，从 `large` 拿一个大概率桶 $j$：
>
>    - 把桶 $i$ 填满 1 的概率。即：
>      - 记录 `prob[i] = p[i]`（小于 1 的概率部分）
>      - 记录 `alias[i] = j`（"补充"部分来自大桶 $j$）
>    - 然后把 $j$ 的剩余容量减去 $1 - p[i]$。
>      - 如果 $j$ 仍然 $\geq 1$，放回 `large`；否则放进 `small`。
>    - 重复直到两个队列空。
>
>    最终每个桶都有一个数 `prob[i] ∈ [0,1]` 和一个"别名"下标 `alias[i]`。
>
> ------
>
> ***3. 采样过程（O(1)）***
>
> - 等概率随机选一个桶 $i$（概率 $1/n$）。
> - 再生成一个 $[0,1)$ 的小数 $u$：
>   - 如果 `u < prob[i]` → 返回 $i$
>   - 否则 → 返回 `alias[i]`
>
> 因为每个桶进入的概率都是 $1/n$，配合桶内这次二择一，就等价于按权重比例抽样。
>
> ------
>
> ***4. 复杂度***
>
> - **预处理**：$O(n)$ 时间，$O(n)$ 空间。
> - **采样**：$O(1)$（一次桶选择 + 一次比较）。
