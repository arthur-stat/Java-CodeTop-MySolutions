题目简述：

> 为了毕业你需要选择 n 门课程，这 n 门课程中存在一定的依赖关系，例如想要完成 B 课程，必须先完成 A 课程，请你找出一个可以完成全部课程的顺序，如果无论如何选择都无法完成全部课程则返回空数组。
>
> 依赖关系以如下方式输入：
>
> [[2,1],[3,2]]
>
> 即要完成课程 2 ，必须先完成 1 ， 要完成课程 3 ，必须先完成课程 2，答案 [1,2,3] 即可。
>
> 但也可能出现类似
>
> [[2,1],[1,2]]
>
> 要完成课程 2 ，必须先完成 1 ，要完成课程 1 ，必须先完成课程 2 ，则无解，返回一个空数组即可。
>
> 数据范围： $1\leqslant n\leqslant 2000$，依赖关系的数量满足 $0\leqslant m\leqslant n∗(n−1)$，保证不会有一组一模一样的依赖关系。

题目链接：[检测循环依赖](https://www.nowcoder.com/practice/8dc02ad98553432a90affc3a0484910b)

# 思路

与 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 是一样的，考虑有向图的 BFS 拓扑排序（Kahn 算法）。

具体原理请移步至我在 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 给出的题解。简单讲是首先构建邻接表，然后计算入度，让入度为 0 的节点入队，然后逐个出队的同时更新入度表，再让新的入度为 0 的节点入队。

这样，如果最终结果集大小与 `n` 相同则说明结果集是一条合法的路径，否则说明存在循环依赖。

# 代码

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param prerequisites int整型二维数组 
     * @param n int整型 
     * @return int整型一维数组
     */
    public int[] findOrder (int[][] prerequisites, int n) {
        // 构建邻接表，同时统计入度
        List<Integer>[] adj = new List[n];
        int[] inDegree = new int[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        for (int[] p : prerequisites) {
            adj[p[1]].add(p[0]);
            inDegree[p[0]]++;
        }

        int[] res = new int[n];
        int k = 0;
        // 初始化队列，将入度为 0 的置入其中
        Deque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
                res[k++] = i;
            }
        }

        // BFS
        while (!queue.isEmpty()) {
            int course = queue.poll();

            for (int next : adj[course]) {
                inDegree[next]--;
                if (inDegree[next] == 0) {
                    queue.offer(next);
                    res[k++] = next;
                }
            }
        }

        return k == n ? res : new int[0];
    }
}
```

