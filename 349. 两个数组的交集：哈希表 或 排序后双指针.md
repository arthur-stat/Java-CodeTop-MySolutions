题目简述：

> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的 交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

题目链接：[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

# 哈希表

这种方法最直观，考虑集合数据结构（不重复且无序的容器），直接取交集。

算法的时间复杂度为 $O(m+n)$，空间复杂度为 $O\big(\min\{m,n\}\big)$。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        set1.addAll(Arrays.stream(nums1).boxed().collect(Collectors.toSet()));

        Set<Integer> set2 = new HashSet<>();
        set2.addAll(Arrays.stream(nums2).boxed().collect(Collectors.toSet()));

        set1.retainAll(set2);
        return set1.stream().mapToInt(i -> i).toArray();
    }
}
```

# 排序 + 双指针

这也是个比较自然的想法，在排序后于两个数组上分别置一个指针（初始化于各自数组的最小值），比较指针所指向的值：如果两值不相等，让指向更小值的指针递增（并跳过所有重复值）；如果相等，我们就找到一个交集元素，然后两个指针都递增并跳过所有相同的该值。

算法的时间复杂度为 $O(m\log m+n\log n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int m = nums1.length;
        int n = nums2.length;

        List<Integer> res = new ArrayList<>();
        int i = 0;
        int j = 0;

        while (i < m && j < n) {
            if (nums1[i] == nums2[j]) {
                int resVal = nums1[i];
                res.add(resVal);

                do {
                    i++;
                } while (i < m && nums1[i] == resVal);

                do {
                    j++;
                } while (j < n && nums2[j] == resVal);
            } else if (nums1[i] < nums2[j]) {
                int tmp = nums1[i];

                do {
                    i++;
                } while (i < m && nums1[i] == tmp);
            } else {
                int tmp = nums2[j];

                do {
                    j++;
                } while (j < n && nums2[j] == tmp);
            }
        }

        return res.stream().mapToInt(num -> num).toArray();
    }
}
```

