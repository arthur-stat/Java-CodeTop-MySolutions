题目简述：

> 给你一棵二叉树，它的根为 `root` 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。
>
> 由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。
>
> **提示：**
>
> - 每棵树最多有 `50000` 个节点，且至少有 `2` 个节点。
> - 每个节点的值在 `[1, 10000]` 之间。

题目链接：[1339. 分裂二叉树的最大乘积](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/)

# 思路

注意到这样一个重要的不变式：整棵树所有节点的和是恒定不变的。一旦我们找出了其中一棵子树的和，那么只要我们知道整棵树的节点和，剩余节点构成的相应的另一棵分裂子树的和也就能直接得到。所谓分裂子树，本质上就是取一个节点作为某个子树的根节点，然后取剩余节点作为另一棵子树。

同时又注意到，一棵分割子树的所有子节点和天然地可以通过后序遍历得到。通过后序遍历，我们可以得到任意一个节点作为分裂子树的根节点的节点和。

按照题目的数据范围，乘积最大为 $(25000\times10000)^2$，这个值是不会溢出 64 位有符号整数的，因此可以直接用 64 位有符号整数存储结果以便于找出最大值。

那么现在的思路就很清晰了，先遍历一次得到所有节点的和，再进行一次后序遍历，考虑每个节点作为某棵分裂子树根节点的可能性，这样就能遍历所有可能的分裂子树并计算子树和的乘积。

# 递归实现

算法的时间复杂度为 $O(n)$，空间复杂度取决于 DFS 的具体实现。在这里的实现中，空间复杂度为 $O(h)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    private long res;

    public int maxProduct(TreeNode root) {
        res = 0;
        long total = dfs(root);
        dfs(root, total);
        return (int) (res % ((int) 1e9 + 7));
    }

    private long dfs(TreeNode root) {
        if (root == null) return 0;

        long sum = root.val;
        sum += dfs(root.left);
        sum += dfs(root.right);

        return sum;
    }

    private long dfs(TreeNode root, long total) {
        if (root == null) return 0;

        long sum = root.val;
        sum += dfs(root.left, total);
        sum += dfs(root.right, total);

        long other = total - sum;
        res = Math.max(res, sum * other);

        return sum;
    }
}
```

# 迭代实现

算法的时间复杂度为 $O(n)$，空间复杂度取决于 DFS 的具体实现。在这里的实现中，空间复杂度为 $O(h)$。

```java
class Solution {
    public int maxProduct(TreeNode root) {
        Deque<TreeNode> queue = new ArrayDeque<>();
        if (root != null) queue.offer(root);
        long total = 0;
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            total += node.val;
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }

        Deque<TreeNode> nodeStack = new ArrayDeque<>();
        Deque<Long> sumStack = new ArrayDeque<>();
        TreeNode prev = null;
        long res = 0;
        while (root != null || !nodeStack.isEmpty()) {
            while (root != null) {
                nodeStack.push(root);
                root = root.left;
            }

            TreeNode node = nodeStack.peek();
            if (node.right != null && node.right != prev) {
                root = node.right;
            } else {
                long sum = node.val;
                if (node.right != null) sum += sumStack.pop();
                if (node.left != null) sum += sumStack.pop();
                long other = total - sum;
                res = Math.max(res, sum * other);
                sumStack.push(sum);
                prev = nodeStack.pop();
            }
        }

        return (int) (res % ((int) 1e9 + 7));
    }
}
```
