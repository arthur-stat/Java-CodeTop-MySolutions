题目简述：

> 实现 pow(x, n)，即计算 `x` 的整数 `n` 次幂函数（即，`x^n` ）。

题目链接：[50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

# 思路

典型的分治算法场景，经典应用。

简单说，比如要计算 $2^4$，可以计算 $2^2$ 得到 $2^2=2\times2=4$，然后直接算 $2^4=2^2\times2^2=4\times4=16$，而没有必要计算 $2\times2\times2\times2$。这样可以实现 $O(\log n)$ 的时间复杂度，而直接自乘 $n$ 次时间复杂度为 $O(n)$。

# 注意

不要从低到高构造幂次，这样会超时，例如

```java
class Solution {
    public double myPow(double x, int n) {
        if (n == 0) return 1.0;
        if (n < 0) {
            x = 1.0 / x;
            n = -n;
        }
        double res = x;
        int exp;

        for (exp = 1; 2 * exp <= n; exp *= 2) {
            res *= res;
        }

        return res *= myPow(x, n - exp);
    }
}
```

因为求解了大量重复的子问题，整体时间复杂度接近 $O(\log^2n)$。

但即使添加哈希表缓存也会超时，这我就不太理解了。

然而无论如何，最佳的实现方式当然还是从高至低构造幂次，这样不会重复求解子问题，能有效利用已知信息。

# 代码

从高至低地构造幂次，时间复杂度为 $O(\log n)$，空间复杂度为 $O(\log n)$（递归栈开销）。

```java
class Solution {
    public double myPow(double x, int n) {
        if (n == 0) return 1.0;

        if (n == Integer.MIN_VALUE) {  // 溢出处理
            return 1 / x * myPow(x, n + 1);
        } else if (n < 0) {
            x = 1.0 / x;
            n = -n;
        }

        return fastPow(x, n);
    }

    private double fastPow(double x, int n) {
        if (n == 1) return x;
        double res = fastPow(x, n / 2);
        res = (n & 1) == 1 ? res * res * x : res * res;
        return res;
    }
}
```

