题目简述：

> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。
>
> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

题目链接：[134. 加油站](https://leetcode.cn/problems/gas-station/)

# 思路

首先找到问题的不变式。

容易知道，`gas` 数组与 `cost` 数组实际上都是循环数组。假设汽车有足够的油，那么行驶一圈能够从各加油站得到的油量与花费的油量都是固定的：

- 获得的油量为 $\displaystyle\sum_i\mathrm{gas}[i]$
- 花费的油量为 $\displaystyle\sum_i\mathrm{cost}[i]$

显然，假设最终获得的油量 $\displaystyle\sum_i\mathrm{gas}[i]$ 小于最终花费的油量 $\displaystyle\sum_i\mathrm{cost}[i]$，那么无论从何处出发，最终剩余油量均为负数，即不可能按顺序绕环路行驶一周。反之，则可能能够按顺序绕环路行驶一周。

当最终获得的油量 $\displaystyle\sum_i\mathrm{gas}[i]$ 大于等于最终花费的油量 $\displaystyle\sum_i\mathrm{cost}[i]$，从第 `k` 个位置出发时，只要全程油量均非负，那么最终汽车就能够从第 `k` 个位置出发按顺序绕环路行驶一周。我们现在的目标是尽可能地找到这个合法的 `k`。

---

再次强调：如果汽车能按顺序绕环路行驶一周，则路途上能获得的油与花费的油都是一定的。我们的目的是尽可能使汽车从某个位置出发后，在旅途上油箱油量保持非负。

那么我们应该从哪个位置出发呢？如果每个位置都尝试一遍，则时间复杂度为 $O(n^2)$，在给定的数据范围 `1 <= n == gas.length == cost.length <= 10^5` 下，这是不可接受的时间开销。

考虑到 `gas[i]` 与 `cost[i]` 之差表示汽车在该点处能够获得的油量与移动至下一个位置所需要花费的油量之差，那么其前缀和 `prefix[i]` 就意味着该差值的累积。换句话说，`prefix[i] - prefix[j]` 表示从点 `i + 1` 移动至点 `j` 的净油量开销。我们将借助前缀和数组帮助我们找出最佳的出发位置。

由于数组是循环的，因此尽管这里的前缀和 `prefix` 是从 $0$ 开始计算的，但事实上从任何点开始计算均只会影响到各前缀和的基准常数，不会影响前缀和变化的相对值。这启发我们通过 `prefix` 的相对变化量寻找起点，而不要关注每个前缀和绝对值的数值大小。

下文将证明：从前缀和最小处的下一点出发，便能尽最大可能使油箱不会在途中见底。如果从该点处出发仍无法按顺序绕环路行驶一周，则意味着从任何一点出发都不能按顺序绕环路行驶一周。

实际上下面这个证明是 GPT 5 - thinking 写的~但证起来的确不算难就是了。

---

**记号与定义.**
设 $\,\mathrm{diff}_i = \mathrm{gas}_i - \mathrm{cost}_i\,$（$i=0,\dots,n-1$）。
定义（**含当前项**）前缀和
$$
\mathrm{prefix}_{-1}=0,\qquad
\mathrm{prefix}_i=\sum_{t=0}^{i}\mathrm{diff}_t\quad (i=0,\dots,n-1).
$$
令总净油量
$$
T=\mathrm{prefix}_{n-1}=\sum_{i=0}^{n-1}\mathrm{diff}_i.
$$
记前缀和全局最小值
$$
m=\min_{-1\leqslant k\leqslant n-1}\mathrm{prefix}_k,\qquad
J=\big\{\,j\in\{-1,0,\dots,n-1\}\mid \mathrm{prefix}_j=m\,\big\}.
$$

**定理（充要性）.**
若 $T<0$，则无解；若 $T\geqslant 0$，则所有且仅有形如
$$
S=\{\, (j+1)\bmod n \mid j\in J \,\}
$$
的下标可作为可行起点（从该站出发能绕圈且沿途油量不为负）。

**证明.**

*充分性.*
取任意 $j\in J$，令起点 $s=(j+1)\bmod n$。分两段讨论沿途油量 $\mathrm{gasoline}$：

1) 不绕回（走 $s\to k$ 且 $k\geqslant s$）：
$$
\mathrm{gasoline}
= \underbrace{\mathrm{prefix}_k}_{\sum_{0..k}}
- \underbrace{\mathrm{prefix}_{s-1}}_{=\mathrm{prefix}_j}
= \mathrm{prefix}_k-\mathrm{prefix}_j
\geqslant m-m=0,
$$
因为 $\mathrm{prefix}_j$ 为全局最小，故 $\mathrm{prefix}_k\geqslant m$。

2) 绕回（末端再回到 $k<s$）：
$$
\mathrm{gasoline}
= \big(\mathrm{prefix}_{n-1}-\mathrm{prefix}_{s-1}\big)+\mathrm{prefix}_k
= T+\mathrm{prefix}_k-\mathrm{prefix}_j
\geqslant T+m-m=T\geqslant 0.
$$
两段均不为负，故可行。

*必要性.*
将 $\mathrm{diff}$ 拼接两遍得到长度 $2n$ 的序列，记其前缀为 $\mathrm{prefix}'$，满足
$$
\mathrm{prefix}'_k=\mathrm{prefix}_k\ (0\leqslant k\leqslant n-1),\qquad
\mathrm{prefix}'_{n-1+i}=T+\mathrm{prefix}_i\ (0\leqslant i\leqslant n-1).
$$
补充定义 $\mathrm{prefix}'_{-1}=0$，则从起点 $s$ 出发走整整 $n$ 步，对窗口
$$
W=\{\,t\mid s-1\leqslant t\leqslant s+n-1\,\}
$$
沿途油量序列为
$$
\{\ \mathrm{prefix}'_t-\mathrm{prefix}'_{s-1}\ :\ t\in W\ \}.
$$
“全程不为负” 当且仅当
$$
\mathrm{prefix}'_{s-1}=\min_{t\in W}\mathrm{prefix}'_t.
$$
而 $\mathrm{prefix}'$ 在任意长度为 $n$ 的窗口内的最小值只会出现在对应
$\mathrm{prefix}$ 取到全局最小 $m$ 的位置 $j$（或其平移 $j+n$）：
后半段只是整体加上常数 $T$，不改变相对大小。
故必存在 $j\in J$ 使 $s-1=j$，即 $s=(j+1)\bmod n$。$\square$

**备注.**
若 $J$ 含多个最小位置，则对应有多个可行起点；若唯一，则起点唯一。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        // long[] prefix = new long[n];
        long sum = 0;
        long min = Long.MAX_VALUE;
        int minIndex = -1;
        for (int i = 0; i < n; i++) {
            // prefix[i] = gas[i] - cost[i] + prefix[i - 1];
            sum += gas[i] - cost[i];
            if (sum < min) {
                min = sum;
                minIndex = i;
            }
        }

        if (sum < 0) return -1;
        
        int gasoline = 0;
        for (int i = 0; i < n; i++) {
            int index = (minIndex + 1 + i) % n;
            gasoline += gas[index] - cost[index];
            if (gasoline < 0) return -1;
        }

        return (minIndex + 1) % n;
    }
}
```

# 等价的贪心算法写法

维护当前前缀和 `sum` （等价于 `prefix[i]`）与当前油箱容量 `gasoline`，若 `gasoline < 0` 则令起点重置至 `i + 1` 并清零 `gasoline` 以重置状态，否则视为继续照常行驶。当算法结束时，若有 `sum >= 0` 则说明最后重置的起点即为问题的解，否则问题无解，返回 `-1`。

这样实现的算法与前缀和数组是等价的，是典型的贪心算法风格。