题目简述：

> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
>
> 你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

题目链接：[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

# 前言

> ***这里堆排序的实现可能不太优雅，因为这是我较早期所撰写的解答。但也可以保证是正确的，只是代码风格可能不够好。***
>
> ***推荐先移步至我对 [LCR 159. 库存管理 III](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/) 问题编写的题解。两个问题是一样的，但那里的实现更成熟。***
>
> ***或者我在 [面试题 17.14. 最小K个数](https://leetcode.cn/problems/smallest-k-lcci/) 的实现也很美！***

# 快速选择算法

算法的平均时间复杂度为 $O(n)$，最坏时间复杂度为 $O(n^2)$，平均空间复杂度为 $O(\log n)$，最坏空间复杂度为 $O(n)$。

```java
class Solution {

    Random rand = new Random("ickk".hashCode());

    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        // 转为第 k 小元素问题，便于配合快速选择算法的逻辑
        k = n - k + 1;
        return quickChoice(nums, k, 0, n - 1);
    }

    private int quickChoice(int[] nums, int k, int lo, int hi) {
        int pivot = lo + rand.nextInt(hi - lo + 1);
        int pivotVal = nums[pivot];

        int l = lo;
        int r = hi;
        int i = lo;
        while (i <= r) {
            int num = nums[i];
            if (num < pivotVal) {
                swap(nums, i, l);
                l++;
                i++;
            } else if (num > pivotVal) {
                swap(nums, i, r);
                r--;
            } else {
                i++;
            }
        }

        // 执行到这里时，l 恰是等于区闭区间的起始，r 恰是等于区闭区间的结束
        if (l + 1 <= k && r + 1 >= k) {
            return pivotVal;
        } else if (l + 1 > k) {
            // 这种情况下，第 k 小元素只可能位于小于区
            return quickChoice(nums, k, lo, l - 1);
        } else {
            // 这种情况下，第 k 小元素只可能位于大于区
            return quickChoice(nums, k, r + 1, hi);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

# 基于数组手搓最大堆

算法的时间复杂度为 $O(n+k\log n)$。如果允许直接修改原数组，可以做到 $O(1)$ 的空间复杂度。

```java
/**
 * 逻辑与 MaxHeapBaseOnArrayList 完全相同（甚至连方法签名都一样），因此这里省略注释，请见后文 MaxHeapBaseOnArrayList
 */
public class MaxHeapBaseOnArray {
    private int[] maxHeap;
    private int size;

    public MaxHeapBaseOnArray() {
        maxHeap = new int[10];
        size = 0;
    }

    public MaxHeapBaseOnArray(int[] arr) {
        maxHeap = Arrays.copyOf(arr, arr.length);
        size = arr.length;
        for (int index = lastNonLeafIndex(); index >= 0; index--) {
            shiftDown(index);
        }
    }

    private int parent(int index) {
        return (index - 1) / 2;
    }

    private int left(int index) {
        return 2 * index + 1;
    }

    private int right(int index) {
        return 2 * index + 2;
    }


    private int lastNonLeafIndex() {
        return size / 2 - 1;
    }

    private boolean exists(int index) {
        return index >= 0 && index < size;
    }

    private void swap(int i, int j) {
        int temp = maxHeap[i];
        maxHeap[i] = maxHeap[j];
        maxHeap[j] = temp;
    }

    private int getMaxChildIndex(int index) {
        int left_index = left(index);
        int right_index = right(index);

        boolean leftExists = exists(left_index);
        boolean rightExists = exists(right_index);

        if (leftExists && rightExists) {
            return (maxHeap[left_index] >= maxHeap[right_index]) ? left_index : right_index;
        } else if (leftExists) {
            return left_index;
        } else if (rightExists) {
            return right_index;
        } else {
            return -1;
        }
    }

    private void shiftDown(int index) {
        int current = index;
        while (true) {
            int maxChild = getMaxChildIndex(current);
            if (maxChild == -1 || maxHeap[current] >= maxHeap[maxChild]) break;
            swap(current, maxChild);
            current = maxChild;
        }
    }

    private void shiftUp(int index) {
        int current = index;
        while (current > 0) {
            int parent = parent(current);
            if (maxHeap[parent] >= maxHeap[current]) break;
            swap(current, parent);
            current = parent;
        }
    }

    private void ensureCapacity() {
        if (size == maxHeap.length) {
            maxHeap = Arrays.copyOf(maxHeap, maxHeap.length * 2);
        }
    }

    public void offer(int value) {
        ensureCapacity();
        maxHeap[size] = value;
        shiftUp(size);
        size++;
    }

    public void remove(int index) {
        if (!exists(index)) throw new IndexOutOfBoundsException();
        swap(index, size - 1);
        size--;

        if (index > 0 && maxHeap[index] > maxHeap[parent(index)]) {
            shiftUp(index);
        } else {
            shiftDown(index);
        }
    }

    public int inPlaceTopK(int k) {
        if (k < 1 || k > size) throw new IndexOutOfBoundsException();
        for (int i = 0; i < k - 1; i++) {
            remove(0);
        }
        return maxHeap[0];
    }

    public MaxHeapBaseOnArray(MaxHeapBaseOnArray original) {
        this.maxHeap = Arrays.copyOf(original.maxHeap, original.maxHeap.length);
        this.size = original.size;
    }

    public int topK(int k) {
        MaxHeapBaseOnArray tempHeap = new MaxHeapBaseOnArray(this);
        return tempHeap.inPlaceTopK(k);
    }

    public int[] getMaxHeapArray() {
        return Arrays.copyOf(maxHeap, size);
    }
}

class Solution {
    public int findKthLargest(int[] nums, int k) {
        MaxHeapBaseOnArray h = new MaxHeapBaseOnArray(nums);
        return h.topK(k);
    }
}
```

# 基于ArrayList手搓最大堆

复杂度分析同上，代码如下所示：

```java
public class MaxHeapBaseOnArrayList {
    /**
     * MaxHeap 在逻辑上维护了一颗完全二叉树，但不必显式存储树的各节点，利用完全二叉树的性质可以方便地计算出父子节点值在数组中的索引
     */
    private ArrayList<Integer> maxHeap;

    public MaxHeapBaseOnArrayList() {
        maxHeap = new ArrayList<>();
    }

    /**
     * Heapify 算法：将输入数组封装为 ArrayList 并维护逻辑上的完全二叉树结构。
     * 该算法通过下沉实现，时间复杂度为 O(n)；虽然也可以通过逐个插入并上浮达到目的，但这样时间复杂度为 O(nlogn)，效率不高。
     *
     * @param arr 输入数组
     */
    public MaxHeapBaseOnArrayList(int[] arr) {
        maxHeap = Arrays.stream(arr)
                .boxed()
                .collect(Collectors.toCollection(ArrayList::new));
        for (int index = lastNonLeafIndex(); index >= 0; index--) {
            shiftDown(index);
        }
    }

    public MaxHeapBaseOnArrayList(ArrayList<Integer> arr) {
        maxHeap = arr;
        for (int index = lastNonLeafIndex(); index >= 0; index--) {
            shiftDown(index);
        }
    }

    // index = 0 意味着该元素为根节点，此时 parent 将返回 0
    private int parent(int index) {
        return (index - 1) / 2;
    }

    private int left(int index) {
        return 2 * index + 1;
    }

    private int right(int index) {
        return 2 * index + 2;
    }

    private int lastNonLeafIndex() {
        return maxHeap.size() / 2 - 1;
    }

    private boolean exists(int index) {
        return index >= 0 && index < maxHeap.size();
    }

    private void swap(int index_i, int index_j) {
        int temp = maxHeap.get(index_i);
        maxHeap.set(index_i, maxHeap.get(index_j));
        maxHeap.set(index_j, temp);
    }

    /**
     * 如果左子节点或右子节点存在则返回最大子节点的索引，否则返回 -1
     *
     * @param index 父节点索引
     * @return 返回最大子节点索引，若不存在则返回 -1
     */
    private int getMaxChildIndex(int index) {
        int left_index = left(index);
        int right_index = right(index);
        if (exists(left_index) && exists(right_index)) {
            if (maxHeap.get(left_index) >= maxHeap.get(right_index)) {
                return left_index;
            } else {
                return right_index;
            }
        } else if (exists(left_index)) {
            return left_index;
        } else if (exists(right_index)) {
            return right_index;
        } else {
            return -1;
        }
    }

    /**
     * 上浮：插入或删除元素时通过上浮维护完全二叉树。
     * 如果父节点小于当前节点，交换父节点与当前节点，并将交换后的父节点视为当前节点重新执行该流程；
     * 如果父节点大于等于当前节点或父节点不存在，则终止。注意，根据公式计算出根节点的父节点为其自身，因此无需额外处理。
     *
     * @param index 上浮起始索引
     */
    private void shiftUp(int index) {
        int currentIndex = index;
        int parentIndex = parent(index);
        while (exists(parentIndex)) {
            if (maxHeap.get(parentIndex) >= maxHeap.get(currentIndex)) {
                return;
            } else {
                swap(currentIndex, parentIndex);
                currentIndex = parentIndex;
                parentIndex = parent(parentIndex);
            }
        }
    }

    /**
     * 下沉：构建或删除元素时通过下沉维护完全二叉树。
     * 如果当前节点值小于最大子节点值，交换当前节点与最大子节点（实际上只需要交换值value和索引index），并将交换前的父节点视为当前节点重新执行该流程；
     * 如果当前节点大于等于左右子节点或左右子节点均不存在，则终止。注意，根据公式计算出根节点的父节点为其自身，因此无需额外处理。
     * 下沉的本质是使当前子树满足最大堆的性质。
     *
     * @param index 下沉起始索引，即当前子树的根
     */
    private void shiftDown(int index) {
        int currentIndex = index;
        while (true) {
            int maxChildIndex = getMaxChildIndex(currentIndex);
            if (maxChildIndex == -1) {
                return;
            } else if (maxHeap.get(currentIndex) >= maxHeap.get(maxChildIndex)) {  // 如果要构建最小堆，将调用替换为 minChildIndex 并将条件改为 > 即可
                return;
            } else {
                swap(currentIndex, maxChildIndex);
                currentIndex = maxChildIndex;
            }
        }
    }

    public ArrayList<Integer> getMaxHeap() {
        return maxHeap;
    }

    public int[] getMaxHeapArray() {
        return maxHeap.stream()
                .mapToInt(Integer::intValue)
                .toArray();
    }

    public int get(int index) {
        if (!exists(index)) throw new IndexOutOfBoundsException();
        return maxHeap.get(index);
    }

    public void offer(int value) {
        maxHeap.add(value);
        shiftUp(maxHeap.size() - 1);
    }

    public int poll() {
        return maxHeap.removeLast();
    }

    public void remove(int index) {
        if (!exists(index)) throw new IndexOutOfBoundsException();
        if (index == maxHeap.size() - 1) {
            maxHeap.removeLast();
            return;
        }

        maxHeap.set(index, maxHeap.removeLast());

        if (index > 0 && maxHeap.get(index) > maxHeap.get(parent(index))) {
            shiftUp(index);
        } else {
            shiftDown(index);
        }
    }

    public int inPlaceTopK(int k) {
        if (k < 1 || k > maxHeap.size()) throw new IndexOutOfBoundsException();
        for (int i = 0; i < k - 1; i++) {
            remove(0);  // 对于基于数组的最大堆，其首个元素一定是全局最大元素（完全二叉树的根节点）
        }
        return maxHeap.getFirst();
    }

    public int topK(int k) {
        if (k < 1 || k > maxHeap.size()) throw new IndexOutOfBoundsException();
        MaxHeapBaseOnArrayList tempHeap = new MaxHeapBaseOnArrayList(maxHeap);
        return tempHeap.inPlaceTopK(k);
    }
}

class Solution {
    public int findKthLargest(int[] nums, int k) {
        MaxHeapBaseOnArrayList h = new MaxHeapBaseOnArrayList(nums);
        return h.topK(k);
    }
}
```

# 利用优先队列高效实现最大堆

复杂度分析同上，代码如下所示：

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        /**
         * 如果不显式指定逆序比较器，优先级队列默认实现最小堆
         */
        // PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        List<Integer> list = Arrays.stream(nums).boxed().toList();
        pq.addAll(list);
        return topK(pq, k);
    }
    
    public static int topK(PriorityQueue pq, int k) {
        for (int i = 0; i < k - 1; i++) {
            pq.poll();
        }
        return (int) pq.poll();
    }
}
```

