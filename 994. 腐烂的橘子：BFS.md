题目简述：

> 在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：
>
> - 值 `0` 代表空单元格；
> - 值 `1` 代表新鲜橘子；
> - 值 `2` 代表腐烂的橘子。
>
> 每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。
>
> 返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

题目链接：[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

# 思路

考虑 BFS，初始化时让所有的烂橘子入队（与此同时可以统计新鲜橘子数量并在稍后 BFS 中动态更新该值，避免最后再遍历看看是否存在新鲜橘子），最后只需要判断是否还存在新鲜橘子。

该写法的好处是作为标准 BFS，性能非常高的同时可以保证不修改输入数组。

---

实现时有一个小技巧，Java 的 `int` 是 32 位的，要表示一对 `int` 不必写一个包装类 `Pair`，可以用 64 位的 `long` 直接表示——高 32 位表示纵坐标，低 32 位表示横坐标：`((long) i << 32) | (j & 0xFFFFFFFFL)`。

这里 `0xFFFFFFFFL` 是为了避免 `j` 为负数时类型提升为 `long` 后补码表示符号的高位干扰到结果的高 32 位——虽然其实在算法中 `j` 始终非负。

# 代码

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        Deque<Long> queue = new ArrayDeque<>();
        int fresh = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    fresh++;
                } else if (grid[i][j] == 2) {
                    queue.offer(pair(i, j));
                }
            }
        }

        int order = 0;
        int count = queue.size();
        boolean justRotted = false;
        while (!queue.isEmpty()) {
            long pair = queue.poll();
            count--;

            int i = getI(pair);
            int j = getJ(pair);

            if (i > 0 && grid[i - 1][j] == 1) {
                queue.offer(pair(i - 1, j));
                grid[i - 1][j] = 2;
                fresh--;
                justRotted = true;
            }

            if (i < m - 1 && grid[i + 1][j] == 1) {
                queue.offer(pair(i + 1, j));
                grid[i + 1][j] = 2;
                fresh--;
                justRotted = true;
            }

            if (j > 0 && grid[i][j - 1] == 1) {
                queue.offer(pair(i, j - 1));
                grid[i][j - 1] = 2;
                fresh--;
                justRotted = true;
            }

            if (j < n - 1 && grid[i][j + 1] == 1) {
                queue.offer(pair(i, j + 1));
                grid[i][j + 1] = 2;
                fresh--;
                justRotted = true;
            }

            if (count == 0) {
                if (!justRotted && fresh == 0) return order;  // 避免无有效腐烂传播的 BFS 也被计数
                order++;
                justRotted = false;
                count = queue.size();
            }
        }

        if (fresh > 0) return -1;
        return order;
    }

    private long pair(int i, int j) {
        return ((long) i << 32) | (j & 0xFFFFFFFFL);
    }

    private int getI(long pair) {
        return (int) (pair >>> 32);
    }

    private int getJ(long pair) {
        return (int) pair;
    }
}
```

