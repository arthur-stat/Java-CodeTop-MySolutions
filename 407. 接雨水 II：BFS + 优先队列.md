题目简述：

> 给你一个 `m x n` 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。

题目链接：[407. 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/)

# 试错纪实

我曾分别试图将 [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) 中的相向双指针解法与单调栈 NGE / PGE 解法直接推广至三维情况以解决本问题，后来发现均不可行。

错误的相向双指针推广：

```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;
        int[][] x = new int[m][n];
        int[][] y = new int[m][n];

        // 横向相向双指针
        for (int row = 0; row < m; row++) {
            int i = 0;
            int j = n - 1;
            int iMax = 0;
            int jMax = 0;

            while (i <= j) {
                if (iMax < jMax) {
                    iMax = Math.max(iMax, heightMap[row][i]);
                    x[row][i] = iMax;
                    i++;
                } else {
                    jMax = Math.max(jMax, heightMap[row][j]);
                    x[row][j] = jMax;
                    j--;
                }
            }
        }

        // 纵向相向双指针
        for (int col = 0; col < n; col++) {
            int i = 0;
            int j = m - 1;
            int iMax = 0;
            int jMax = 0;

            while (i <= j) {
                if (iMax < jMax) {
                    iMax = Math.max(iMax, heightMap[i][col]);
                    y[i][col] = iMax;
                    i++;
                } else {
                    jMax = Math.max(jMax, heightMap[j][col]);
                    y[j][col] = jMax;
                    j--;
                }
            }
        }

        int sup = 0;  // 递增柱体积
        int v = 0;    // 实际总体积
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                sup += Math.min(x[row][col], y[row][col]);
                v += heightMap[row][col];
            }
        }

        return  sup - v;
    }
}
```

错误的单调栈 NGE / PGE 推广：

```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;

        int[][] leftNextMax = new int[m][n];
        int[][] rightNextMax = new int[m][n];
        int[][] upNextMax = new int[m][n];
        int[][] downNextMax = new int[m][n];

        int[] rowStack = new int[n];  // 单调递减栈（自栈顶至栈底），栈内存储索引
        int top;  // 栈顶指针

        // 横向扫描
        for (int row = 0; row < m; row++) {
            top = -1;
            for (int col = 0; col < n; col++) {
                while (top > -1 && heightMap[row][rowStack[top]] < heightMap[row][col]) {
                    rightNextMax[row][top] = heightMap[row][col];
                    top--;
                }
                int tmp = top;
                while (tmp > -1 && heightMap[row][rowStack[tmp]] == heightMap[row][col]) tmp--;
                if (tmp > -1) leftNextMax[row][col] = heightMap[row][rowStack[tmp]];
                rowStack[++top] = col;
            }
        }

        int[] colStack = new int[m];

        // 纵向扫描
        for (int col = 0; col < n; col++) {
            top = -1;
            for (int row = 0; row < m; row++) {
                while (top > -1 && heightMap[colStack[top]][col] < heightMap[row][col]) {
                    downNextMax[top][col] = heightMap[row][col];
                    top--;
                }
                int tmp = top;
                while (tmp > -1 && heightMap[colStack[tmp]][col] == heightMap[row][col]) tmp--;
                if (tmp > -1) upNextMax[row][col] = heightMap[colStack[tmp]][col];
                colStack[++top] = row;
            }
        }

        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int minNextMax =  min4Four(leftNextMax[i][j], rightNextMax[i][j], upNextMax[i][j], downNextMax[i][j]);
                res += Math.max(0, minNextMax - heightMap[i][j]);
            }
        }

        return res;
    }

    private int min4Four(int a, int b, int c, int d) {
        return Math.min(a, Math.min(b, Math.min(c, d)));
    }
}
```

分析这些解法错误的原因，都是因为对于一个柱子只考虑到了他的前后左右的下一个更大值。在二维平面上这样考虑没有问题（即只考虑左右的下一个更大值），但对于三维平面这样考虑是不周全的，归根结底一个柱子能接多少水取决于整个三维空间下盆地的容积，而不仅仅由四个方向上的下一个更大值决定。

# 逐层扫描？

上文中错误的尝试告诉我们应转换思路。可以先尝试的方案是将三维空间的高度视为层，然后进行层序遍历 BFS。

每一层均为一个平面，对于每一层，我们只需要看该平面上有多少个封闭图形，那么所有封闭图形的面积就是这一层能够接住的雨水量。从最底层开始向上层遍历，都某一层不存在任何封闭图形时，即雨水量为 0，算法就可以终止了——因为柱子的堆叠方式决定了每一层能接的雨水量必然是递减的。

这样实现的算法正确性能够保证，但时间复杂度来到 $O(Hmn)$，在力扣的 `1 <= m, n <= 200`、`0 <= heightMap[i][j] <= 2 * 10^4` 数据范围下超时。

```java
class Solution {

    private int[][] heightMap;
    private int[][] layer;
    private int m;
    private int n;

    public int trapRainWater(int[][] heightMap) {
        this.heightMap = heightMap;
        m = heightMap.length;
        n = heightMap[0].length;
        layer = new int[m][n];  // 一个平面，稍后将进行 BFS

        int res = 0;
        for (int level = 1; true; level++) {
            int rainy = calculateLayer(level);
            if (rainy == -1) return res;
            res += rainy;
        }
    }

    // 针对一个平面，计算其中被柱子 (1) 包围的封闭空气 (0) 面积
    private int calculateLayer(int level) {
        /* 算法思路是首先累加所有空气，然后再从外侧每个点染色传播剪去非封闭的空气 */

        int air = updateLayer(level);
        // 如果平面已高于柱子的最高点，返回 -1
        if (air == -1) return -1;

        int unsealedAir = 0;
        for (int i = 0; i < m; i++) {
            unsealedAir += spread(i, 0);
            unsealedAir += spread(i, n - 1);
        }
        for (int j = 1; j < n - 1; j++) {
            unsealedAir += spread(0, j);
            unsealedAir += spread(m - 1, j);
        }
        
        return air - unsealedAir;
    }

    // 计算从底至上第 level 层的平面，平面上 0 表示空气，1 表示柱子，返回空气的总面积
    private int updateLayer(int level) {
        // 如果平面已高于柱子的最高点，即 valid 为 false，返回 -1
        boolean valid = false;
        int air = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (heightMap[i][j] >= level) {
                    layer[i][j] = 1;
                    valid = true;
                } else {
                    layer[i][j] = 0;
                    air++;
                }
            }
        }
        if (!valid) return -1;
        return air;
    }

    // 传播非封闭的空气，返回非封闭空气的面积
    private int spread(int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n || layer[i][j] == 1) return 0;

        layer[i][j] = 1;
        int count = 1;
        count += spread(i - 1, j);
        count += spread(i + 1, j);
        count += spread(i, j - 1);
        count += spread(i, j + 1);

        return count;
    }
}
```

# BFS + 优先队列

看来不可以逐层扫描，尽管算法最终能够得到正确结果。当下只能将视野转移至二维矩阵 `heightMap` 的扫描上。但我想不到更好的方案。

上网搜索后，发现本问题可以考虑加权泛洪算法，加权泛洪的经典实现是 BFS + 优先队列。这样我们就有头绪了。

我是在看了 [LeetCode407 3D接雨水，最最臭名昭著劝退题，真的很难吗？](https://www.bilibili.com/video/BV18P411n7AF) 可视化的视频及评论区后才知道怎么做的。

定义水平面高度 `level` 为 `max(当前点柱子高度, 邻居的水面高度)`，首先将最外圈的点都 `offer()` 收入优先队列，然后 `poll()` 出水平面最低的点。根据木桶效应，当前全局水平面至少为 `level`，且对于该点的邻居而言水平面就为 `level`——高于 `level` 的水会因为该点短板而流出，于是将该点未曾入队的邻居加入队列，邻居的水平面定义为 `max(邻居柱子高度, 刚刚出队点的柱子高度)`，并在此时结算邻居对于水平面 `level` 能接住多少雨水。

最终当优先队列为空时，我们就结算了所有点上能容纳的雨水量。

# 实现

算法的时间复杂度为 $O\big(mn\log(mn)\big)$，空间复杂度为 $O(mn)$。

```java
record Edge(int i, int j, int level) {}

class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;
        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> Integer.compare(a.level(), b.level());
        boolean[][] visited = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            update(heightMap, visited, heightMap[i][0], i, 0, pq);
            update(heightMap, visited, heightMap[i][n - 1], i, n - 1, pq);
        }
        for (int j = 1; j < n - 1; j++) {
            update(heightMap, visited, heightMap[0][j], 0, j, pq);
            update(heightMap, visited, heightMap[m - 1][j], m - 1, j, pq);
        }

        int rainy = 0;
        while (!pq.isEmpty()) {
            Edge e = pq.poll();
            int i = e.i();
            int j = e.j();
            int level = e.level();
            rainy += update(heightMap, visited, level, i + 1, j, pq);
            rainy += update(heightMap, visited, level, i - 1, j, pq);
            rainy += update(heightMap, visited, level, i, j + 1, pq);
            rainy += update(heightMap, visited, level, i, j - 1, pq);
        }

        return rainy;
    }

    private int update(int[][] heightMap, boolean[][] visited, int height, int i, int j, PriorityQueue<Edge> pq) {
        if (i < 0 || i >= heightMap.length || j < 0 || j >= heightMap[0].length || visited[i][j]) return 0;
        
        int level = Math.max(height, heightMap[i][j]);
        visited[i][j] = true;
        pq.offer(new Edge(i, j, level));
        return Math.max(0, level - heightMap[i][j]);
    }
}
```
