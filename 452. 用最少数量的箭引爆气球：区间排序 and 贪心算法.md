题目简述：

> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。
>
> 一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
>
> 给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

题目链接：[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

# 思路

<u>在区间排序后，每次选择射击区间右端点值中的最小值。</u>

这种贪心算法的题目，有点考记忆力的味道。贪心策略十分简单，代码十分容易编写，但如何意识到这是一个贪心算法问题？又如何得到可用的贪心策略？不知道……

只好总结一下有哪些常见的、涉及区间的贪心算法问题：

- 区间调度

  - 选出最多个互不重叠的区间
  - 最少删多少个区间使之互不重叠（例如 [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)）

  按右端点排序，总是优先选右端点最小的区间。

- 区间合并

  - 将所有重叠的区间合并为并集，输出合并后的若干段

  按左端点排序，维护当前合并段，如果不重叠则另开辟新段。

- 区间刺点

  - 例如本问题

  按右端点排序，总是优先选右端点最小的区间。

# 代码

算法的平均时间复杂度为 $O(n\log n)$，平均空间复杂度为 $O(\log n)$——这些开销均主要来自于快速排序算法。

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
        long lastShoot = Integer.MIN_VALUE - 1L;
        int count = 0;
        for (int i = 0; i < points.length; i++) {
            if (points[i][0] <= lastShoot) continue;
            lastShoot = (long) points[i][1];
            count++;
        }
        return count;
    }
}
```

