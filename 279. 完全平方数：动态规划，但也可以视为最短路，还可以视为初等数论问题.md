题目简述：

> 给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。
>
> **完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。
>
> **提示：**
>
> - `1 <= n <= 10^4`

题目链接：[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

# 动态规划

## 思路

这个问题还是比较明显可以应用动态规划算法的，因为该问题显然具有一定的最优子结构。

设 $dp[i]$ 表示和为 $i$ 的完全平方数的最少数量，则
$$
dp[i]=\min\{dp[i-j^2]+1:i>j^2\}
$$
补充定义 $dp[0]=0$。

> 看到一篇文章以背包模型视角解决这个问题，我认为完全没有必要。

## 代码

时间复杂度是 $O(n\sqrt{n})$，空间复杂度是 $O(n)$。

AC 时花费 25ms。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            int res = Integer.MAX_VALUE;
            int j = 1;
            while (j * j <= i) {
                res = Math.min(res, dp[i - j * j]);
                j++;
            }
            dp[i] = res + 1;
        }

        return dp[n];
    }
}
```

# 最短路（BFS）

## 思路

将问题视为：

- 状态：一个整数值 `x`，初始状态是 `n`

- 转移：从 `x` 可以跳到 `x - s`，其中 `s` 是一个平方数（`1, 4, 9, …` 且 ≤ `x`）

- 目标：走到 `0`

- 代价：每次操作算一步

那么问题就变为了在一张「从 `n` 开始，每次减去一个平方数」的图里，求最短步数到达 `0`。

BFS 算法结束时的层数就是问题的解。

## 待改进代码

时间复杂度非常高，似乎接近指数爆炸，因为没有记忆化搜索。

AC 时花费 84 ms。

```java
class Solution {
    public int numSquares(int n) {
        Deque<Integer> q = new ArrayDeque<>();
        int layer = 1;
        int thisLayerNum = 1;
        int nextLayerNum = 0;
        q.offer(n);

        main_loop:
        while (true) {
            int num = q.poll();
            thisLayerNum--;
            for (int i = 1; i * i <= num; i++) {
                q.offer(num - i * i);
                nextLayerNum++;
                if (num == i * i) break main_loop;
            }

            if (thisLayerNum == 0) {
                thisLayerNum = nextLayerNum;
                nextLayerNum = 0;
                layer++;
            }
        }

        return layer;
    }
}
```

## 记忆化搜索改进

和动态规划一样，时间复杂度是 $O(n\sqrt{n})$，空间复杂度是 $O(n)$。

AC 时花费 9 ms。

```java
class Solution {
    public int numSquares(int n) {
        Deque<Integer> q = new ArrayDeque<>();
        boolean[] visited = new boolean[n + 1];
        int layer = 1;
        int thisLayerNum = 1;
        int nextLayerNum = 0;
        q.offer(n);

        main_loop:
        while (true) {
            int num = q.poll();
            thisLayerNum--;
            for (int i = 1; i * i <= num; i++) {
                if (!visited[num - i * i]) {
                    q.offer(num - i * i);
                    nextLayerNum++;
                    visited[num - i * i] = true;
                    if (num == i * i) break main_loop;
                }
            }

            if (thisLayerNum == 0) {
                thisLayerNum = nextLayerNum;
                nextLayerNum = 0;
                layer++;
            }
        }

        return layer;
    }
}
```

# 数论

## 引言

要用什么 Lagrange 四平方定理，作为（前）数学系学生、在数学与统计学院读本硕的研究生，我专门上过数论课都没听过这东西，不知道又是哪个 oi 赛棍喜欢的。如果感兴趣请参考官方题解：[完全平方数](https://leetcode.cn/problems/perfect-squares/solutions/822940/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/)，我反正没兴趣。
