题目简述：

> 给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

题目链接：[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

# 逐位计数

## 思路

32 位有符号整数至多只有 32 位，因此可以统计每一位上 1 出现的频次。

如果某一位上的频数恰被 3 整除，说明此位结果为 0，否则频数必然除 3 后余 1，说明此位结果为 1。

不必单独处理符号位，因为计数和还原均统一按补码的逻辑进行，程序在解释结果时也将按补码解释 `int`，符号位此时与普通位的地位是均等的。不需要再画蛇添足利用补码等于绝对值反码加一的公式想办法进一步处理。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] freq = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                if (isBitOne(num, i)) freq[i]++;
            }
        }

        int res = 0;
        for (int i = 0; i < 32; i++) {
            if (freq[i] % 3 == 1) res += 1 << i;
        }

        return res;
    }

    public boolean isBitOne(int num, int loc) {
        return (num >>> loc & 1) == 1;
    }
}
```

# DFA

## 思路

本来我想像 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 那样找到一种组合位运算直接一次逐元素计算，对于左结合运算 `#`，我规定
$$
\left\{\begin{align}
&1\#1\#1=0\\\\
&0\#0\#0=0\\\\
&1\#0=1\\\\
&0\#1=1\\\\
&0\#0=0
\end{align}\right.
$$
化简为真值表
$$
\begin{array}{cc|c}
\hline
A & B & A \# B \\
\hline
0 & 0 & 0 \\
0 & 1 & 0 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\hline
\end{array}
$$
进而得到卡诺图
$$
\begin{array}{c|cc}
A \backslash B & 0 & 1 \\
\hline
0 & 0 & 0 \\
1 & 1 & 0 \\
\end{array}
$$
进一步解得
$$
f(A,B)=A\bar{B}
$$
所以看上去 `a # b = a & ~b`。

但其实这样导出的 `#` 运算不能用于本问题，因为我们没考虑到运算是否满足结合律——实际上是不满足的。不难发现，如果取初值为 `0`，那么 `0` 与 `nums` 中的元素逐个取 `#` 运算并赋值给自己后，最后的结果一定还是 `0`，没有意义。

根本原因是该二元运算会破坏半群的性质，不属于半群内的运算。

---

后来看了其他人的解法，发现正确的思路应该是建模为 DFA。

在 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 中，DFA 只有两个状态；在本问题中，DFA 有三种状态。一个位上在统计频次的过程中可能出现三种状态，我们记为 $\alpha$、$\beta$、$\gamma$，分别表示 1 出现 $3k$ 次、$3k+1$ 次以及 $3k+2$ 次，当统计完成后只可能出现 $\alpha$ 状态与 $\beta$ 状态。统计的过程中，如果该位上为 0 则原地转移，否则转移至下一种状态。

由于一共有三种状态，因此我们分别用两个变量 $\lambda$ 以及 $\omega$ 的组合表示状态（用一个不够，用三个太多）。我们画出这样定义状态转移：
$$
\begin{array}{cc|c}
\hline
\lambda & \omega & state \\
\hline
0 & 0 & \alpha \\
0 & 1 & \beta \\
1 & 0 & \gamma \\
\hline
\end{array}
$$
$\lambda=1,\omega=1$ 未定义。

记输入比特为 $b$，根据定义，$b=0$ 时 $\lambda,\omega$ 原地转移，保持值不变，否则 $\lambda,\omega$ 转移至下一种状态，因此可以写出下述真值表：
$$
\begin{array}{ccc|cc}\hline\lambda & \omega & b & \lambda' & \omega'\\ \hline 0 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 1\\ 1 & 0 & 0 & 1 & 0\\ \hline 0 & 0 & 1 & 0 & 1\\ 0 & 1 & 1 & 1 & 0\\ 1 & 0 & 1 & 0 & 0\\\hline\end{array}
$$
进一步画出 $\lambda$ 与 $\omega$ 的两张卡诺图
$$
\begin{gathered}\lambda'\ \ \mathrm{K-map}\\\hline\begin{array}{|c|cc|}
\lambda \backslash \omega b & 00 & 01 & 11 & 10 \\
\hline
0 & 0 & 0 & 1 & 0 \\
1 & 1 & 0 & ? & ?\\\hline
\end{array}\end{gathered}
$$

$$
\begin{gathered}\omega'\ \ \mathrm{K-map}\\\hline\begin{array}{|c|cc|}
\lambda \backslash \omega b & 00 & 01 & 11 & 10 \\
\hline
0 & 0 & 1 & 0 & 1 \\
1 & 0 & 0 & ? & ?\\\hline
\end{array}\end{gathered}
$$

因此可以算出 $\lambda$ 与 $\omega$ 的公式
$$
\lambda'=\lambda\bar{\omega}\bar{b}\lor\bar{\lambda}\omega b
$$

$$
\omega'=\bar{\lambda}(\bar{\omega}b\lor\omega\bar{b})
$$

在注意力惊人的情况下，$\omega'$ 可以进一步化简
$$
\omega'=\bar{\lambda}(\omega\oplus b)
$$
现在我们只需要初始化 `lambda = 0`、`omega = 0`，然后遍历 `nums`，将 `num` 的各比特位视为 `b` 不断更新 `lambda` 与 `omega` 即可。当遍历结束时，根据定义，

- $\alpha$ 状态对应比特位重复 $3k$ 次的情况，定义中状态 $\alpha$ 对应的输入比特 $(\lambda,\omega)$ 则为 $(0,0)$
- $\beta$ 状态对应比特位重复 $3k+1$ 次的情况，定义中状态 $\beta$ 对应的输入比特 $(\lambda,\omega)$ 则为 $(0,1)$

这就是说，如果最终某比特位上那个不重复数字为比特 0，这是 $\alpha$ 状态，那么 `omega` 在对应比特位上恰为 0；最终某比特位上那个不重复数字为比特 1，这是 $\beta$ 状态，那么 `omega` 在对应比特位上恰为 1.所以，遍历结束后，将 `omega` 解释为 `int` 的结果就是那唯一不重复的数字。

---

在这里，我们就不需要担心此前 `#` 运算不满足半群运算性质而不存在结合律的问题，因为在模 3 剩余类群中一共就只有三个等价元素，每次进行一次状态转移，该转移是有方向的，只能转移至下一个状态。状态转移是确定性的函数组合，构成半群同态，天然满足结合性。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int lambda = 0;
        int omega = 0;

        for (int num : nums) {
            int lmd = lambda & ~omega & ~num | ~lambda & omega & num;
            int omg = ~lambda & (omega ^ num);
            lambda = lmd;
            omega = omg;
        }

        return omega;
    }
}
```

