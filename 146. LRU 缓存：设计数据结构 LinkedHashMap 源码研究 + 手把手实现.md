题目简述：

> 请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。
>
> 实现 `LRUCache` 类：
>
> - `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
> - `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
> - `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。
>
> 函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

题目链接：[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

# 前言

LRU 的进阶研究，可以参考我对 [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/) 编写的题解。要实现软件 LFU，必须对软件 LRU 深入且充分的理解。

因此，也可以说 [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/) 的基础上本问题。

# LinkedHashMap源码分析

如果看不懂可以直接读最后一章，看看我们具体是如何一步一步实现的。

总而言之，无论是用 JDK 提供的 LinkedHashMap，还是最后我们自己用 HashMap 与双向链表实现一个，本质上都是基于哈希表与双向链表这两种数据结构的组合。

## 基于HashMap

LinkedHashMap 这一哦数据结构天然就是 LRU 的软件模拟实现。为了深入理解，我们来看看 LinkedHashMap 源码。

首先我们要了解一下 Java 的 LinkedHashMap 在底层是怎么实现的。LinkedHashMap 基于 HashMap，HashMap 则是数组 + 红黑树 + 链表：

![图片引用自：https://www.linkedin.cn/incareer/pulse/hashmap-java-everything-you-need-know-omar-ismail](images/143lru_1.png)

LinkedHashMap 在 HashMap 的基础上添加了双向链表结构，也就是说支持顺序了，原本 HashMap 是无序的。具体而言，在节点 Entry 中添加指向上一个元素的指针 before 和下一个元素的指针 `after`，使之形成链表，再记录首元素指针 `head` 和尾元素指针 `tail` 形成双向链表，稍后我们可以在源码中看到这一点。

LinkedHashMap 的 `get` 和 `put` 基于 HashMap，本来就是 $O(1)$ 的，如果要利用 LinkedHashMap 那就只需要考虑如何利用 LinkedHashMap 的有序性实现最近最久未使用更新。

注：实际上 LinkedHashMap 基于 HashMap 的 `put` 的、会自动扩容的那俩方法是 `putFirst` 和 `putLast`，方便起见合称 `put` 了。

## 节点Entry

我们先大概看看节点，LinkedHashMap 的节点  `Entry` 继承自 HashMap 的 `Node`，不同的是额外添加了  `before` 和  `after` 指针，实现有序，我们现在来看看 `Entry` 的源码：

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements SequencedMap<K,V>
{

    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }

    transient LinkedHashMap.Entry<K,V> head;

    transient LinkedHashMap.Entry<K,V> tail;

    final boolean accessOrder;

    ...
```

注意这里还有个  `accessOrder` 字段，该字段默认为  `False` ，意思是按照元素的插入顺序维护键值对的遍历顺序，如果通过构造函数  `LinkedHashMap(int, float, boolean)` 设为 `True` 则访问操作 `get` 也会将元素移动到链表尾部——而不光光是 `put` 才触发。

## put（putFirst 和 putLast）

接下来我们先看看 `put` 是怎么更新顺序的，毕竟无论 `accessOrder` 的值是什么，LinkedHashMap 都会记录下插入的顺序。不过 `put` 本身不包含实际维护顺序的逻辑，顺序的维护是通过重写 `newNode` 回调将节点追加到双向链表的首部或尾部实现的。

```java
    ...
    
    private void linkNodeAtEnd(LinkedHashMap.Entry<K,V> p) {
        if (putMode == PUT_FIRST) {
            LinkedHashMap.Entry<K,V> first = head;
            head = p;
            if (first == null)
                tail = p;
            else {
                p.after = first;
                first.before = p;
            }
        } else {
            LinkedHashMap.Entry<K,V> last = tail;
            tail = p;
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
        }
    }
    
    ...

    public V putFirst(K k, V v) {
        try {
            putMode = PUT_FIRST;
            return this.put(k, v);
        } finally {
            putMode = PUT_NORM;
        }
    }

    public V putLast(K k, V v) {
        try {
            putMode = PUT_LAST;
            return this.put(k, v);
        } finally {
            putMode = PUT_NORM;
        }
    }

    ...
    
    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
        LinkedHashMap.Entry<K,V> p = new LinkedHashMap.Entry<>(hash, key, value, e);
        linkNodeAtEnd(p);
        return p;
    }
    
    ...
```

可以看到， `put` 时直接维护双向链表的首尾指针 `head` 与 `tail` 就好了，没有很复杂的逻辑。

至于缓存容量被设置为有限的这点——那插入的同时直接丢掉尾巴不就好了，只不过在丢的同时把尾巴指向的前一个元素设置为新的尾巴。但是 LinkedHashMap 的 `put` 是完全基于 HashMap 本来的 `put` 的，她默认 `put` 时自动扩容而不存在缓存容量上限的概念，所以我们不能直接调用这两个。这里介绍他俩只是为了探究 LinkedHashMap 源码并引出  `removeEldestEntry`，我们重写了这个 `put` 才会帮我们检查是否达到设定的缓存容量上限并在必要的时候删掉最老元素。

## get 和 getOrDefault

我们再看看 `get` 的源码。

```java
    ...
    
    public V get(Object key) {
        Node<K,V> e;
        if ((e = getNode(key)) == null)
            return null;
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
    }

    ...

    void afterNodeAccess(Node<K,V> e) {
        LinkedHashMap.Entry<K,V> last;
        LinkedHashMap.Entry<K,V> first;
        if ((putMode == PUT_LAST || (putMode == PUT_NORM && accessOrder)) && (last = tail) != e) {
            // move node to last
            LinkedHashMap.Entry<K,V> p =
                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
            p.after = null;
            if (b == null)
                head = a;
            else
                b.after = a;
            if (a != null)
                a.before = b;
            else
                last = b;
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        } else if (putMode == PUT_FIRST && (first = head) != e) {
            // move node to first
            LinkedHashMap.Entry<K,V> p =
                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
            p.before = null;
            if (a == null)
                tail = b;
            else
                a.before = b;
            if (b != null)
                b.after = a;
            else
                first = a;
            if (first == null)
                tail = p;
            else {
                p.after = first;
                first.before = p;
            }
            head = p;
            ++modCount;
        }
    }

    ...
```

可以看到 `get` 通过 `afterNodeAccess` 实现更新顺序的逻辑，看起来 `afterNodeAccess` 还挺冗长的，但我们仔细研究就会发现如果抛开更新模式不谈只以 `putMode == PUT_LAST` 为例的话，其实他就是做了以下的事情：

1. 断开当前节点与前后节点的连接；
2. 将当前节点链接到链表尾部，更新尾指针 `tail` 。

也没有什么难的嘛。（真的假的？）

至于 `getOrDefault`，他就是给 `get` 加了个默认值以符合类似题目要求键不存在时返回 `-1` 的设定，源码如下：

```java
    ...

    public V getOrDefault(Object key, V defaultValue) {
       Node<K,V> e;
       if ((e = getNode(key)) == null)
           return defaultValue;
       if (accessOrder)
           afterNodeAccess(e);
       return e.value;
   }

   ...
```

## removeEldestEntry 与 afterNodeInsertion

这两个方法源码如下，本身没提供实现，仅作为钩子：

```java
    ...

    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry<K,V> first;
        if (evict && (first = head) != null && removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }

    ...

    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
        return false;
    }

    ...
```

这个就是帮助我们实现淘汰最久未使用元素的关键。具体来说，LinkedHashMap 的 put 方法继承自 HashMap 的 `put` 实现，而 HashMap 的 `put` 方法在完成节点插入后会调用 `afterNodeInsertion` 进行后续的行为——默认是无后续行为，所以直接调用 `put` 默认行为就只是添加，容量不够就扩容，没有包括删除最老元素在内的后续操作。

更专业、标准的话来说，`afterNodeInsertion` 是 HashMap 留给子类扩展的钩子方法（Hook）。LinkedHashMap 重写了 `afterNodeInsertion`，重写后他将结合 `removeEldestEntry` 返回的布尔值确认是否要删除最老元素。

不过观察源码，`removeEldestEntry` 默认只返回 false，因此 `afterNodeInsertion` 默认情况下永不触发，所以我们需要自行重写并定义一下删除最老元素的时机。在LRU中，这个时机就是元素数量超过指定的capacity。

# 利用LinkedHashMap快速实现LRU策略

看了源码以后要利用 LinkedHashMap 实现 LRU 就超级容易了，毕竟 `java.util` 都帮我们实现好了全部功能直接用就行了，如下所述：

```java
class LRUCache {
    private LinkedHashMap<Integer, Integer> map;
    private final int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                return size() > LRUCache.this.capacity;
            }
        };
    }

    public int get(int key) {
        return map.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

# 利用哈希表、双向链表自己设计LRU

和 LinkedHashMap 的原理一样，都是使用一个哈希表和一个双向链表，结构如下：

![LinkedHashMap原理](images/143lru_2.png)

只有这样才能做到 $O(1)$ 时间复杂度的get和put。如上所述，这其实也就是 LinkedHashMap 的样子。

简单来讲，***关键是用哈希表存储键到节点的映射，而链表则通过节点存储值与值的实际更新顺序***，这样就能在高效率找到目标元素的同时记忆最近一次访问与最久未访问元素的顺序。***双向链表是隐含的，节点必须通过哈希表进行查询——除了更新时使用的首尾节点***。

```java
class LRUCache {

    int capacity;
    int size;
    Node dummy;  // 为简化实现，以 dummy 取代 head
    Node tail;
    final Map<Integer, Node> keyToNode;

    public LRUCache(int capacity) {
        this.capacity = capacity;  // 应检查 capacity 是否非负，此处略
        this.dummy = new Node(0, 0);
        size = 0;
        tail = dummy;
        keyToNode = new HashMap<>();
    }
    
    public int get(int key) {
        Node node = keyToNode.get(key);
        if (node == null) return -1;
        moveNodeToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        // if (capacity == 0) ... 此处略

        Node node = keyToNode.get(key);

        if (node != null) {
            // ====== 若 key 存在 ======
            node.value = value;
            moveNodeToHead(node);
        } else {
            // ====== 若 key 不存在，应插入 ======
            node = new Node(key, value);
            keyToNode.put(key, node);
            // 若缓存已满，首先执行 LRU 淘汰策略
            if (size == capacity) {
                keyToNode.remove(tail.key);
                tail.prev.next = null;
                tail = tail.prev;
                size--;
            }
            // 缓存未满或执行淘汰策略后，写入新节点
            Node head = dummy.next;
            dummy.next = node;
            if (head != null) head.prev = node;
            else tail = node;  // 更新 tail
            node.prev = dummy;
            node.next = head;
            size++;
        }
    }

    /**
     * 辅助方法，将节点移至头部（表示最近使用）
     */
    private void moveNodeToHead(Node node) {
        // 断开与现有节点的链接
        Node p = node.prev;
        Node n = node.next;
        p.next = n;
        if (n != null) n.prev = p;
        else tail = p;  // 更新 tail

        // 重新插入至 dummy 后
        Node head = dummy.next;
        dummy.next = node;
        if (head != null) head.prev = node;
        else tail = node;  // 更新 tail
        node.prev = dummy;
        node.next = head;
    }

    private static class Node {

        int key;
        int value;
        Node prev;
        Node next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public boolean equals(Object o) {
            if (o == null) return false;
            if (!(o instanceof Node node)) return false;
            return key == node.key;
        }

        @Override
        public int hashCode() {
            return key;
        }

        @Override
        public String toString() {
            return "{k: " + key + ", v: "+ value + "}";
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

