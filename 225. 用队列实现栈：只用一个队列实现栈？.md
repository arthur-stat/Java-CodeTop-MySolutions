题目简述：

> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
>
> 实现 `MyStack` 类：
>
> - `void push(int x)` 将元素 x 压入栈顶。
> - `int pop()` 移除并返回栈顶元素。
> - `int top()` 返回栈顶元素。
> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
>
> **进阶：**你能否仅用一个队列来实现栈。

题目链接：[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

# 前言

其实在 [LCR 125. 图书整理 II](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) 的题解中我就已经解决过这个问题了。在那里，我们不光用双栈模拟了队列，还用双队列模拟了栈。

但这里我们给出仅用一个队列的实现。

# 双队列实现

```java
class MyStack {

    Deque<Integer> d1 = new ArrayDeque<>();  // for input
    Deque<Integer> d2 = new ArrayDeque<>();  // for output
    int prev;
    
    public void push(int x) {
        d1.offer(x);
        prev = x;
    }
    
    public int pop() {
        int size = d1.size();
        for (int i = 0; i < size - 1; i++) {
            int num = d1.poll();
            d2.offer(num);
            prev = num;
        }
        int res = d1.poll();
        Deque<Integer> tmp = d2;
        d1 = d2;
        d2 = tmp;
        return res;
    }
    
    public int top() {
        return prev;
    }
    
    public boolean empty() {
        return d1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```

# 单队列实现

思路没区别，自己产的自己吃，循环 $n-1$ 就取出最近 `offer` 的元素了。

```java
class MyStack {

    Deque<Integer> d = new ArrayDeque<>();
    int prev;
    
    public void push(int x) {
        d.offer(x);
        prev = x;
    }
    
    public int pop() {
        int size = d.size();
        for (int i = 0; i < size - 1; i++) {
            int num = d.poll();
            d.offer(num);
            prev = num;
        }
        return d.poll();
    }
    
    public int top() {
        return prev;
    }
    
    public boolean empty() {
        return d.isEmpty();
    }
}
```

