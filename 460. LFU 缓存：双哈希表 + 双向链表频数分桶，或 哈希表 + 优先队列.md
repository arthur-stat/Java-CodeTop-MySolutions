题目简述：

> 请你为最不经常使用（LFU）缓存算法设计并实现数据结构。
>
> 实现 `LFUCache` 类：
>
> - `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象
> - `int get(int key)` - 如果键 `key` 存在于缓存中，则获取键的值，否则返回 `-1` 。
> - `void put(int key, int value)` - 如果键 `key` 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 `capacity` 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最久未使用** 的键。
>
> 为了确定最不常使用的键，可以为缓存中的每个键维护一个 **使用计数器** 。使用计数最小的键是最久未使用的键。
>
> 当一个键首次插入到缓存中时，它的使用计数器被设置为 `1` (由于 put 操作)。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。
>
> 函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

题目链接：[460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

# 引言

无论是 “哈希表 + 优先队列” 还是 “双哈希表 + 双向链表”，都可以视为是基于 LRU 的 LinkedHashMap 底层 “哈希表 + 双向链表” 的变形。

- 哈希表 + 优先队列：可视为用优先队列替换双向链表，显式写入每个节点的频数与上次访问时间，不过需要额外的逻辑维护 key 频数与上次访问时间；
- 双哈希表 + 双向链表频数分桶：可视为额外新增一个从 freq 映射到 LinkedHashSet 的哈希表，仅显式写入每个节点的频数，对每个频数单独用 LinkedHashSet 维护同频数内元素的上次访问时间顺序。

因此，务必确保已经充分理解了 [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)，务必确保十分熟悉 LinkedHashMap 的底层实现，否则不应直接尝试 [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)。

# 哈希表 + 优先队列

这是最简单直观的方案，尽管性能上没有 “双哈希表 + 双向链表” 的方案好，但是实现起来超级简单——如果使用 PriorityQueue 的话。当然，自己实现一个小顶堆也是完全可行的，只是稍微麻烦一些。

本方案并非解决本问题的最优方案，但一定是逻辑最简单易懂的方案之一。

> 虽然性能更高的 “双哈希表 + 双向链表频数分桶” 我觉得只要见过一次也就不难实现了，但至少初见的话，还是本方案更直观吧？

## 思路

此前我们用 JDK 提供的 LinkedHashMap 与基于其原理通过更底层的 HashMap 和双向链表分别软件模拟实现了 [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)。从底层数据结构上来说，哈希表 + 双向链表的组合，天然就符合 LRU 的逻辑。

要在此基础上结合优先队列改为 LFU，**<u>只需要将双向链表替换为优先队列</u>**。为此，可以设计一个节点类 Node，Node 包含 key、value、freq 以及 lastVisited 四个字段，哈希表将 key 映射到 Node（为了以 $O(1)$ 时间复杂度进行查询），优先队列在出队时优先让 freq 最少的节点出队（实现 LFU 主淘汰策略），如果存在多个 freq 最少的元素， 则令 lastVisited 最小的元素出队。其中，freq 为值为 key 被访问的频率，lastVisited 为上次 key 被访问的操作计数。

现在还留下最后一个问题，就是我们在更新了 Node 的 freq、lastVisited 后如何让优先队列同步更新 Node 状态的修改——毕竟优先队列是无法主动感知内部元素状态变化的。一个好的方案是**<u>懒删除</u>**，即需要更新节点的状态时我们不直接删除优先队列中的旧 Node，而是 `offer` 一个新 Node，新 Node 的状态为旧 Node 更新后的状态，并且修改哈希表 key 到 Node 的映射，从指向旧 Node 更新为指向新 Node。这样，当我们需要淘汰一个节点时，先判断出队节点是否有效——通过对比出队节点与哈希表中该 key 指向节点的内存地址是否相同进行判断。若地址相同，则该节点有效，我们顺利使一个有效的节点出队了；若地址不同，则该节点无效，意味着此时优先队列中存在一个同样的 key 但 freq 与 lastVisited 更新的节点，因此该节点被认为是需要额外出队的无效节点，于是触发懒删除，该节点出队后需要继续让下一个节点出队——直到一个有效的节点出队。

## 代码

设容量 capacity 为 $C$、执行操作数 opCounter 为 $T$、堆实际大小为 $H$，则

- `get(key)` 的平均时间复杂度为摊还 $O(\log H)$；
- `put(key, value)` 的平均时间复杂度为摊还 $O(\log H)$。

AC 时，耗时 84ms。

```java
class LFUCache {

    private Map<Integer, Node> map;
    private PriorityQueue<Node> pq;
    private long opCounter;
    private int pqValidSize;
    private int capacity;

    public LFUCache(int capacity) {
        map = new HashMap<>(capacity);
        pq = new PriorityQueue<>((n1, n2) -> {
            if (n1.freq != n2.freq) return Long.compare(n1.freq, n2.freq);
            return Long.compare(n1.lastVisited, n2.lastVisited);
        });
        opCounter = 0L;
        pqValidSize = 0;
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node elderNode = map.getOrDefault(key, null);
        if (elderNode == null) return -1;
        Node newerNode = new Node(key, elderNode.value, elderNode.freq + 1, ++opCounter);
        pq.offer(newerNode);
        map.put(key, newerNode);
        return newerNode.value;
    }
    
    public void put(int key, int value) {
        Node node = map.getOrDefault(key, null);
        if (node != null) {
            Node newerNode = new Node(key, value, node.freq + 1, ++opCounter);
            pq.offer(newerNode);
            map.put(key, newerNode);
        } else if (pqValidSize < capacity) {
            Node newNode = new Node(key, value, 1, ++opCounter);
            pq.offer(newNode);
            map.put(key, newNode);
            pqValidSize++;
        } else {
            while (!pq.isEmpty()) {
                Node obsoleteNode = pq.poll();
                if (map.get(obsoleteNode.key) == obsoleteNode) {
                    map.remove(obsoleteNode.key);
                    break;
                }
            }
            Node newNode = new Node(key, value, 1, ++opCounter);
            pq.offer(newNode);
            map.put(key, newNode);
        }
    }

    private static class Node {

        public int key;
        public int value;
        public long freq;
        public long lastVisited;

        public Node(int key, int value, long freq, long lastVisited) {
            this.key = key;
            this.value = value;
            this.freq = freq;
            this.lastVisited = lastVisited;
        }
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

# 双哈希表 + 双向链表频数分桶

这是本问题的最优方案，能够保证 `get(key)` 和 `put(key, value)` 的平均时间复杂度为 $O(1)$，且常数很小。

## 思路

这里需要借用 JDK 提供的数据结构 LinkedHashSet，因此简短介绍一下。如果说 LRU 缓存是 LinkedHashMap(key, value)，那么 LinkedHashSet 就是 LinkedHashMap(value, dummy)，其中 dummy 是哑对象，即 LinkedHashSet 是单值的——只存在一个值 value 而不存在 key，只不过为了实现能够维护顺序的 Set，将 LinkedHashSet 的 value 视为 LinkedHashMap 的 key，借用 LinkedHashMap 维护 LinkedHashSet 的 value 的访问顺序。由于并不需要 LinkedHashMap 的 value（LinkedHashSet 没有第二个值），因此 LinkedHashMap 的 value 用一个哑对象代替。

实际上，JDK 也正是这样实现的，LinkedHashSet 封装了一层 LinkedHashMap，dummy 为 `static final Object PRESENT = new Object();`。

注：下文中 LinkedHashSet(key) 的 key 指的是 `get(key)` 与 `put(key, value)` 的 key。

---

在 LRU 的 “哈希表 + 双向链表” 基础上，我们额外添加一个哈希表。这些数据结构各自的职责如下所述：

- **第一个哈希表 keyToNode**：做 key 到 Node 的映射，便于以 $O(1)$ 的时间开销查询 key。
- **第二个哈希表 freqToList**：做 freq 到**对应双向链表（桶）**的映射，用于在 $O(1)$ 时间内定位某个频数的链表，支持元素提升频数时在“旧桶→新桶”的快速迁移，以及在某个桶为空时将其从映射中移除。
- **双向链表**：按**频数分桶的多条链表**。每个频数对应一条独立的双向链表，链表中存放所有该频数的元素，并且链表内部维护访问顺序，最新访问的元素在链表头部，最久未访问的元素在链表尾部。这样我们既能以 $O(1)$ 的时间开销把某个元素从旧频数链表中摘下并插入到新频数链表中，又能以 $O(1)$ 的时间开销从最小频数链表的尾部淘汰最久未使用的元素。

需要注意的是，这里的双向链表与 LRU 中的双向链表的职责也有所不同。LRU 中只有淘汰最久未访问元素这一种更新策略，因此全局维护一条访问顺序链表即可，链表尾节点就是唯一的淘汰对象。而在 LFU 中，不同频数需要分别维护，因而我们维护的是**多条**双向链表，每条链表内部仍然保证 LRU 顺序。

事实上，第一个哈希表维护了 key 到 value 的正确映射，而 value 存储在 Node，Node 实际上是按频数分组的，对于不同频数 Node 并不是连续的，这也是与 LRU 很大的一个区别。在 LRU 中，Node 构成唯一一个全局的双向链表（而不是现在按频数分组的多个双向链表）。这也说明，事实上我们背后的思想是：先按频数分桶，每个桶内再考虑 LRU 的双向链表；最后靠第一个哈希表将各 Node 统一组织起来。

那我们动手实现吧！

## 代码

算法的摊还时间复杂度为严格 $O(1)$。

AC 时，耗时 51ms。

```java
public class LFUCache {
    private final int capacity;
    private final Map<Integer, Node> keyToNode = new HashMap<>();
    private final Map<Integer, DLList> freqToList = new HashMap<>();
    private int size = 0;
    private int minFreq = 0;

    public LFUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        Node node = keyToNode.get(key);
        if (node == null) return -1;
        increaseFreq(node);
        return node.val;
    }

    public void put(int key, int value) {
        if (capacity == 0) return;

        Node node = keyToNode.get(key);
        if (node != null) {
            node.val = value;
            increaseFreq(node);
            return;
        }

        if (size == capacity) {
            DLList list = freqToList.get(minFreq);
            Node victim = list.removeLast();
            keyToNode.remove(victim.key);
            size--;
            if (list.isEmpty()) freqToList.remove(minFreq);
        }

        Node fresh = new Node(key, value);
        fresh.freq = 1;
        keyToNode.put(key, fresh);
        freqToList.computeIfAbsent(1, f -> new DLList()).addFirst(fresh);
        minFreq = 1;
        size++;
    }

    private void increaseFreq(Node node) {
        int oldF = node.freq;
        DLList oldList = freqToList.get(oldF);
        oldList.remove(node);
        if (oldList.isEmpty()) {
            freqToList.remove(oldF);
            if (minFreq == oldF) minFreq++;
        }

        node.freq = oldF + 1;
        freqToList.computeIfAbsent(node.freq, f -> new DLList()).addFirst(node);
    }

    private static class Node {
        int key, val, freq = 0;
        Node prev, next;

        Node(int k, int v) {
            key = k;
            val = v;
        }
    }

    private static class DLList {
        private final Node head = new Node(-1, -1);
        private final Node tail = new Node(-1, -1);
        private int size = 0;

        DLList() {
            head.next = tail;
            tail.prev = head;
        }

        boolean isEmpty() {
            return size == 0;
        }

        void addFirst(Node node) {
            node.next = head.next;
            node.prev = head;
            head.next.prev = node;
            head.next = node;
            size++;
        }

        void remove(Node node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
            node.prev = node.next = null;
            size--;
        }

        Node removeLast() {
            Node last = tail.prev;
            remove(last);
            return last;
        }
    }
}
```

# 跳表

跳表只是 “”能 实现 LFU，但是逻辑复杂度非常高，而且性能与优先队列一样，也远远不如最优解 “双哈希表 + 双向链表频数分桶” 的方案，这里就不多介绍了。
