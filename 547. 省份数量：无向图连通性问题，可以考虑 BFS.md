题目简述：

> 有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。
>
> **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。
>
> 返回矩阵中 **省份** 的数量。

题目链接：[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

# 思路

这是一个典型的无向图连通性问题，`isConnected` 实际上是一个邻接矩阵。

我的思路是基于邻接矩阵进行 BFS 分量计数，通过 `visited` 矩阵保存访问状态，也利用 `visited` 进行染色标记。

首先在外层循环遍历所有城市的编号，对于每个被遍历的城市，检查该城市是否已被访问。如果已被访问，意味着该城市所属的省份均已被探索，跳过该城市即可；如果未被访问，则意味着我们找到了一座属于新的未探索省份的城市，然后省份计数器加一，再开始尽可能以该城市为起点，遍历整个省份。

遍历省份时，可以考虑 BFS。初始化时让外层遍历中未探索的新城市入队，然后只要队列非空就进行下述循环：

- 一个城市出队；
- 遍历该城市对应的邻接矩阵对应行或列，找出所有<u>与该城市直接相连</u>且<u>尚未访问</u>的城市们，将这些城市们访问状态标记为已访问——因为他们与出队城市均属于同一省份，然后再让这些城市们入队。

这样，当队列最终为空时，我们就找出了最初入队城市所在省份的所有或直接或间接与之相连的全部城市，并将他们标记为已访问。

最后，在外层循环结束时，我们就找出了所有城市的省份聚类。

# 代码

算法的时间复杂度为 $\Theta(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        int count = 0;
        boolean[] visited = new boolean[n];
        Deque<Integer> deque = new ArrayDeque<>();

        for (int city = 0; city < n; city++) {
            if (!visited[city]) {
                visited[city] = true;
                count++;

                deque.offer(city);
                while (!deque.isEmpty()) {
                    int c = deque.poll();
                    for (int i = 0; i < n; i++) {
                        if (isConnected[c][i] == 1 && !visited[i]) {
                            deque.offer(i);
                            visited[i] = true;
                        }
                    }
                }
            }
        }

        return count;
    }
}
```

