题目简述：

> 给定一个整数数组 `nums` 和一个整数 `k` ，返回其中元素之和可被 `k` 整除的非空 **子数组** 的数目。
>
> **子数组** 是数组中 **连续** 的部分。

题目链接：[974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

# 思路

在求解本问题前，我刚刚解决了 [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)。那个问题与本问题非常相似，以下是 [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/) 的思路：

> 问题描述：
>
> > 给你一个整数数组 `nums` 和一个整数 `k` ，如果 `nums` 有一个 **好的子数组** 返回 `true` ，否则返回 `false`：
> >
> > 一个 **好的子数组** 是：
> >
> > - 长度 **至少为 2** ，且
> > - 子数组元素总和为 `k` 的倍数。
>
> 对于这个问题，我首先看了数据范围，发现 $O(n^2)$ 的时间复杂度极大概率会超时，但 $O(n\log n)$ 不会，这让我想到 binary indexed tree。但考虑到力扣的题目一般并不需要——至少并不必要高级数据结构，因为这些问题通常都是开发职位面试时会考察的题目，所以我猜测，或许可以利用别的条件与问题的特性，实现 $O(n)$ 的复杂度。
>
> 我再次查看数据范围，发现元素均非负，但该条件似乎意义不大。随即，我又想到可以把前缀和数组做反向的哈希表映射，让对 $k$ 取模后的前缀和的值作为 key 映射到索引，取索引为 value。而且，对于重复的 key，value 只取首个扫描到的索引。
>
> 然后，问题就变为了类似 “两数之和” 的问题。遍历对 $k$ 取模后的前缀和数组，考虑 `prefix[i]`，找哈希表中是否存在这样一个索引 `j`：`j` 小于等于 `i - 1`，并且使得 `(prefix[i] - prefix[j]) % k == 0`。如果是，那么我们就找到一个 “好的子数组”。
>
> 这样实现的算法时间复杂度就是 $O(n)$ 了，效率很高。 
>
> 总结：（取模后的）前缀和数组 + 哈希表
>
> 题目规定元素均非负，应该是为了避免类 C 语言中 `%` 的行为与数论中的模运算针对负数情况的行为不一致而带来的小麻烦。

可以看到，[523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/) 与本问题几乎是一对孪生兄弟。

类似地，一边扫描，同时做到：

1. 计算前缀和
2. 更新哈希表
3. 寻找是否存在解

不过本问题下哈希表需要记录所有模 `k` 剩余 `?` 的索引，即应考虑 `HashMap<Integer, List<Integer>>` 数据结构，因为这里要求返回的是所有元素和能被 `k` 整除的非空子数组数量，而非询问是否存在至少一个元素和能被 `k` 整除的非空子数组。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

可以将 `HashMap<Integer, List<Integer>>` 等价地替换为 `List<Integer>[]`，这样效率更高，毕竟 `k` 是已知且有限的。

```java
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int n = nums.length;
        Map<Integer, List<Integer>> map = new HashMap<>(k);
        for (int i = 0; i < k; i++) map.put(i, new ArrayList<Integer>());
        long sum = 0;
        int count = 0;

        for (int i = 0; i < n; i++) {
            sum += nums[i];
            sum = mod(sum, k);
            List<Integer> list = map.get((int) sum);
            count += list.size();
            if (sum == 0) count++;
            list.add(i);
        }

        return count;
    }

    private long mod(long number, int k) {
        long res = number % k;
        return res < 0 ? res + k : res;
    }
}
```

