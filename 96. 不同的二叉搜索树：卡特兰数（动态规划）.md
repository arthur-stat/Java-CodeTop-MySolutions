题目简述：

> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

题目链接：[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

# 思路

很显然这是一个动态规划问题，难点在于如何找出状态转移方程。

设状态 $dp[n]$ 为恰由 $n$ 个节点组成且节点值从 $1$ 到 $n$ 互不相同的二叉搜索树数量。接下来需要找出状态转移。

---

破局之处在于：假设一共有 $n$ 个节点，那么根据 BST 的性质，讨论以第 $i$ 个节点为根节点的 BST，

- 值小于第 $i$ 个节点的节点一共有 $i-1$ 个，这些节点均属于第 $i$ 个节点的左子树；
- 值大于第 $i$ 个节点的节点一共有 $n-i$ 个，这些节点均属于第 $i$ 个节点的右子树。

BST 的任何一棵子树一定也是一棵 BST，根据状态 $dp$ 的定义，

- 第 $i$ 个节点的左子树要符合 BST 的结构，则一共有 $dp[i-1]$ 种可能；
- 第 $i$ 个节点的右子树要符合 BST 的结构，则一共有 $dp[n-i]$ 种可能。

此处体现了最优子结构。

因此，以第 $i$ 个节点作为根节点的、一共有 $n$ 个节点的 BST，总计就有 $dp[i-1]\times dp[n-i]$ 种可能。

一棵 BST 如果共有 $n$ 个节点，那么从第 $1$ 个节点至第 $n$ 个节点都可能作为根节点，因此
$$
dp[n]=\sum^n_{k=1}dp[k-1]\times dp[n-k]
$$
这里补充定义 $dp[0]=1$。

---

实际上，$dp[n]$ 就是卡特兰数 $C_n$，下标完全对齐。

# 代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int k = 1; k <= i; k++) {
                dp[i] += dp[k - 1] * dp[i - k];
            }
        }

        return dp[n];
    }
}
```

