题目简述：

> 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。
>
> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。
>
> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

题目链接：[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

# 思路

> 二分查找（Binary Search）是一种经典的分治算法。

一般来说这类涉及数组的算法时间复杂度至少为 $O(N)$，因为我们至少需要完整遍历一次数组才能拿到数组的全部信息，但这个题目要求 $O(\log N)$，这是因为给我们的数组是排序的——只是“旋转”了一下，因此数组本身就蕴含着额外的信息，我们不必完整遍历整个数组。

看到 $O(\log N)$，就应该想到分治算法。实际上，看到数组在旋转前是有序的，应该直接想到二分查找。

考虑到题干明确说了不存在重复的值，因此设反转前的数组为 $\text{arr}$、旋转点的索引为 $k$（$\text{arr}[k]$ 及其右侧的部分反转），则这类旋转数组 $\text{nums}$ 的特点是：

- 从左端点（值为 $\text{arr}[k]$、$\text{nums}[0]$）起值递增，直到全局最大值 $\text{nums}[n-k-1]$，有 $\text{nums}[n-k-1]>\text{nums}[n-k]$，然后自 $\text{nums}[n-k]$ 起继续递增，但 $n-k$ 以后的值始终小于左端点；

- 注意，这里有一个很好的性质：对 $\text{nums}$ 而言，$\text{nums}[n-k-1]$ 是全局最大的，而且其左侧的值一定小于他，其右侧的值也一定小于他，最重要的是其**右侧的值一定小于左侧的值**。对于中间的某个值：

  - 如果其小于 $\text{nums}[0]$：他一定位于 $n-k-1$ 右侧；
  - 如果其大于等于 $\text{nums}[0]$：他一定位于 $n-k-1$ 或者 $n-k-1$ 左侧。

  通过这一性质，我们可以先确定 $\mathrm{target}$ 位于哪一侧，然后寻找最小值下标（两侧的分界点），再在确定单调递增且包含 $\mathrm{target}$ 的那一侧进行二分查找。

---

注：此前在其他题解我给出了 “二分查找黄金模板”（搜索关键字 “黄金模板” 即可找到），该模板用于在升序数组中查找模板元素。

其实只要修改 if-else 的条件就可以直接变成旋转数组寻找最小值的模板：

```java
    if (nums[0] <= nums[nums.length - 1]) {
        min = 0;
    } else {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // mid 位于左半侧
            if (nums[mid] >= nums[0]) {
                left = mid + 1;
            } else {
                // mid 位于右半侧
                right = mid - 1;
            }
        }
        min = left;
    }
```

原因是这里的 `if (nums[mid] >= nums[0])` 条件在 “黄金模板” 中对应 `if nums[mid] < target`。之所以直接改这一处就能直接生效，是因为他们背后的语义都是一样的：判断条件表达了目标元素（`target` 或旋转数组最小值）是否严格在 `mid` 的右侧（相对地，`mid` 严格在目标元素左侧），从而指导区间收缩方向。

# 代码

算法的时间复杂度为 $O(\log n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int search(int[] nums, int target) {
        int left;
        int right;
        int min;  // 最小值对应的索引，即分界点

        if (nums[0] <= nums[nums.length - 1]) {
            min = 0;
            left = 0;
            right = nums.length - 1;
        } else {
            int l = 0;
            int r = nums.length - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                // mid 位于左半侧
                if (nums[mid] >= nums[0]) {
                    l = mid + 1;
                } else {
                    // mid 位于右半侧
                    r = mid - 1;
                }
            }

            min = l;
            if (target >= nums[0]) {
                left = 0;
                right = min - 1;
            } else {
                left = min;
                right = nums.length - 1;
            }
        }

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return (left < nums.length && nums[left] == target) ? left : -1;
    }
}
```

# 如果数组旋转好几次呢？

无论旋转几次，一个旋转数组里最多只有 2 段递增序列，所以代码甚至原封不到就可以适用多次旋转的旋转数组。

从数学上可以证明：旋转数组无论旋转多少次，都与仅旋转一次是同构的。我在 [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) 的题解中给出了证明该结论的论文，而且针对那里数组非严格单调递增的情况结论依然适用，读者感兴趣的话可以去那篇题解看看。
