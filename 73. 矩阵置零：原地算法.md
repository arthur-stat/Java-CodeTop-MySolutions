题目简述：

> 给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **原地** 算法**。**
>
> **进阶：**
>
> - 一个直观的解决方案是使用  `O(mn)` 的额外空间，但这并不是一个好的解决方案。
> - 一个简单的改进方案是使用 `O(m + n)` 的额外空间，但这仍然不是最好的解决方案。
> - 你能想出一个仅使用常量空间的解决方案吗？

题目链接：[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

# 思路

既然只允许使用原地算法，那么就考虑将信息写到原矩阵 $A$ 中。

分别进行两次扫描，第一次扫描时自上而下、从左至右地遍历每一个元素，这样当我们扫描到 $A[i][j]$，就可以保证 $A[0][j]$ 与 $A[i][0]$ 是已被扫描过的。于是，如果 $A[i][j]=0$，则覆写 $A[0][j]=A[i][0]=0$。这样覆写是不会丢失信息的，因为如果 $A[0][j]$ 或 $A[i][0]$ 本就为 $0$，那么写与不写结果相同，而如果 $A[0][j]$ 或 $A[i][0]$ 不为 $0$，那么根据要求，我们在后来迟早也会将这两个元素置为 $0$，所以这样覆写是合理的，不会影响最终结果。

第一次扫描标记出了需要置 $0$ 的行与列，因此第二次扫描时只需要扫描首行与首列。如果首行的第 $j$ 列 $A[0][j]=0$，则置第 $j$ 列全为 $0$；如果首列的第 $i$ 行 $A[i][0]=0$，则置第 $i$ 行全为 $0$。

注意，目前位置算法的逻辑尚不完整。算法所缺失的最关键一环，是我们必须对 $A[0][0]$ 单独处理，即首行与首列是否需要置 $0$ 我们不能通过 $A[0][0]$ 进行判断，因为 $A[0][0]$ 同时对应了首行与首列的置 $0$ 标记，如果 $A[0][0]=0$，则我们无法判断究竟是对首行置 $0$、首列置 $0$ 还是同时对首行与首列置 $0$。要解决这个问题，我们需要单独用两个布尔变量标记是否对首行置 $0$ 与是否对首列置 $0$，然后单独讨论是否对首行与首列置 $0$。

这样，我们就可以在不使用额外空间的前提下，实现 $O(mn)$ 时间复杂度的原地算法。

# 代码

算法的时间复杂度为 $O(mn)$，空间复杂度为 $O(1)$，系原地算法。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        boolean cleanFirstRow = false;
        boolean cleanFirstCol = false;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                    if (i == 0) cleanFirstRow = true;
                    if (j == 0) cleanFirstCol = true;
                }
            }
        }

        for (int i = 1; i < m; i++) {
            if (matrix[i][0] == 0) {
                Arrays.fill(matrix[i], 0);
            }
        }

        for (int j = 1; j < n; j++) {
            if (matrix[0][j] == 0) {
                for (int i = 0; i < m; i++) {
                    matrix[i][j] = 0;
                }
            }
        }

        if (cleanFirstRow) Arrays.fill(matrix[0], 0);
        if (cleanFirstCol) {
            for (int i = 0; i < m; i++) matrix[i][0] = 0;
        }
    }
}
```

