题目简述：

> 给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以 **字符串形式返回小数** 。
>
> 如果小数部分为循环小数，则将循环的部分括在括号内。
>
> 如果存在多个答案，只需返回 **任意一个** 。
>
> 对于所有给定的输入，**保证** 答案字符串的长度小于 `10^4` 。
>
> **示例 1：**
>
> > 输入：numerator = 1, denominator = 2
> > 输出："0.5"
>
> **示例 2：**
>
> > 输入：numerator = 2, denominator = 1
> > 输出："2"
>
> **示例 3：**
>
> > 输入：numerator = 4, denominator = 333
> > 输出："0.(012)"

题目链接：[166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

# 思路

模拟，面向测试用例编程，比较无聊无趣又令人讨厌的模拟。

注意点：

1. 要避免类 C 语言中 `%` 对负数的特殊行为，可以事先记录结果的符号，然后令两数分别为其绝对值；

2. 用 `long` 表示除数与被除数，这样可以安全地在除法时对被除数乘 10 借位；

3. 靠余数能够唯一确认是否进入了循环节，所以应当用哈希记录余数，并且根据第四点的分析，需要记录余数到余数首次出现时商在结果中位置的映射；

4. 出现相同余数则表明我们发现了循环节；

5. 每次借位后，立刻将 `"0"` 写入结果中并结算商与余数，这是长除法的标准算法——也可以说是不区分是否为 0，即使是 0 也一并立刻写入结果。不要累积借位直到商不为 0 再一次性商与余数并将借位后填充了前缀 0 的商写入结果，徒增算法的逻辑复杂度，尽管这样做更符合人类计算竖式除法的实际思维；

6. ***判定是否发现循环节的逻辑一定要放在 `while` 最初被执行的部分对 `nume` 执行，不要放在计算了余数后再针对新余数 `remainder` 执行！***否则算法只能设计得很复杂。

   我为什么知道这一点呢？因为我就在这里踩了这个大坑——虽然前面踩的坑也不少，但不至于如此令人印象深刻。踩坑的代码我放到文章最后的部分了，那份代码是能 AC 的，但得到的循环小数表示不是最简形式，而且逻辑要复杂得多，主要就是因为把判定循环节的代码写在了计算新余数后，这导致必须进行额外的分类讨论才能得到合法的循环节表示，而且循环节的表示不是最简的。那份代码如果希望得到最简形式表示的结果，那逻辑就更加复杂了。

   可以对比一下两份代码的差别。

# 代码

这份代码能够得到循环小数的最简形式表示。

```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        long nume = Math.abs((long) numerator);
        long deno = Math.abs((long) denominator);
        String sign;
        if ((numerator > 0 && denominator > 0) || (numerator < 0 && denominator < 0)) {
            sign = "";
        } else if (numerator != 0 && denominator != 0) {
            sign = "-";
        } else if (numerator == 0) {
            return "0";
        } else {
            throw new ArithmeticException("/ by zero");
        }
        String integerPart = "" + (nume / deno);
        StringBuilder fractionalPart = new StringBuilder();
        nume %= deno;
        if (nume == 0) return sign + integerPart;

        // 余数至商在结果中起始索引的映射
        Map<Long, Integer> remainderToIndex = new HashMap<>();
        int start = 0;  // 商在结果中的起始位置

        while (nume != 0) {
            // 发现循环节
            if (remainderToIndex.putIfAbsent(nume, start) != null) {
                int circleStart = remainderToIndex.get(nume);
                fractionalPart.insert(circleStart, '(');
                fractionalPart.append(')');
                return sign + integerPart + "." + fractionalPart.toString();
            }

            nume *= 10;
            long quotient = nume / deno;
            long remainder = nume % deno;  // 仅靠余数便能唯一确认是否进入循环节
            fractionalPart.append(quotient);
            start = fractionalPart.length();
            nume = remainder;
        }

        return sign + integerPart + "." + fractionalPart.toString();
    }
}
```

# 处处踩雷点的代码

能 AC，但也只是能 AC。

此外，也无法得到循环小数的最简表示。

```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        long nume = Math.abs((long) numerator);
        long deno = Math.abs((long) denominator);
        String sign;
        if ((numerator > 0 && denominator > 0) || (numerator < 0 && denominator < 0)) {
            sign = "";
        } else if (numerator != 0 && denominator != 0) {
            sign = "-";
        } else if (numerator == 0) {
            return "0";
        } else {
            throw new ArithmeticException("/ by zero");
        }
        String integerPart = "" + (nume / deno);
        StringBuilder fractionalPart = new StringBuilder();
        nume %= deno;
        if (nume == 0) return sign + integerPart;

        // 将余数映射到整数商的起始索引
        Map<Long, Integer> quotientIndex = new HashMap<>();
        // 将余数映射到整数商的长度
        Map<Long, Integer> quotientLen = new HashMap<>();
        int start = 0;  // 一段整数商在结果中的起始位置

        while (nume != 0) {
            int borrow = 0;  // 借位
            while (nume < deno) {
                nume *= 10;
                borrow++;
            }
            long quotient = nume / deno;
            long remainder = nume % deno;  // 仅靠余数便能唯一确认是否进入循环节
            String quotientStr = String.format("%0" + borrow + "d", quotient);

            if (quotientIndex.putIfAbsent(remainder, start) != null) {
                // 余数首次出现时整数商的起始位置
                int firstIndex = quotientIndex.get(remainder);
                // 余数首次出现时的整数商
                String firstQuotient = fractionalPart.toString().substring(firstIndex, firstIndex + quotientLen.get(remainder));

                // 如果两余数对应的整数商相同
                if (firstQuotient.equals(quotientStr)) {
                    int circleStart = firstIndex;
                    fractionalPart.insert(circleStart, '(');
                    fractionalPart.append(')');
                    return sign + integerPart + "." + fractionalPart.toString();
                } else {
                    // 如果两余数对应的整数商不同
                    int circleStart = firstIndex + firstQuotient.length();
                    fractionalPart.insert(circleStart, '(');
                    fractionalPart.append(quotientStr);
                    fractionalPart.append(')');
                    return sign + integerPart + "." + fractionalPart.toString();
                }
            }

            quotientLen.put(remainder, quotientStr.length());
            fractionalPart.append(quotientStr);
            start = fractionalPart.length();
            nume = remainder;
        }

        return sign + integerPart + "." + fractionalPart.toString();
    }
}
```
