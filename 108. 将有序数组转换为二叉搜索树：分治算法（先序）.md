题目简述：

> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵平衡二叉搜索树。

题目链接：[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

# 思路

> 定义一个节点的平衡因子（Balance Factor）为该节点的左子树高度减去右子树高度的差，则一棵二叉树为平衡二叉树当且仅当该树中任何一点的平衡因子只可能为 -1、0 或 1。
>
> 平衡二叉树的任何子树均为平衡二叉树。

> 删除或插入节点后可能会破坏平衡二叉树的结构，此时可以分为四种情况，对应四种不同的 “旋转” 操作以维护二叉树的平衡性。
>
> 但对于本问题不必如此繁琐。

> 二叉搜索树（BST）的定义是对于每个节点，只要子节点存在，那么就必须满足左子节小于当前节点，右子节点大于当前节点。即，左子树内的任何节点均小于当前节点，右子树内的任何节点均大于当前节点。

从上文的定义回顾来看，本问题是一个典型的分治算法问题。

对于一个升序排列的整数数组，我们暂不能直接确定其他节点应该被安排在平衡二叉搜索树的何处，但我们可以肯定该整数数组的中间元素一定是平衡二叉搜索树的根节点，因为作为一棵 BST，必须保证其根节点大于左子树内的任何节点、小于右子树内的任何节点。然后，再递归地分治处理左右子树即可，这样就可以保证结果是一棵平衡的二叉搜索树：

- BST 的性质由我们选取作为子树根的元素大于其左子树内的任何节点且小于其右子树内的任何节点所保证；
- 平衡树的性质由我们对一棵子树选择子数组的中间元素所保证，作为中间元素，能够确保左子树与右子树所包含的节点数量差额不超过 1，自然能够保证左子树与右子树的高度差绝对值小于 1。

这样，对于任何一个节点，当视其为某个子树的根节点时，他的左子树内元素均小于该节点、右子树内元素均大于该节点，且左子树与右子树的深度差绝对值不超过 1。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(\log n)$，其中空间复杂度主要来自于递归栈的开销。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    private int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return build(0, nums.length - 1);
    }

    private TreeNode build(int start, int end) {
        if (start > end) return null;
        int mid = start + (end - start) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        TreeNode left = build(start, mid - 1);
        TreeNode right = build(mid + 1, end);

        root.left = left;
        root.right = right;
        
        return root;
    }
}
```

