题目简述：

> 给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。
>
> 你应该使用 “**贪心算法**” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 `' '` 填充，使得每行恰好有 *maxWidth* 个字符。
>
> 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
>
> 文本的最后一行应为左对齐，且单词之间不插入**额外的**空格。
>
> **注意:**
>
> - 单词是指由非空格字符组成的字符序列。
> - 每个单词的长度大于 0，小于等于 *maxWidth*。
> - 输入单词数组 `words` 至少包含一个单词。

题目链接：[68. 文本左右对齐](https://leetcode.cn/problems/text-justification/)

# 思路

就是模拟啦~

请直接阅读代码。

这个问题居然是 hard 难度，其实直接按描述进行模拟就好了。

# 代码

```java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<List<String>> rows = new ArrayList<>();
        List<String> row = new ArrayList<>();
        int count = 0;

        // 首先分出单词行的层次（贪心策略）
        for (String word : words) {
            int evalCount = count;
            if (!row.isEmpty()) evalCount += 1;
            evalCount += word.length();

            if (evalCount <= maxWidth) {
                row.add(word);
                count = evalCount;
            } else {
                rows.add(row);
                row = new ArrayList<>();
                row.add(word);
                count = word.length();
            }
        }
        rows.add(row);

        // 再对除最后一行外的每一层构造具体的填充空格后的字符串
        List<String> res = new ArrayList<>();
        for (int i = 0; i < rows.size() - 1; i++) {
            List<String> builtRow = rows.get(i);
            int wordsLen = 0;
            for (String word : builtRow) {
                wordsLen += word.length();
            }
            int gapNumber = builtRow.size() - 1;
            if (gapNumber == 0) {
                String s = builtRow.get(0) + " ".repeat(maxWidth - builtRow.get(0).length());
                res.add(s);
                continue;
            }
            int gapLen = (maxWidth - wordsLen) / gapNumber;
            int leftGapCount = maxWidth - wordsLen - gapLen * gapNumber;

            StringBuilder sb = new StringBuilder();
            sb.append(builtRow.get(0));
            for (int j = 1; j < builtRow.size(); j++) {
                String gap;
                if (leftGapCount > 0) {
                    gap = " ".repeat(gapLen + 1);
                    leftGapCount--;
                } else {
                    gap = " ".repeat(gapLen);
                }

                sb.append(gap);
                sb.append(builtRow.get(j));
            }

            res.add(sb.toString());
        }

        // 单独构造左对齐的最后一行
        List<String> lastBuiltRow = rows.get(rows.size() - 1);
        StringBuilder sb = new StringBuilder();
        sb.append(lastBuiltRow.get(0));
        int lenCount = lastBuiltRow.get(0).length();
        for (int i = 1; i < lastBuiltRow.size(); i++) {
            sb.append(' ');
            sb.append(lastBuiltRow.get(i));
            lenCount += lastBuiltRow.get(i).length() + 1;
        }
        sb.append(" ".repeat(maxWidth - lenCount));
        res.add(sb.toString());

        return res;
    }
}
```

