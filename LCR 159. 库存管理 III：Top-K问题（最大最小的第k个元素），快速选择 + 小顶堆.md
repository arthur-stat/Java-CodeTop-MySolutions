题目简述：

> 仓库管理员以数组 `stock` 形式记录商品库存表，其中 `stock[i]` 表示对应商品库存余量。请返回库存余量最少的 `cnt` 个商品余量，返回 **顺序不限**。

题目链接：[LCR 159. 库存管理 III](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

# 分析

这显然是一个 Top-K 问题——或者说 Bottom-K？

可以用与快速排序思想一致的快速选择算法解决，也可以考虑小顶堆，即优先队列。

两种算法的平均时间复杂度都是 $O(k\log n)$ 的。

# 快速选择算法

```java
class Solution {

    Random rand = new Random(0);
    int found;

    public int[] inventoryManagement(int[] stock, int cnt) {
        int[] res = new int[cnt];
        found = 0;
        quickselect(stock, 0, stock.length - 1, res, cnt);
        return res;
    }

    private boolean quickselect(int[] stock, int low, int high, int[] res, int cnt) {
        if (low > high) return false;

        int left = low;
        int right = high;
        int i = low;

        int pivotIndex = low + rand.nextInt(high - low + 1);
        int pivot = stock[pivotIndex];
        while (i <= right) {
            if (stock[i] < pivot) {
                swap(stock, left, i);
                left++;
                i++;
            } else if (stock[i] == pivot) {
                i++;
            } else {
                swap(stock, right, i);
                right--;
            }
        }

        if (left <= cnt - 1) {
            int limitedRight = Math.min(right, cnt - 1);
            System.arraycopy(stock, left, res, left, limitedRight - left + 1);
            found += limitedRight - left + 1;
            if (found == cnt) return true;
        }

        if (quickselect(stock, low, left - 1, res, cnt)) return true;
        if (quickselect(stock, right + 1, high, res, cnt)) return true;
        return false;
    }

    private void swap(int[] stock, int i, int j) {
        int tmp = stock[i];
        stock[i] = stock[j];
        stock[j] = tmp;
    }
} 
```

# 小顶堆（利用数组实现）

需要单独说明的是，<u>小顶堆的初始化与删除堆顶元素的最优实现均为下沉</u>。初始化时，对非叶子节点——即前 `n / 2` 个元素逐个下沉即可，而且应当从 `arr[n / 2 - 1]` 开始下沉。

<u>仅在队尾插入新元素或删除非堆顶元素时需要上浮</u>。

将其中不等号反向即可得到大顶堆。

```java
class Solution {

    public int[] inventoryManagement(int[] stock, int cnt) {
        MyPq pq = new MyPq(stock);;
        int[] res = new int[cnt];
        for (int i = 0; i < cnt; i++) {
            res[i] = pq.poll();
        }
        return res;
    }

    private class MyPq {

        int[] arr;
        int size;

        public MyPq(int[] arr) {
            this.arr = arr;
            this.size = arr.length;
            for (int i = arr.length / 2 - 1; i >= 0; i--) {
                shiftDown(i);
            }
        }

        private void shiftDown(int i) {
            int left = left(i);
            int right = right(i);

            while ((check(left) && arr[i] > arr[left]) || (check(right) && arr[i] > arr[right])) {
                int less;
                if (check(left) && check(right)) {
                    less = arr[left] < arr[right] ? left : right;
                } else {
                    less = check(left) ? left : right;
                }
                swap(i, less);
                i = less;
                left = left(i);
                right = right(i);
            }
        }

        private int poll() {
            int res = arr[0];
            swap(0, size - 1);
            size--;
            shiftDown(0);
            return res;
        }

        private void swap(int i, int j) {
            int tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }

        private int left(int i) {
            return 2 * i + 1;
        }

        private int right(int i) {
            return 2 * i + 2;
        }

        private int parent(int i) {
            return (i - 1) / 2;
        }

        private boolean check(int i) {
            return i >= 0 && i < size;
        }
    }
}
```

# 小顶堆（借助内置数据结构）

Java 中的优先队列其实就是小顶堆。

```java
class Solution {
    public int[] inventoryManagement(int[] stock, int cnt) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Arrays.stream(stock).boxed().collect(Collectors.toList()));
        int[] res = new int[cnt];
        for (int i = 0; i < cnt; i++) {
            res[i] = pq.poll();
        }
        return res;
    }
}
```

