题目简述：

> 不使用任何库函数，设计一个 **跳表** 。
>
> **跳表** 是在 `O(log(n))` 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。
>
> 例如，一个跳表包含 `[30, 40, 50, 60, 70, 90]` ，然后增加 `80`、`45` 到跳表中，以下图的方式操作：
>
> ![跳表](images/1206.gif)
>
> 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 `O(n)`。跳表的每一个操作的平均时间复杂度是 `O(log(n))`，空间复杂度是 `O(n)`。
>
> 了解更多 : https://oi-wiki.org/ds/skiplist/
>
> 在本题中，你的设计应该要包含这些函数：
>
> - `bool search(int target)` : 返回target是否存在于跳表中。
> - `void add(int num)`: 插入一个元素到跳表。
> - `bool erase(int num)`: 在跳表中删除一个值，如果 `num` 不存在，直接返回false. 如果存在多个 `num` ，删除其中任意一个即可。
>
> 注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。

题目链接：[1206. 设计跳表](https://leetcode.cn/problems/design-skiplist/)

# 跳表

逻辑上，跳表具有多层链表，能够实现平均 $O(\log n)$ 时间复杂度的增加、删除与搜索。其中，最底层的链表包含了所有内容，上层的链表中每个元素均按累积概率随机地分布在某层与该层之下的所有层链表中，用于加速链表的查询。也就是说，一旦一个节点值出现在了某一层，那么在垂直位置上，该节点也应该出现在任何低于该层高度的层中，这是跳表能够加速查询的关键——如果在当前层没有找到目标值 `target` 的节点，那么就在最后一个值小于 `target` 的节点垂直向下一层继续尝试搜索。

本质上，跳表也是一种概率化数据结构，因为在插入新节点时，新节点应在逻辑上插入哪些层的链表，是由概率分布所决定的。不过与布隆过滤器等概率化数据结构不同的是，跳表查询的结果是完全准确的，因为逻辑上最底层的链表仍保留了全部信息。

实际实现时，不要真的维护多层双向链表，这不仅拉低性能，还增加了大量的空间开销。正确的做法是定义节点类 `Node`，一个节点只保存一份值，节点内维护各层内的下一个节点数组 `forward`。然后按跳表定义实现增加、删除与搜索即可。也就是说，我们实际上只有一份所有值对应的节点，我们是通过事实上维护每个节点在各层内的下一跳做到逻辑上维护各层（那本不实际存在的）链表的。

即，我们在搜索位置时，在逻辑上从当前有效的最高层的首个节点开始，每次要么向右走 “快速通道”，要么在 “快速通道” 如何提供准确信息——即仅凭当前层无法确定结果时，就向下走以获得相对更完整的链表。要么向右，要么向下，直到找到目标或是宣告未能找到目标。加速查询的最主要办法就是利用上层信息提供的 “快速通道”，让我们可以不必从最底层也最完整的链表首节点开始查询。

这里也可以看出，跳表等价于平衡树，都是通过减治算法的思想加速查询。

为方便处理边界情况，可以设计虚拟头节点 `dummy`。

更多编程细节请直接查看代码获知。

# 代码

每种操作的时间复杂度期望均为 $O(\log n)$。

```java
class Skiplist {

    public final double p;
    public final int MAX_DEPTH;  // 1-based
    private int currentDepth;    // 0-based
    private Random rand;
    private Node dummy;
    
    public Skiplist() {
        MAX_DEPTH = 32;
        currentDepth = 0;
        p = 0.5;
        rand = new Random("saki".hashCode());
        dummy = new Node(0);
        dummy.forward = new Node[MAX_DEPTH];
    }
    
    public boolean search(int target) {
        Node prev = dummy;
        int depth = currentDepth;

        while (depth >= 0) {
            while (prev.forward[depth] != null && prev.forward[depth].val < target) {
                prev = prev.forward[depth];
            }

            if (prev.forward[depth] != null && prev.forward[depth].val == target) return true;
            depth--;
        }

        return false;
    }
    
    public void add(int num) {
        int height = 0;
        while (height < MAX_DEPTH && rand.nextDouble() < p) height++;
        currentDepth = Math.max(currentDepth, height);

        Node node = new Node(num);
        node.forward = new Node[height + 1];
        Node prev = dummy;
        int depth = currentDepth;

        while (depth >= 0) {
            while (prev.forward[depth] != null && prev.forward[depth].val < num) {
                prev = prev.forward[depth];
            }
            if (depth <= height) {
                Node next = prev.forward[depth];
                prev.forward[depth] = node;
                node.forward[depth] = next;
            }
            depth--;
        }
    }
    
    public boolean erase(int num) {
        Node prev = dummy;
        int depth = currentDepth;
        boolean res = false;

        while (depth >= 0) {
            while (prev.forward[depth] != null && prev.forward[depth].val < num) {
                prev = prev.forward[depth];
            }

            if (prev.forward[depth] != null && prev.forward[depth].val == num) {
                prev.forward[depth] = prev.forward[depth].forward[depth];
                res = true;
            }
            depth--;
        }

        for (depth = currentDepth; depth >= 0; depth--) {
            if (dummy.forward[depth] == null) {
                currentDepth--;
            } else {
                break;
            }
        }

        return res;
    }

    public void printList() {
        Node node = dummy.forward[0];
        System.out.print("[");
        while (node != null) {
            System.out.print(node.val);
            if (node.forward[0] == null) break;
            System.out.print(", ");
            node = node.forward[0];
        }
        System.out.println("]");
    }

    private static class Node {

        int val;
        Node[] forward;

        Node(int val) {
            this.val = val;
        }
    }
}

/**
 * Your Skiplist object will be instantiated and called as such:
 * Skiplist obj = new Skiplist();
 * boolean param_1 = obj.search(target);
 * obj.add(num);
 * boolean param_3 = obj.erase(num);
 */
```

