题目简述：

> 给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。
>
> 数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

题目链接：[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

# 思路

优先队列（大/小顶堆）适合解决 Top-K 问题，单调队列适合解决动态维护窗口最值问题，而单调栈正是最适合解决下一个更大/更小元素（以及他们的距离）问题的数据结构。

因此显然本问题需要考虑单调栈这一数据结构，只不过应针对循环数组的场景做额外的逻辑处理。

# 代码

算法的摊还时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

`visited` 数组是为了放置重复写回，实际上可以省去 `visited` 数组，只需要在第一轮遍历时让元素只入栈但不写入 `res`、第二轮遍历时再边入栈边更新 `res` 即可。但作为我最初的独立思考想法，代码中保留了这一设计。

```java
class Solution {

    private class CircularMonoStack {

        // 对于本问题，应维护栈内元素单调递减（自栈底至栈顶），并且存储索引
        private Deque<Integer> stack;

        public CircularMonoStack() {
            stack = new ArrayDeque<>();
        }

        public void push(int[] nums, int i, int[] res, boolean[] visited) {
            int validIndex = i % nums.length;
            int val = nums[validIndex];

            while (!stack.isEmpty() && nums[stack.peek()] < val) {
                int j = stack.pop();
                if (!visited[j]) {
                    res[j] = val;
                    visited[j] = true;
                }
            }
            stack.push(validIndex);
        }
    }

    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(res, -1);
        CircularMonoStack s = new CircularMonoStack();

        for (int i = 0; i < 2 * n; i++) {
            s.push(nums, i, res, visited);
        }

        return res;
    }

    // 非负模运算方法（类 C 语言的模定义全都和标准数论的取模行为不一致）
    private int mod(int a, int b) {
        return (a % b + b) % b;  // a % b
    }
}
```

