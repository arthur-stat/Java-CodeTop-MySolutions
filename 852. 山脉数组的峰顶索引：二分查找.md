题目简述：

> 给定一个长度为 `n` 的整数 **山脉** 数组 `arr` ，其中的值递增到一个 **峰值元素** 然后递减。
>
> 返回峰值元素的下标。
>
> 你必须设计并实现时间复杂度为 `O(log(n))` 的解决方案。

题目链接：[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

# 思路

本问题只是 [1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/) 的一个子问题，即找到山脉数组的山峰。

二分查找即可，这里引用我在 [1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/) 的题解中的描述：

> 对于寻找山峰的二分查找，初始化 `left = 0`、`right = MountainArray.length() - 1`，
>
> 1. 取 `mid = left + (right - left) / 2`
> 2. 借助 `mid + 1`（或 `mid - 1` 也可以）判断 `mid` 处于上山还是下山，
>    - 若 `MountainArray.get(mid) < MountainArray.get(mid + 1)`，则 `mid` 处于上山段，收缩边界，令 `left = mid + 1`
>    - 若 `MountainArray.get(mid) > MountainArray.get(mid + 1)`，则 `mid` 处于下山段，收缩边界，令 `right = mid`
> 3. 回到第一步，直到 `MountainArray.get(mid) > MountainArray.get(mid + 1)` 且 `MountainArray.get(mid) > MountainArray.get(mid - 1)`，此时 `mid` 即为山峰
>
> 对于第三步的条件，可以优化为 `while (left < right)`，此时 `left == right` 之处即为山峰。

# 代码

算法的时间复杂度为 $O(\log n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int n = arr.length;
        if (n <= 1) return 0;

        int l = 0;
        int r = n - 1;

        while (l <= r) {
            int mid = l + ((r - l) >>> 1);

            if (mid < n - 1 && arr[mid] < arr[mid + 1]) {
                l = mid + 1;
            } else if (mid > 0 && arr[mid] < arr[mid - 1]) {
                r = mid - 1;
            } else {
                return mid;
            }
        }

        return l;
    }
}
```