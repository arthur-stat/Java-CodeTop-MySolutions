题目简述：

> 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
> (1) 每次只能移动一个盘子;
> (2) 盘子只能从柱子顶端滑出移到下一根柱子;
> (3) 盘子只能叠在比它大的盘子上。
>
> 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
>
> 你需要原地修改栈。

题目链接：[面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)

# 思路

求解汉诺塔问题的递归思路是：要移动 `n` 个盘子，则

1. 先借助 C，将 A 的前 `n-1` 个盘子从 A 移至 B；
2. 将 A 的第 `n` 个盘子移至 C；
3. 再借助已经没有盘子的 A，将 B 上的 `n-1` 个盘子从 B 移至 C。

其中，第一步与第三步就是需要递归进行的过程，直到 `n-1` 足够小，例如 `n-1` 为 1 时，可以直接解出最小子问题，不需要再递归。

要注意的是，在设计递归算法时不能让形参对应实际的柱子。这是因为，我们可以看到，第一步与第三步都需要进行递归，但是每根柱子在第一步与第三步中扮演的角色是不同的。具体来说，在第一步的递归中，A 为非空柱子、C 为辅助柱子而 B 为目标柱子；在第三步的递归中，B 为非空柱子、A 为辅助柱子而 C为目标柱子。因此，递归算法的参数应该按柱子逻辑上角色的不同，设计为非空柱子、辅助柱子与目标柱子，而不是具体的三根柱子 A、B、C。

# 代码

汉诺塔问题还有个有趣的规律：当圆盘一共有 $N$ 个时，至少需要移动 $2^N-1$ 次圆盘。

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        recursion(A.size(), A, B, C);
    }

    // 将 from 的前 n 个盘子移动至 to，借助 sup
    private void recursion(int n, List<Integer> from, List<Integer> sup, List<Integer> to) {
        if (n == 1) {
            to.add(from.removeLast());
            return;
        }

        recursion(n - 1, from, to, sup);
        to.add(from.removeLast());
        recursion(n - 1, sup, from, to);
    }
}
```

