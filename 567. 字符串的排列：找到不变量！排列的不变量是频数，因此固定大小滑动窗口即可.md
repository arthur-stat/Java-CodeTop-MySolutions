题目简述：

> 给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。
>
> 换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

题目链接：[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

# 思路

这个问题的重点是：找到排列的不变量！

排列的不变量是什么呢？是固定长度区间内的字符频数！无论每个字符究竟是如何排列的，不同字符的频数都是恒定不变的。更进一步地，每个字符的频率与 `s1 `的所有合法排列集合构成一一映射。

因此，对于本问题应当使用一个固定大小的窗口，通过统计窗口内字符的频数判断窗口内的子串是否是我们所期待的结果。这可以被视为滑动窗口的一个特例，也可以被视为一种特殊的遍历。

---

对于 Java 而言，这里还有一个重要特性：`Map.equals` 实现了按引用对象 `equals` 进行键值映射字面量相等的判断。因此我们不必自行重写 HashMap 的 `equals` 方法，直接使用即可。

# 代码

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Character, Integer> s1Count = new HashMap<>();
        Map<Character, Integer> s2Count = new HashMap<>();
        int width = s1.length();
        int n = s2.length();
        if (n < width) return false;

        for (char c1 : s1.toCharArray()) {
            s1Count.put(c1, s1Count.getOrDefault(c1, 0) + 1);
        }

        for (int i = 0; i < width; i++) {
            char c2 = s2.charAt(i);
            s2Count.put(c2, s2Count.getOrDefault(c2, 0) + 1);
        }

        if (s1Count.equals(s2Count)) return true;

        for (int i = width; i < n; i++) {
            char c = s2.charAt(i - width);
            char cc = s2.charAt(i);
            s2Count.put(c, s2Count.get(c) - 1);
            if (s2Count.get(c) == 0) s2Count.remove(c);
            s2Count.put(cc, s2Count.getOrDefault(cc, 0) + 1);
            if (s1Count.equals(s2Count)) return true;
        }

        return false;
    }
}
```

由于题目明确了数据范围：字符只包含小写拉丁字母，因此可以直接将定长当作哈希表使用。这样效率会显著提高。