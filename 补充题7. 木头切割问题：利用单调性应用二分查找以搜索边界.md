题目简述：

> 给定一个长度为 n 的数组，数组中的元素表示每个木头的长度，木头可以在任意位置截断。从这些木头中取出至少 k 个长度都为 m 的木头。请问 m 最大是多少。
>
> 数据范围：数组长度满足 $1\leqslant n\leqslant10^4$，木头长度满足 $1\leqslant val\leqslant10^9,\ 1\leqslant k\leqslant2\times10^4$

题目链接：[[编程题]切割木头](https://api-cdn.nowcoder.com/questionTerminal/707d98cee255448c838c76918a702be0)

# 思路

本问题与 [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 是没有任何本质区别的，这里直接引用我解决 [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 时的思路：

> 珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。
>
> 珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 
>
> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
>
> 返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。
>
> ---
>
> 就是说，`h` 固定时，让 `k` 尽可能小，要让以 `k - 1` 的吃香蕉速度珂珂都不能吃完所有的香蕉。
>
> 看，这不就是存在一个分割点让我们可以考虑二分查找吗？因为如果问题的解为 `k`，则以更快的速度 `k' > k` 吃香蕉珂珂是一定能吃完的，但她喜欢慢慢吃；而以更慢的速度 `k' < k` 吃香蕉珂珂就不能吃完所有的香蕉了，否则问题的解就不会是 `k`，而是比 `k` 更小的数。这里体现了单调性，因此可以应用二分查找算法。
>
> 我们可以设计一个函数 `boolean canEat(int k)` 表示以速度 `k` 吃香蕉时珂珂能不能在警卫回来前吃完所有香蕉，然后二分查找找到最小的使 `canEat` 返回 `true` 的 `k` 即可。

# 代码

算法的时间复杂度为 $O(n\log L)$，空间复杂度为 $O(1)$。其中 $L$ 是最长的木条的长度。

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param a int整型一维数组 
     * @param k int整型 
     * @return int整型
     */
    public int cutWood(ArrayList<Integer> a, int k) {
        int l = 1;
        int r = 1;
        for (int aa : a) r = Math.max(r, aa);

        while (l <= r) {
            int mid = l + (r - l) / 2;

            if (canCut(a, k, mid)) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        return r;
    }

    private boolean canCut(ArrayList<Integer> a, int k, int m) {
        int count = 0;
        for (int aa : a) count += aa / m;
        return count >= k;
    }
}
```

