题目简述：

> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

题目链接：[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

# 暴力 DFS

## 思路

考虑 DFS 先序遍历，使用哈希表，对 DFS 过程中路径上的每个节点都动态维护一个以该节点为起点的路径和，只要路径和为 `targetSum` 计数器就记录一个路径。这样，当我们最终遍历完了所有节点，事实上也遍历完了所有可能的路径和。实现时记得别忘了 DFS 回溯时撤销路径和的累加哦~

这个算法简单、暴力、直接，只是性能相对差一点，但 AC 是完全没有问题的。

## 代码

算法的最坏时间复杂度为 $O(n^2)$，对于平衡二叉树时间复杂度则为 $O(n\log n)$，空间复杂度为 $O(h)$。

你就说面对最多 $10^3$ 个节点的数据范围他能不能 AC 吧！算法 AC 时耗时 180ms，经测试将较重的 `HashMap<TreeNode, Long>` 替换为 `long[]` 数组后算法 AC 时能够做到仅耗时 7ms，与最优方案前缀和结合频次哈希表的大部分代码实现耗时 3ms 相比完全是可接受的。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    private Map<TreeNode, Long> map;
    private int targetSum;
    private int count;

    public int pathSum(TreeNode root, int targetSum) {
        map = new HashMap<>();
        this.targetSum = targetSum;
        count = 0;
        dfs(root);
        return count;
    }

    private void dfs(TreeNode node) {
        if (node == null) return;

        map.put(node, 0L);

        for (var entry : map.entrySet()) {
            TreeNode key = entry.getKey();
            long newValue = entry.getValue() + node.val;
            map.put(key, newValue);
            if (newValue == targetSum) count++;
        }

        dfs(node.left);
        dfs(node.right);

        map.remove(node);

        for (var entry : map.entrySet()) {
            TreeNode key = entry.getKey();
            long value = entry.getValue();
            map.put(key, value - node.val);
        }
    }
}
```

# 前缀和 + 频次哈希表

## 思路

这是本问题的最优解决方案，能够实现严格的 $O(n)$ 时间复杂度。

这个思路在 DFS 的路径的前缀和基础上也有点借鉴 “两数之和” 中利用哈希表快速寻找是否有符合条件的解的意思，具体做法是：

- 依然用一个哈希表记录路径和，但这次不是记录每个节点为起点的路径和（即节点到部分路径和的映射），而是记录路径上节点值的各前缀和数值到频次的映射，同时 DFS 方法的参数不仅需要输入节点，也需要到达该节点前 DFS 的当前路径和（即该节点的父节点所对应的路径前缀和）；
- 当 DFS 探索到一个新的节点，首先更新路径前缀和频次哈希表，然后：
  - 如果现存在一条以当前节点为终点的路径使得该路径上的和等于 `targetSum`，那么记当前节点对应的路径前缀和为 `prefixSum`，则 `prefixSum - targetSum` 一定在路径前缀和频次哈希表中——这是前缀和的一种定义；
  - 所以，直接判断哈希表中是否存在 key 为 `prefixSum - targetSum` 的元素即可——如果存在，那么 `prefixSum - targetSum` 为 key 对应的 value 就是我们发现的以当前节点为路径终点的路径和为 `targetSum` 的路径个数！

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(h)$。

```java
class Solution {

    private Map<Long, Integer> map;
    private int targetSum;
    private int count;

    public int pathSum(TreeNode root, int targetSum) {
        this.targetSum = targetSum;
        count = 0;
        map = new HashMap<>();
        map.put(0L, 1);
        dfs(root, 0);
        return count;
    }

    private void dfs(TreeNode node, long prefixSum) {
        if (node == null) return;

        long newPrefixSum = prefixSum + node.val;
        count += map.getOrDefault(newPrefixSum - targetSum, 0);
        map.merge(newPrefixSum, 1, Integer::sum);
        
        dfs(node.left, newPrefixSum);
        dfs(node.right, newPrefixSum);

        map.merge(newPrefixSum, -1, Integer::sum);
        // if (map.get(newPrefixSum) == 0) map.remove(newPrefixSum);
    }
}
```

