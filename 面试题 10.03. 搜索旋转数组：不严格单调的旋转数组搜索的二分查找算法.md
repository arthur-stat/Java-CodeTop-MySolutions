题目简述：

> 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

题目链接：[面试题 10.03. 搜索旋转数组](https://leetcode.cn/problems/search-rotate-array-lcci/)

# 思路

如果只是讲严格单调的数组被旋转多次，根据我在 [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) 的题解中给出的论文的结论，旋转任意有限次的数组都与旋转一次同构，那么本问题就与 [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 是完全相同的。

这里有个不一样的点是数组是非严格单调的，尽管我们的思路实际上是一样的，都可以先二分查找找出分界点，再在（严格或非严格）单调的数组上再次二分查找。

只不过不严格单调会给我们带来一些麻烦，需要额外的处理。

# 代码

```java
class Solution {
    public int search(int[] arr, int target) {
        int n = arr.length;
        int left = 0;
        int right = n - 1;
        int start = 0;
        // 确保 arr[start] 与 arr[n-1] 不一样，便于判断二分搜索区间收缩方向
        if (arr[0] == target) return 0;
        if (arr[0] == arr[n - 1]) {
            do {
                left++;
            } while (arr[left] == arr[0]);
            start = left;
        }

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] >= arr[start]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        int min = left;
        if (target >= arr[start]) {
            left = start;
            right = min - 1;
        } else {
            left = min;
            right = n - 1;
        }

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return (left < n && arr[left] == target) ? left : -1;
    }
}
```

