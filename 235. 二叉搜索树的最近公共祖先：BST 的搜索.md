题目简述：

> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
> **说明:**
>
> - 所有节点的值都是唯一的。
> - p、q 为不同节点且均存在于给定的二叉搜索树中。

题目链接：[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

# 思路

对于一棵普通的二叉树，要寻找两个目标节点的最近公共祖先，一个比较合适的方案是考虑后序遍历：

- 若当前节点的左子树包含一个目标节点而右子树不包含，或者右子树包含目标节点而左子树不包含，则当前节点即为最近公共祖先；

- 当前节点自身恰为一个目标节点时，该节点可能是最近公共祖先，此时需要结合左右子树已搜索的具体情况的情况进行判断。

这样实现的算法时间复杂度为 $O(n)$。

对于 BST，我们则可以利用 BST 的性质，设置一种优于后序遍历的、时间复杂度为 $O(h)$ 的算法，这里 $h$ 为树的深度。

假设我们现在有一个节点，对于 BST，我们知道：

1. 若一个目标节点的值小于当前节点，则目标节点必然位于该节点某个祖先的左子树；
2. 若一个目标节点的值大于当前节点，则目标节点必然位于该节点某个祖先的右子树。

对于 BST 而言，反过来讲也是成立的，

1. 如果目标节点位于该节点某个祖先的左子树，则目标节点的值必然小于该节点；
2. 如果目标节点位于该节点某个祖先的右子树，则目标节点的值必然大于该节点。

因此：我们从根节点开始探索，

- 若一个目标节点的值小于当前节点、另一个目标节点的值大于当前节点，则该节点即为两目标节点的最近公共祖先；
- 若两个目标节点的值均小于当前节点，则两个节点均位于当前节点的左子树，因此应向当前节点的左子节点探索，深度加一；
- 若两个目标节点的值均大于当前节点，则两个节点均位于当前节点的右子树，因此应向当前节点的右子节点探索，深度加一。

这样，设树的深度为 $h$，则我们最多进行 $h$ 次探索。

# 代码

算法的时间复杂度为 $O(h)$，空间复杂度为 $O(1)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        int a = Math.min(p.val, q.val);
        int b = Math.max(p.val, q.val);

        while (true) {
            if (root.val >= a && root.val <= b) {
                return root;
            } else if (root.val < a) {
                root = root.right;
            } else {
                root = root.left;
            }
        }
    }
}
```

