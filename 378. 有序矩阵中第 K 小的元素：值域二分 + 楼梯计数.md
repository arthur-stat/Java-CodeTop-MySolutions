题目简述：

> 给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
> 请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。
>
> 你必须找到一个内存复杂度优于 `O(n^2)` 的解决方案。
>
> **进阶：**
>
> - 你能否用一个恒定的内存(即 `O(1)` 内存复杂度)来解决这个问题?
> - 你能在 `O(n)` 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) ）很有趣。

题目链接：[378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

# 值域二分 + 楼梯计数

## 思路

这是常规思路中最高效的一种。

本方法和常规的二分搜索不同——通常意义的二分搜索是利用值对索引进行二分。但在本问题中，我们直接对值域进行二分。根据给定矩阵的性质，范围内的最大值与最小值我们是可以直接得出来的——左上角元即为最小值，右下角元即为最大值。因此，我们取 `mid` 为最大值与最小值的均值——二分取 `mid` 为某个索引，然后统计矩阵中小于等于该值的元素数量。

统计这一数量的具体做法就是**楼梯计数**。如果矩阵内小于 `mid` 的数的数量大于 $k$，则收缩右边界，否则增加左边界。

本方法的分析和推理，我比较推荐直接阅读力扣官方题解：[有序矩阵中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/solutions/311472/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/)。这里就不多说啦~

本问题的官方题解写得很好！请直接移步至力扣官方题解。

## 代码

算法总体的时间复杂度为 $O\big(n\log(\max-\min)\big)$，空间复杂度为 $O(1)$。

其中，`countLessMid()` 方法的时间复杂度为 $O(n)$。

```java
class Solution {

    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int min = matrix[0][0];
        int max = matrix[n - 1][n - 1];

        while (min <= max) {
            int mid = min + (max - min) / 2;
            int count = countLessMid(matrix, mid);
            if (count < k) {
                min = mid + 1;
            } else {
                max = mid - 1;
            }
        }

         return min;
    }

    private int countLessMid(int[][] matrix, int mid) {
        int n = matrix.length;
        int count = 0;

        int x = n - 1;
        int y = 0;
        
        while (x >= 0 && y < n) {
            if (matrix[x][y] <= mid) {
                y++;
            } else {
                count += y;
                x--;
            }
        }

        if (x >= 0) {
            count += (x + 1) * y;
        }

        return count;
    }
}
```

# 转化为 Top-K

## 思路

显然地，只要我们算出最小的 $k$ 个元素，那么就能直接得到顺序第 $k$ 小的元素，于是问题可以被转化为 Top-K 问题。利用快速选择算法或大顶堆（优先队列）都可以实现解决 Top-K 问题的算法，且空间复杂度远低于 $O(n^2)$——只不过时间开销相比其他方法可能较高。

## 代码

这里以大顶堆为例，使用 Java 提供的优先队列内置实现。快速排序与手搓大小顶堆请参见我以前的题解。

算法的时间复杂度为 $O(n^2\log k)$，空间复杂度为 $O(k)$。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        PriorityQueue<Integer> pq = new PriorityQueue<>(k, (a, b) -> b - a);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                pq.offer(matrix[i][j]);
                if (pq.size() > k) pq.poll();
            }
        }
        
        return pq.poll();
    }
}
```

