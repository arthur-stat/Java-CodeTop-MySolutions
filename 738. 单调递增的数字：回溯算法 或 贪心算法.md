题目简述：

> 当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
>
> 给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

题目链接：[738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

# 回溯算法 · 全遍历

> 我的第一反应是数位 DP，尝试实现的一分钟后忽然发觉似乎直接考虑回溯算法就好了。

考虑回溯算法，配合合理高效的剪枝。

基本的 DFS 逻辑如下，按定义寻找从首位为 $0$ 的数字构造并搜索单调递增数字即可：

```java
class Solution {

    public static final int X_DIGIT = 10;

    public int monotoneIncreasingDigits(int n) {
        int[] path = new int[X_DIGIT];
        int i = 0;
        return dfs(String.valueOf(n), path, i, true, 0);
    }

    private int dfs(String n, int[] path, int i, boolean tight, int prev) {
        if (i == X_DIGIT) return intArrayToInt(path);
        int digit = getDigit(n, i);
        int res = 0;

        for (int d = prev; (!tight && d <= 9) || (tight && d <= digit); d++) {
            path[i] = d;
            res = Math.max(res, dfs(n, path, i + 1, (tight && d == digit) ? true : false, d));
        }

        return res;
    }

    private int getDigit(String n, int i) {
        i = n.length() + i - X_DIGIT;
        if (i < 0) return 0;
        return n.charAt(i) - '0';
    }

    private int intArrayToInt(int[] arr) {
        return Integer.parseInt(Arrays.stream(arr)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining()));
    }
}
```

这份代码在正确性上是毋庸置疑的，但面对大测试用例将会超时，因为算法会 “呆呆地” 遍历所有小于 `n` 的单调递增数字。我们需要合理的剪枝策略。

# 回溯算法 · 剪枝

最简单但极其有效的改进是在 `dfs()` 的 `for` 中 `tight == false` 时只搜索一位数字：

- 如果 `tight == true`，则继续按上述逻辑进行搜索，在 `d == digit` 时传递状态 `tight = true`，否则传递状态 `tight = false`；
- 如果 `tight == false`，则只探索 `9`，传递状态 `tight = false`。

因为我们只关心最大的单调递增数字，所以这样做是合理的，最大的单调递增数字必然只可能位于这两条路径上，读者自证不难。

```java
class Solution {

    public static final int X_DIGIT = 10;

    public int monotoneIncreasingDigits(int n) {
        int[] path = new int[10];
        int i = 0;
        return dfs(String.valueOf(n), path, i, true, 0);
    }

    private int dfs(String n, int[] path, int i, boolean tight, int prev) {
        if (i == X_DIGIT) return intArrayToInt(path);

        if (!tight) {
            path[i] = 9;
            return dfs(n, path, i + 1, false, 9);
        }

        int digit = getDigit(n, i);
        int res = 0;

        for (int d = prev; d <= digit; d++) {
            path[i] = d;
            res = Math.max(res, dfs(n, path, i + 1, (d == digit) ? true : false, d));
        }

        return res;
    }

    private int getDigit(String n, int i) {
        i = n.length() + i - X_DIGIT;
        if (i < 0) return 0;
        return n.charAt(i) - '0';
    }

    private int intArrayToInt(int[] arr) {
        return Integer.parseInt(Arrays.stream(arr)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining()));
    }
}
```

现在算法已经能很好地 AC 了。

# 贪心算法

回溯算法与数位 DP 类似地，都是从左往右搜索单调递增数字。

贪心算法则不同，贪心算法从右至左贪心地构造最大的单调递增数字。

记 $n[0]$ 为 $n$ 的最高位、$n[len]$ 为 $n$ 的最低位，贪心算法的思路是：

1. 从右至左地遍历数字 $n$，找到首个使得 $n[i]>n[i+1]$ 成立的位置；
2. ，如果 $n[i]>0$（这是必然成立的，因为 $n[i]>n[i+1]\geqslant0$），则
   - 第 $i$ 位上的值暂更新为 $n[i]-1$；
   - 第 $i$ 位右侧的所有数字全部更新为 $9$；
3. 继续向左遍历，直到找到下一个使得 $n[i']>n[i'+1]$ 成立的位置，或直至数字的尽头；
4. 最终修改后的 $n$ 即为最大的单调递增数字。

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String num = String.valueOf(n);
        char[] res = num.toCharArray();
        for (int i = num.length() - 2; i >= 0; i--) {
            if (res[i] > res[i + 1]) {
                res[i] = (char) (res[i] - 1);
                for (int j = i + 1; j < num.length(); j++) {
                    res[j] = '9';
                }
            }
        }

        return Integer.parseInt(new String(res));
    }
}
```

