题目简述：

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

题目链接：[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

# 回溯算法

如果只要求给出组合数量，那么本问题就是一个典型的完全背包模型，应考虑动态规划。

但这里要求给出具体的组合，这就应考虑回溯算法。组合问题是回溯算法的最经典应用之一。

# 代码实现

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Deque<Integer> path = new ArrayDeque<>();
        List<List<Integer>> res = new ArrayList<>();
        dfs(candidates, target, res, path, 0);
        return res;
    }

    private void dfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int index) {
        if (target == 0) res.add(new ArrayList<>(path));
        else if (target < 0) return;

        for (int i = index; i < candidates.length; i++) {
            path.push(candidates[i]);
            dfs(candidates, target - candidates[i], res, path, i);
            path.pop();
        }
    }
}
```

如果数据量很大，可以考虑事先排序然后剪枝：

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res = new ArrayList<>();
        backtrack(candidates, target, 0, new ArrayList<>(), res);
        return res;
    }

    private void backtrack(int[] nums, int remain, int start, List<Integer> path, List<List<Integer>> res) {
        if (remain == 0) {
            res.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = start; i < nums.length; i++) {
            if (nums[i] > remain) break;
            
            path.add(nums[i]);
            backtrack(nums, remain - nums[i], i, path, res);
            path.remove(path.size() - 1);
        }
    }
}
```