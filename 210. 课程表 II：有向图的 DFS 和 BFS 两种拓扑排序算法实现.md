题目简述：

> 现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。
>
> - 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。
>
> 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

题目链接：[210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

# 整体思想

这个问题的本质上是希望我们给出拓扑排序，和 [207. 课程表](https://leetcode.cn/problems/course-schedule/) 比较相似，只不过在那里只要求检测环，而这里更进一步，要求在无环时给出拓扑排序。

拓扑排序当然是 Kahn 算法（BFS）的应用场景。但是带记忆化搜索的 DFS 也是可以的，而且就时间复杂度的数量级而言是一致的。

---

无论是哪种算法实现，最好都先实现一个邻接表以降低搜索的时间开销。

# DFS 实现

## 前言

本文给出的实现实际上不是标准的 DFS 拓扑排序……更像是 Kahn 算法的递归版本。因为标准的 DFS 拓扑排序应该是不基于入度的。我对这种实现倒没有过多了解，所以暂且把 “递归 Kahn 算法” 称为 DFS 吧……嗯嗯这很不严谨。

也就是说，染色标记的确是 DFS，但 “DFS 拓扑排序” 其实不是标准的 DFS 拓扑排序的逻辑。但是方便考虑，本文还是称其为 DFS。

## 思路

由于没有要求具体的排序规则，只要能顺利修完所有课程即可，那么就可以先按照 [207. 课程表](https://leetcode.cn/problems/course-schedule/) 的思路通过染色标记判断是否存在环，如果不存在环那么就一定可以修完所有课程。

如果不存在环，则当符合以下条件时，我们将课程纳入到学习路径中、作为下一个将学习的课程：

1. 当前学习路径下该课程尚未被学习；
2. <u>当前学习路径下该课程的所有前驱课程均已被学习。</u>

不必担心第二种情况选择忽略该课程是否会导致漏解，因为只要不存在环、可以学习完全部课程，那么学习路径上总有一个位置我们能学习完他的全部前驱课程，最终顺利学习完该课程。

要检验当前课程是否符合第二种情况，可以通过反向入度表进行检查，也可以动态维护入度表实现。

实际上，拓扑排序会给出不存在环的节点的拓扑序，因此直接进行拓扑排序即可，最后观察是否所有节点都在拓扑序中就可以知道是否存在依赖循环（环路）。也就是说，不必先进行染色标记以判断环路。

## 算法（染色+排序两步流程）

这一实现就严格遵照上述分析实现——将环检测与构建学习路径分为两步走，算法的时间复杂度为 $O(V+E)$，空间复杂度为 $O(V+E)$。

这一实现仅作演示，表示我们如何从 [207. 课程表](https://leetcode.cn/problems/course-schedule/) 的逻辑推进至本问题 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)。下文将会提到实际上并不需要单独通过染色标记进行环路检测 `dfs`，因为 DFS 可以直接利用入度进行拓扑排序，并且在拓扑排序时能够直接检测出环。

这也意味着 DFS 有两种环路检测的实现，一种是基于图论拓扑排序的，一种是染色标记的。这一实现的环路检测就是染色标记的。

```java
class Solution {

    private Map<Integer, ArrayList<Integer>> adj;
    private boolean[] searched;
    private int k;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        adj = new HashMap<>(numCourses);
        searched = new boolean[numCourses];  // init false

        // Init for adj
        for (int[] p : prerequisites) {
            if (!adj.containsKey(p[1])) adj.put(p[1], new ArrayList<>());
            adj.get(p[1]).add(p[0]);
        }

        // Cycle Detection
        boolean[] visited = new boolean[numCourses];  // init false
        for (int i = 0; i < numCourses; i++) {
            if(dfs(i, visited)) return new int[0];
        }

        // 统计入度，初始化入度数组
        int[] in_degree = new int[numCourses];  // init 0
        for (int[] p : prerequisites) {
            in_degree[p[0]]++;
        }

        // 获取入度为 0 的课程
        ArrayList<Integer> predeccessors = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            if (in_degree[i] == 0) predeccessors.add(i);
        }

        // 构建修习路径
        int[] path = new int[numCourses];
        // boolean[] visited = new boolean[numCourses];  // `visited` should now be entirely false.
        k = 0;
        for (int predeccessor : predeccessors) {
            buildPath(predeccessor, in_degree, visited, path);
        }

        return path;
    }

    /**
     * 返回 true 表示有环，返回 false 表示无环
     */
    private boolean dfs(int courseStart, boolean[] visited) {
        if (searched[courseStart]) return false;

        ArrayList<Integer> successors = adj.getOrDefault(courseStart, null);
        if (successors != null) {
            visited[courseStart] = true;
            for (int successor : successors) {
                if (visited[successor]) return true;
                if (dfs(successor, visited)) return true;
            }
            visited[courseStart] = false;
        }
        searched[courseStart] = true;
        return false;
    }

    private void buildPath(int course, int[] in_degree, boolean[] visited, int[] path) {
        if (visited[course]) return;

        visited[course] = true;
        path[k++] = course;
        ArrayList<Integer> successors = adj.getOrDefault(course, null);
        if (successors != null) {
            for (int successor : successors) {
                in_degree[successor]--;
                if (in_degree[successor] == 0) buildPath(successor, in_degree, visited, path);
            }
        }
    }
}
```

## 算法改进（拓扑排序一步流程）

实际上上述算法可以进行改进——我们可以像 BFS 一样直接进行拓扑排序，并在这一过程中直接检测出是否存在环，而不必先进行环路检测，再利用入度构建学习路径。我们甚至不需要为 `buildPath` 方法也加上 `visited` 染色标记的逻辑，因为只要最后存在环，那么拓扑排序就无法把环路上的节点纳入到结果中——他们存在循环依赖，是我们无论如何也无法学习的课程。因此，比较可以学习的课程数量、即拓扑排序给出的序列长度就可以知道我们能否学习完全部课程，而不必显式地染色标记。

这一实现的时间复杂度和空间复杂度均为 $O(V+E)$，常数因子比上述算法更小一点，在数量级上无差异。

算法里也用到了 `visited`，但目的是为了记忆化搜索以避免重复搜索，而不是靠染色标记判断是否存在环路。

```java
class Solution {

    private Map<Integer, ArrayList<Integer>> adj;
    private int k;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        adj = new HashMap<>(numCourses);

        // Init for adj
        for (int[] p : prerequisites) {
            if (!adj.containsKey(p[1])) adj.put(p[1], new ArrayList<>());
            adj.get(p[1]).add(p[0]);
        }

        // 统计入度，初始化入度数组
        int[] in_degree = new int[numCourses];  // init 0
        for (int[] p : prerequisites) {
            in_degree[p[0]]++;
        }

        // 获取入度为 0 的课程
        ArrayList<Integer> predeccessors = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            if (in_degree[i] == 0) predeccessors.add(i);
        }

        // 构建修习路径
        int[] path = new int[numCourses];
        boolean[] visited = new boolean[numCourses];  // init false
        k = 0;
        for (int predeccessor : predeccessors) {
            buildPath(predeccessor, in_degree, visited, path);
        }

        // 如果存在环
        if (k < numCourses - 1) return new int[0];

        return path;
    }

    private void buildPath(int course, int[] in_degree, boolean[] visited, int[] path) {
        if (visited[course]) return;

        visited[course] = true;
        path[k++] = course;
        ArrayList<Integer> successors = adj.getOrDefault(course, null);
        if (successors != null) {
            for (int successor : successors) {
                in_degree[successor]--;
                if (in_degree[successor] == 0) {
                    buildPath(successor, in_degree, visited, path);
                }
            }
        }
    }
}
```

# BFS 实现

## 思路

简单的逻辑是我们每次都把入度为 0 的课程加入到 `path` 中，然后更新入度数组，继续把入度为 0 的课程加入到 `path` 即可。比较标准的做法（Kahn 算法）是利用队列构造显式的层序关系，在一个层序中：

1. 首先将入度为 0 的节点全部加入队列；
2. 逐个从队列中取出元素，每取出一个元素就更新入度，然后将新的入度为 0 的节点作为下一层序的元素加入队列；
3. 直到取完队列中当前层序的全部元素，进入到下一层序。

这样就是最标准的 Kahn 算法。

## 遍历算法

这一实现逻辑上很简单，通过多次遍历扫描实现 BFS 而不使用队列，时间复杂度比较高，为 $O(V^2+E)$。如果要对其进行改进，那么就是显式使用队列以高效实现 BFS，这样得到的就是标准的 Kahn 算法。空间复杂度为 $O(V+E)$，空间开销主要来自于邻接表，相比标准的 Kahn 算法倒是节约了 $O(V)$ 的队列空间开销。

```java
class Solution {

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, ArrayList<Integer>> adj = new HashMap<>(numCourses);

        // Init for adj
        for (int[] p : prerequisites) {
            if (!adj.containsKey(p[1])) adj.put(p[1], new ArrayList<>());
            adj.get(p[1]).add(p[0]);
        }

        // 统计入度，初始化入度数组
        int[] in_degree = new int[numCourses];  // init 0
        for (int[] p : prerequisites) {
            in_degree[p[0]]++;
        }

        boolean updated = false;
        int k = 0;
        int[] path = new int[numCourses];
        while (k < numCourses) {
            for (int i = 0; i < numCourses; i++) {
                if (in_degree[i] == 0) {
                    path[k++] = i;
                    in_degree[i] = -1;
                    ArrayList<Integer> successors = adj.getOrDefault(i, null);
                    if (successors != null) {
                        for (int successor : successors) {
                            in_degree[successor]--;
                        }
                    }
                    updated = true;
                }
            }

            if (!updated) return new int[0];
            updated = false;
        }

        return path;
    }
}
```

## 标准 Kahn 算法

这一实现是标准的 Kahn 算法，时间复杂度为 $O(V+E)$，空间复杂度为 $O(V+E)$。

```java
class Solution {
    
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 1. 构建邻接表和入度数组
        Map<Integer, List<Integer>> adj = new HashMap<>();
        int[] inDegree = new int[numCourses];
        
        for (int[] p : prerequisites) {
            adj.computeIfAbsent(p[1], k -> new ArrayList<>()).add(p[0]);
            inDegree[p[0]]++;
        }

        // 2. 初始化队列（入度为0的节点）
        Queue<Integer> q = new LinkedList<>();
        for (int u = 0; u < numCourses; u++) {
            if (inDegree[u] == 0) q.add(u);
        }

        // 3. 拓扑排序
        int[] path = new int[numCourses];
        int k = 0;
        while (!q.isEmpty()) {
            int u = q.poll();
            path[k++] = u;
            for (int v : adj.getOrDefault(u, new ArrayList<>())) {
                if (--inDegree[v] == 0) q.add(v);
            }
        }

        // 4. 检查是否有环
        return (k == numCourses) ? path : new int[0];
    }
}
```

