题目简述：

> 有 `n` 个气球，编号为`0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。
>
> 现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 `i - 1` 和 `i + 1` 代表和 `i` 相邻的两个气球的序号。如果 `i - 1`或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。
>
> 求所能获得硬币的最大数量。
>
> **提示：**
>
> - `n == nums.length`
> - `1 <= n <= 300`
> - `0 <= nums[i] <= 100`

题目链接：[312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

# 思路

最简单的方案是回溯算法暴力遍历所有可能的解，而且这里可以利用缓存设计记忆化搜索，因为：当我们已经戳破了 $k$ 个气球，对于剩下 $n-k$ 个气球所能获得的最大硬币数是能够唯一确定的。因此，记忆化搜索最简单的实现就是设计状态为剩下哪些气球，对探索过的状态直接返回结果。

但这样设计状态是无法 AC 的，因为这样实现的记忆化回溯算法可能的子集状态有 $2^n$ 个，在每种状态下需要枚举 $O(n)$ 个选择（下一个戳破的气球），因此算法的时间复杂度为 $O(n2^n)$。尽管这比无记忆化的暴力搜索 $O(n!)$ 时间复杂度已经小上不少，但在 $n$ 最大为 $300$ 的数据范围下也是不可被接受的：$300\times 2^{300}\approx10^{93}\gg10^{10}$。

尽管按照上文思路设计的算法不可行、无法 AC，但他为我们提示了一个很好的思路：超时不是记忆化的问题，而是状态设计导致状态过多的问题，导致记忆化无法高效发挥。我们可以考虑改变状态的设计从而实现更高效的记忆化搜索或动态规划。

针对这种情况与本问题的特点，一个好的方案就是考虑区间 DP，设计状态 $dp[i][j]$（在分析中采取 1-based，编写代码时考虑 0-based）表示原本的第 $i+1$ 个气球至原本的第 $j-1$ 个气球最多能获得多少硬币，注意这里不能保证原本的第 $i$ 个气球与原本的第 $j$ 个气球仍存在。为什么定义成开区间呢？继续阅读想必就会明白其中的原因，暂且当作闭区间的定义（主动戳破原本的第 $i$ 个气球至原本的第 $j$ 个气球）也是可以的，因为继续阅读下去稍后就会自然地意识到定义为开区间会方便不少。

接下来的则是关键：寻找 $dp[i][j]$ 的状态转移时，不要正向考虑下次戳破哪个气球，因为这样的话状态空间实际上与此前提到的记忆化搜索是一模一样的，无法高效求解；而应该***<u>反向思考</u>***，考虑最后戳破的是哪个气球，则状态转移为
$$
dp[i][j]=\max\big\{vals[i]\cdot vals[k]\cdot vals[j]+dp[i][k]+dp[k][j]:i<k<j\big\}
$$
（$vals$ 暂时可以视为 $nums$，后文将解释）

其中，$k$ 的含义是最后一个被戳破的气球是原本的第 $k$ 个气球。这也是为什么此前将 $dp[i][j]$ 定义为开区间的原因，因为这样我们可以保证原本的第 $i$ 个气球与原本的第 $j$ 个气球最后未被戳破，他们恰好分别就是最后一个被戳破的气球 $k$ 的左侧的首个气球与右侧的首个气球。

为了不必单独处理边界条件，可以用扩充后的数组 $vals$ 代替 $nums$，$vals$ 在 $nums$ 的左右两侧插入两个 dummy 元素，值为 $1$。这样做有两个好处：

1. 因为我们所定义的 $dp$ 语义是开区间，因此要在 $nums$ 上计算解，只能最终计算至 $dp[-1][n+1]$——这很奇怪；
2. 使用扩充后的 $vals$ 代替 $nums$，我们就只需要计算至 $dp[0][N]$（$N=n+2$，为 $vals$ 的长度），这很符合直观；
3. 除了符合直观以外，最重要的是不必单独处理 “如果 `i - 1`或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球” 的逻辑了，此时两个哨兵元素仅负责提供边界值 $1$ 而不会被纳入 “需要被戳破的气球” 的语义中。

可见，使用 $vals$ 是一举多得的。

初始化条件：
$$
\forall i,\ \ dp[i][i+2]=vals[i]\cdot vals[i+1]\cdot vals[i+2]
$$
如果正向思考首个戳破哪个气球，就不得不维护一个不断更新余下未戳破气球的数组以快速寻找下一次戳破某个气球时该气球左侧的首个未戳破气球与右侧的首个未戳破气球，于是我们实际上就需要考虑三个动态的变量：下一个戳破的气球，下一个戳破气球的左侧首个未戳破气球，下一个戳破气球的右侧首个未戳破气球。而当我们反向思考后，就不需要维护这样一个记录剩余气球的数组，我们只需要关注最后一个被戳破的气球是谁——他的左侧首个未戳破气球确定为原本的第 $i$ 个气球、他的右侧首个未戳破气球确定为原本的第 $j$ 个气球。

似乎区间 DP 问题中有不少需要这样反向思考才能找到高效状态转移的问题。

最后，在设计区间 DP 具体的算法时，填表的顺序是按照区间的大小进行搜索，而不是单纯的从左至右或自下而上，因此外层循环应该定义为区间的长度。初始化时已经给出了区间长 3 的结果，所以外层循环可以从区间长 4 开始填表。本问题作为区间 DP 问题，从其依赖关系也可以看出，我们无法用滚动数组降低空间复杂度。

这可能不太直观。改为从上往下的记忆化搜索的形式会更容易理解一点。

# 代码

算法的时间复杂度为 $O(n^3)$，空间复杂度为 $O(n^2)$。

```java
class Solution {
    public int maxCoins(int[] nums) {
        int N = nums.length + 2;
        int[] vals = new int[N];
        vals[0] = 1;
        vals[N - 1] = 1;
        System.arraycopy(nums, 0, vals, 1, nums.length);

        int[][] dp = new int[N][N];
        // init
        for (int i = 0; i < N - 2; i++) {
            dp[i][i + 2] = vals[i] * vals[i + 1] * vals[i + 2];
        }

        for (int size = 4; size <= N; size++) {    // size: interval width
            for (int i = 0; i <= N - size; i++) {  // i:    interval start
                int j = i + size - 1;
                int dp_max = 0;
                
                // loop for dp[i][j] = max(...)
                for (int k = i + 1; k < j; k++) {
                    dp_max = Math.max(dp_max, vals[i] * vals[k] * vals[j] + dp[i][k] + dp[k][j]);
                }

                dp[i][j] = dp_max;
            }
        }

        return dp[0][N - 1];
    }
}
```

