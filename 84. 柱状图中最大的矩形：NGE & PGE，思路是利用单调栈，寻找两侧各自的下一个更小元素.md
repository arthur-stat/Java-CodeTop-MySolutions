题目简述：

> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。

题目链接：[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

# 思路

对于一个柱状图中最大面积的矩形，它必然有这样的性质：

- 矩形所在的范围内一定存在一个最小值（可能不唯一），记为 `heights[i]`；
- 矩形范围内的任何元素均不小于该值，否则 `heights[i]` 就不是最小值了；
- 矩形左侧的第一个元素与矩形右侧的第一个元素必然小于该值，否则该矩形可以继续延展，得到面积更大的矩形。

因此，我们可以考虑用单调栈寻找下一个或上一个更小元素，首先正向用单调栈遍历寻找每个元素的下一个更小元素，再反向用单调栈遍历寻找每个元素的上一个更小元素，然后就可以算出以某个元素为范围内最小值的最大矩形的面积。当我们再次遍历数组、算出分别以每个元素为范围内最小值的最大矩形面积时，这些面积的最大值就是全局面积最大的矩形面积。

# 代码

时间复杂度为 $O(n)$，AC 时耗时 42ms。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxSqure = 0;
        int[] nextLess = nextLessElement(heights);
        int[] lastLess = nextLessElementInverse(heights);

        for (int i = 0; i < n; i++) {
            int last = lastLess[i];
            int next = nextLess[i];
            int squre;

            if (last != -1 && next != -1) {
                squre = heights[i] * (next - last - 1);
            } else if (last != -1) {
                squre = heights[i] * (n - last - 1);
            } else if (next != -1) {
                squre = heights[i] * next;
            } else {
                squre = heights[i] * n;
                
            }
            maxSqure = Math.max(maxSqure, squre);
        }
        return maxSqure;
    }

    // 从左至右扫描每个元素的下一个严格更小元素（单调栈），返回索引数组
    public int[] nextLessElement(int[] nums) {
        int n = nums.length;
        Deque<Integer> s = new ArrayDeque<>();
        int[] nextLess = new int[n];
        Arrays.fill(nextLess, -1);

        for (int i = 0; i < n; i++) {
            while (!s.isEmpty() && nums[s.peek()] > nums[i]) {
                int j = s.pop();
                nextLess[j] = i;
            }
            s.push(i);
        }
        return nextLess;
    }

    // 从右至左扫描每个元素的前一个严格更小元素（单调栈），返回索引数组
    public int[] nextLessElementInverse(int[] nums) {
        int n = nums.length;
        Deque<Integer> s = new ArrayDeque<>();
        int[] lastLess = new int[n];
        Arrays.fill(lastLess, -1);

        for (int i = n - 1; i >= 0; i--) {
            while (!s.isEmpty() && nums[s.peek()] > nums[i]) {
                int j = s.pop();
                lastLess[j] = i;
            }
            s.push(i);
        }
        return lastLess;
    }
}
```

# 优化思路

可以只做一遍扫描，而不必正向扫描一遍再反向扫描一遍。

- 左边界在 “把 `i` 压栈之前” 的那一刻确定；

- 右边界在 “把某个下标 `j` 从栈里弹出” 的那一刻由当前的 `i` 确定。

因此，一次单调栈扫描就可以得到一些元素的左边界与一些元素的右边界，并不需要进行两边扫描。只不过两边扫描理解起来更容易。

虽然时间复杂度数量级上无差异，但常数更小。

> 两次单调栈的方案是一次扫描中只实现寻找某一侧的下一个更大 / 更小元素，进行两次扫描后即得到两侧的下一个更大 / 更小元素，这是只利用了 “出栈” 的信息。事实上，同时利用上 “留在栈内” 的信息，可以在一次扫描中同时获得两侧的下一个更大 / 更小元素。

此外，由于 `n` 是确定的，可以用数组代替栈对象。

# 优化代码

本版代码做了如下改进：

- 用 `int[]` 模拟栈；
- 单调栈一次扫描获得全部的各元素左右侧下一个更小元素。

时间复杂度为 $O(n)$，AC 时耗时 10ms。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxSqure = 0;
        int[][] tmp = scan(heights);
        int[] lastLess = tmp[0];
        int[] nextLess = tmp[1];

        for (int i = 0; i < n; i++) {
            int last = lastLess[i];
            int next = nextLess[i];
            int squre;

            if (last != -1 && next != 0) {
                squre = heights[i] * (next - last - 1);
            } else if (last != -1) {
                squre = heights[i] * (n - last - 1);
            } else if (next != 0) {
                squre = heights[i] * next;
            } else {
                squre = heights[i] * n;
                
            }
            maxSqure = Math.max(maxSqure, squre);
        }
        return maxSqure;
    }

    // 从左至右一次扫描，返回 lastLess 与 nextLess
    public int[][] scan(int[] nums) {
        int n = nums.length;
        int[] lastLess = new int[n];
        int[] nextLess = new int[n];
        int[] stack = new int[n];
        int stackTop = -1;

        for (int i = 0; i < n; i++) {
            while (stackTop >= 0 && nums[stack[stackTop]] > nums[i]) {
                nextLess[stack[stackTop--]] = i;
            }
            lastLess[i] = stackTop >= 0 ? stack[stackTop] : -1;
            stack[++stackTop] = i;
        }
        return new int[][]{lastLess, nextLess};
    }
}
```

