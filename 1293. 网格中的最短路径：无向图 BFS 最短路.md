题目简述：

> 给你一个 `m * n` 的网格，其中每个单元格不是 `0`（空）就是 `1`（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。
>
> 如果您 **最多** 可以消除 `k` 个障碍物，请找出从左上角 `(0, 0)` 到右下角 `(m-1, n-1)` 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 `-1` 。

题目链接：[1293. 网格中的最短路径](https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

# 思路

本来我看到问题后首先想到的是 A\* 算法，因为 A\* 算法能够很好地解决带障碍物的无向图最短路问题，但随即发现本问题存在的不是不可被摧毁的障碍物，而是存在的可被摧毁但可摧毁数有限的障碍物，那么有可能考虑经典 BFS 会更容易实现。

设计状态 `State`，其中封装了当前坐标与到达该坐标时的剩余可摧毁障碍物个数，然后对于队列中的每个点考虑走到上下左右四个邻居，即下一个层序，进行无向图的 BFS。

# 代码

一共存在 `m * n * (k - 1)` 个状态，因此算法的时间复杂度为 $O(mnk)$，空间复杂度为 $O(mnk)$。

```java
record State(int i, int j, int cross) {}

class Solution {

    private int[][] grid;
    private int m;
    private int n;

    public int shortestPath(int[][] grid, int k) {
        m = grid.length;
        n = grid[0].length;
        this.grid = grid;
        Deque<State> queue = new ArrayDeque<>();
        Set<State> visited = new HashSet<>();

        int step = 0;
        State origin = (grid[0][0] == 0) ? new State(0, 0, k) : new State(0, 0, k - 1);
        if (origin.cross() < 0) return -1;
        queue.offer(origin);
        visited.add(origin);
        int count = 1;

        while (!queue.isEmpty()) {
            State s = queue.poll();
            count--;
            if (s.i() == m - 1 && s.j() == n - 1) return step;

            int i = s.i();
            int j = s.j();
            int cross = s.cross();

            State up = next(i - 1, j, cross);
            State dw = next(i + 1, j, cross);
            State le = next(i, j - 1, cross);
            State ri = next(i, j + 1, cross);
            if (up != null && !visited.contains(up)) {
                queue.offer(up);
                visited.add(up);
            }
            if (dw != null && !visited.contains(dw)) {
                queue.offer(dw);
                visited.add(dw);
            }
            if (le != null && !visited.contains(le)) {
                queue.offer(le);
                visited.add(le);
            }
            if (ri != null && !visited.contains(ri)) {
                queue.offer(ri);
                visited.add(ri);
            }

            
            if (count == 0) {
                count = queue.size();
                step++;
            }
        }

        return -1;
    }

    public State next(int i, int j, int prevCross) {
        if (i < 0 || i >= m || j < 0 || j >= n) return null;

        if (grid[i][j] == 1) {
            if (prevCross == 0) return null;
            prevCross--;
        }

        return new State(i, j, prevCross);
    }
}
```

# 优化性能

尽管理论时间复杂度上限是无法进一步降低的，但我们可以对上述算法做许许多多小优化。

例如，不必显式在 `Set<State> visited` 中存储出所有对象，只需要一张 `m * n` 尺寸的 `int[][]` 表格，在表格中存储到达该点时的最大剩余可摧毁障碍物次数。这样就不再需要 `Set<State> visited` 了，对 JVM 而言能够大大降低 GC 压力。

> 其实也可以用三元数组替换掉 `record State`，可能会更高效一丢丢？

然后可以进行许多优化剪枝，其中很重要的一个剪枝就是基于上面的存储到达某点时的最大剩余可摧毁障碍物次数 `int[][]` 表格，如果该点尚未被访问或者再次到达时最大剩余可摧毁障碍物次数更大，则更新表格中该点对应的值，否则可以直接剪枝，因为如果是再次到达该点的，那么二次到达该点所花费的步数不可能比首次到达该点时的更少，若此时剩余可摧毁障碍物次数还没有首次到达时的多，那么就可以保证要么第二次到达时的状态不是最优解路径上的状态，要么与首次到达的状态同为最优解上路径的状态。

此外还可以结合一些其他的剪枝策略，比如如果点到终点的曼哈顿距离已经小于剩余可摧毁障碍物次数，那么便可以直接返回结果。