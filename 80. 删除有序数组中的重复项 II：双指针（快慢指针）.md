题目简述：

> 给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在**原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

题目链接：[80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

# 思路

双指针，慢指针 `i` 指向下一个写入位置，快指针 `j` 指向下一个扫描位置，然后按下述策略更新数组与指针：

- 如果 `j` 访问的元素较之前一个元素更大，则立刻写入 `nums[j]` 一次；
- 如果 `j` 访问的元素与上一个元素等大小，
  - 若 `j` 访问该值的次数小于两次，则立刻写入 `nums[j]` 一次；
  - 若 `j` 访问该值的次数已经达到两次，则移动 `j` 至首个大于该值的元素，不进行写入操作，转移至第一种情况。

代码的实现中有一个小细节是为方便与上一个元素进行大小的对比，可以初始化 `i = 1`、`j = 1`。这样做是合理的，因为 `j = 1` 才方便统一对比的逻辑而不必考虑索引越界，而 `i = 1` 蕴含了 “写入一次 `nums[0]`”，这是由于无论如何 `nums[0]` 一定会被写入一次于索引 0，而在我们的更新策略下写入操作是相对滞后的——只在状态改变至某些情形才执行写操作，这导致如果从 `i = 0` 开始会遗漏解，而从 `i = 1` 开始则恰契合我们的更新策略。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        int i = 1;
        int j = 1;
        int prevCount = 1;

        main_loop:
        while (j < n) {
            if (nums[j] > nums[j - 1]) {
                nums[i++] = nums[j];
                prevCount = 1;
                j++;
            } else if (prevCount < 2) {
                nums[i++] = nums[j];
                prevCount++;
                j++;
            } else {
                while (j < n - 1 && nums[j] == nums[j + 1]) {
                    j++;
                }
                j++;
            }
        }

        return i;
    }
}
```

