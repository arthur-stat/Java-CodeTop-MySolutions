题目简述：

> 给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。

题目链接：[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

# 思路

设计一个新的类 `Str`，该类与 `String` 的语义等价，但重写其 `hashCode()` 与 `equals()` 方法：重写为只要两个新类的字符频数统计相等，那么就认为两个新类相等。

这样，HashMap 就会将字符频数相同的单词视为 “相同的”，进而语义为互不相同的字母异位词的新类作为 key 时，HashMap 将认为他们是 “相同的”，于是我们就可以把互为字母异位词的单词们语放到同一个集合 value 中去。

实际的代码实现中不直接重写 `String` 而是组合 `String` 当然是因为 Java 不允许我们继承本就不可变的 `String` 了~

---

如果所使用的编程语言的字符串是可变的（或者自己重新写了一个可变的字符串对象出来？），那么也可以直接将排序后的字符串副本作为 key，这样就不需要设计新的类，效果是一样的。

# 代码

```java
class Solution {

    private static class Str {
        
        private String str;
        private final int[] freq = new int[26];
        private final int hash;

        public Str(String str) {
            this.str = str;
            for (char c : str.toCharArray()) {
                freq[c - 'a']++;
            }
            hash = Arrays.hashCode(freq);
        }

        @Override
        public int hashCode() {
            return hash;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Str other)) return false;
            return Arrays.equals(this.freq, other.freq);
        }
    }

    public List<List<String>> groupAnagrams(String[] strs) {
        Map<Str, List<String>> map = new HashMap<>();
        for (String s : strs) {
            Str key = new Str(s);
            List<String> list = map.getOrDefault(key, null);
            if (list == null) {
                list = new ArrayList<String>();
                map.put(key, list);
            }

            list.add(s);
        }

        return new ArrayList<>(map.values());
    }
}
```

