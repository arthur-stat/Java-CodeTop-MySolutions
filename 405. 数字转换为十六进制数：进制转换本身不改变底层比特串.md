题目简述：

> 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用补码运算方法。
>
> 答案字符串中的所有字母都应该是小写字符，并且除了 0 本身之外，答案中不应该有任何前置零。
>
> **注意:** 不允许使用任何由库提供的将数字直接转换或格式化为十六进制的方法来解决这个问题。
>
> **示例 1：**
>
> > 输入：num = 26
> > 输出："1a"
>
> **示例 2：**
>
> > 输入：num = -1
> > 输出："ffffffff"

题目链接：[405. 数字转换为十六进制数](https://leetcode.cn/problems/convert-a-number-to-hexadecimal/)

# 思路

如果 `num` 是非负数，那么还是很容易转换的。例如，下面的代码就能从数学进制的视角漂亮地完成 10 进制正数的 16 进制换算：

```java
while (num > 0) {
    res.append(numberToChar(num % 16));
    num /= 16;
}
```

现在要求以补码的十六进制形式表示负数，这似乎有点棘手。我们都知道补码等于绝对值的反码加一，但难道我们真的要去再写一个十六进制字符串的加法运算吗？显然麻烦了。

不要去考虑如何从数值的绝对值出发计算其补码。注意到计算机内本就是以补码的形式存储的数字，不要忽略下面这一重要的事实：原本是什么编码，那么我们将其按比特位转换为新进制，则转换后依然是什么编码。原码进制转换后依然是原码，反码转换后依然是反码，补码转换后依然是补码。任何编码方式都遵循这一规律，因为我们实际上根本没有改变比特位，仅仅是换了种写法。

所以不要去特殊处理补码的符号位，将其视为与普通位地位平等的平凡比特位即可。

因此，要得到十六进制的补码，只需要将原本的二进制补码每四个二进制位转换为一个十六进制位即可，其他的什么也不需要改变。

# 代码

```java
class Solution {
    public String toHex(int num) {
        char[] res = new char[8];
        int k = 7;
        for (int i = 0; i < 8; i++) {
            res[k--] = digitToChar(num >>> 4 * i & 0xf);
        }
        StringBuilder sb = new StringBuilder();
        k = 0;
        while (res[k] == '0' && k < 7) k++;
        for (int j = k; j < 8; j++) sb.append(res[j]);
        return sb.toString();
    }

    private char digitToChar(int digit) {
        if (digit <= 9) return (char) (digit + '0');
        return (char) (digit - 10 + 'a');
    }
}
```

