题目简述：

> 给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。
>
> 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。
>
> 返回机器人能够到达右下角的不同路径数量。
>
> 测试用例保证答案小于等于 `2 * 10^9`。

题目链接：[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

# 思路

如果不存在障碍物，那么这就是一个简单的二维动态规划问题，即 [62. 不同路径](https://leetcode.cn/problems/unique-paths/)。考虑障碍物，但机器人仍然只能每次向下或向右移动，那么我们仍考虑为动态规划——只不过考虑障碍物，这会改变状态转移。

定义 $dp[i][j]$ 表示机器人移动至 `grid[i][j]` 的全部不同路径数量，则
$$
dp[i][j]=\left\{\begin{align}&dp[i-1][j]+dp[i][j-1],&&\mathrm{obstacleGrid}[i][j]=0\\\\&0,&&\mathrm{obstacleGrid}[i][j]=1\end{align}\right.
$$
初始化：
$$
dp[0][0]=1
$$

$$
\forall j>0,\ \ dp[0][j]=dp[i-1][j]
$$

$$
\forall i>0,\ \ dp[i][0]=dp[i][j-1]
$$

最终 $dp$ 矩阵的最后一个主对角元即问题的解。

# 代码

使用滚动数组优化空间开销。算法的时间复杂度为 $O(mn)$，空间复杂度为 $O\big(\min\{m,n\}\big)$。

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid[0][0] == 1) return 0;

        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid[m - 1][n - 1] == 1) return 0;

        int[] dp1 = new int[n];
        int[] dp2 = new int[n];

        dp1[0] = 1;
        for (int j = 1; j < n; j++) {
            dp1[j] = obstacleGrid[0][j] == 0 ? dp1[j - 1] : 0;
        }

        for (int i = 1; i < m; i++) {
            dp2[0] = obstacleGrid[i][0] == 0 ? dp1[0] : 0;

            for (int j = 1; j < n; j++) {
                dp2[j] = obstacleGrid[i][j] == 0 ? dp1[j] + dp2[j - 1] : 0;
            }

            int[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
        }

        return dp1[n - 1];
    }
}
```