题目简述：

> 给你一个整数数组 `arr`，只有可以将其划分为三个和相等的 **非空** 部分时才返回 `true`，否则返回 `false`。
>
> 形式上，如果可以找出索引 `i + 1 < j` 且满足 `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])` 就可以将数组三等分。

题目链接：[1013. 将数组分成和相等的三个部分](https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/)

# 思路

数组 `arr` 的总和是固定的，因此如果数组能够被按题目要求划分为三个部分，那么三个部分的和均为 `sum(arr) / 3`。

所以可以考虑前缀和数组 `prefix`，找出前缀和数组中按顺序出现的 `sum(arr) / 3`、`2 * sum(arr) / 3` 以及 `sum(arr)`。其中 `sum(arr)` 就是前缀和数组 `prefix` 的末位元素，我们只需要确保第三段子数组非空即可，因此实际上只需要找前缀和数组 `prefix` 中是否先后出现了 `sum(arr) / 3` 以及 `2 * sum(arr) / 3`（同时判断第三段子数组是否为空）。

能否找到前缀和数组中先后出现的先后出现的 `sum(arr) / 3` 以及 `2 * sum(arr) / 3` 且第三段子数组非空，是能否找到符合问题要求的划分的充要条件。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean canThreePartsEqualSum(int[] arr) {
        int n = arr.length;
        int[] prefix = new int[n + 1];
        for (int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + arr[i - 1];
        if (prefix[n] % 3 != 0) return false;

        int t1 = prefix[n] / 3;
        int t2 = 2 * t1;

        boolean seg1 = false;  // 是否找到了 sum(arr) / 3
        boolean seg2 = false;  // 是否找到了 2 * sum(arr) / 3
        boolean seg3 = false;  // 是否找到了第三段非空的子数组
        for (int i = 1; i <= n; i++) {
            if (seg1 && prefix[i] == t2) {
                seg2 = true;
                if (i < n) seg3 = true;  // 确保第三段子数组非空
            }
            if (prefix[i] == t1) seg1 = true;
        }

        return seg1 && seg2 && seg3;
    }
}
```

