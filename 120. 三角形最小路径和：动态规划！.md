题目简述：

> 给定一个三角形 `triangle` ，找出自顶向下的最小路径和。
>
> 每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。
>
> **进阶：**
>
> - 你可以只使用 `O(n)` 的额外空间（`n` 为三角形的总行数）来解决这个问题吗？

题目连接：[120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

# 思路

题目有说 `1 <= triangle.length <= 200`，因此 DFS 暴力搜索路径数量最多有 $2^{199}$ 种，这必然会超时。

那么考虑动态规划？的确可行！定义 $dp[i][j]$ 为第 $i$ 层且终点为第 $j$ 个元素时的最小路径和，那么在已知 $\forall k<i,\ \ dp[k][\ast]$ 的前提下，$dp[i][j]$ 是非常容易计算的，这也就是状态转移：
$$
dp[i][j]=\mathrm{triangle}[i][j]+\min\big\{dp[i-1][j-1],\ dp[i-1][j]\big\}
$$
甚至可以轻松的用滚动数组做到 $O(n)$ 的空间复杂度！时间复杂度为 $O(n^2)$。

# 代码

其实可以自下而上遍历（在逻辑上是找自底向上的最小路径和——反正不管怎么走都是求最小路径和），这样的话可以进一步省去对最底层 $dp$ 数组求最小值的开销，而且无需单独处理对每行末位元素 $dp[i][j']$ 而言不存在 $dp[i-1][j']$ 的情况。

这里我们就采取这样的实现，时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int m = triangle.size();
        int n = triangle.get(m - 1).size();
        int[] dp1 = triangle.get(m - 1).stream()
            .mapToInt(Integer::intValue)
            .toArray();
        int[] dp2 = new int[n];

        for (int row = m - 2; row >= 0; row--) {
            List<Integer> layer = triangle.get(row);

            for (int col = 0; col < row + 1; col++) {
                dp2[col] = layer.get(col) + Math.min(dp1[col], dp1[col + 1]);
            }

            int[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
        }

        return dp1[0];
    }
}
```
