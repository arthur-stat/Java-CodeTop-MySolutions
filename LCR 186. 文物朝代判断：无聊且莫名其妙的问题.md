题目简述：

> 展览馆展出来自 13 个朝代的文物，每排展柜展出 5 个文物。某排文物的摆放情况记录于数组 `places`，其中 `places[i]` 表示处于第 `i` 位文物的所属朝代编号。其中，编号为 0 的朝代表示未知朝代。请判断并返回这排文物的所属朝代编号是否能够视为连续的五个朝代（如遇未知朝代可算作连续情况）。

题目链接：[LCR 186. 文物朝代判断](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

# 思路

很无聊的题目。排序然后考虑最大值与最小值，利用最大值与最小值的差判断编号是否连续，如果不连续允许用编号 0 尝试容错。

面向测试用例补全边界条件编程。

# 代码

```java
class Solution {
    public boolean checkDynasty(int[] places) {
        Arrays.sort(places);
        
        int countZeros;
        for (countZeros = 0; countZeros < 5; countZeros++) {
            if (places[countZeros] != 0) {
                break;
            }
        }

        if (countZeros == 5) return true;

        for (int i = countZeros; i < 4; i++) {
            if (places[i + 1] == places[i]) return false;
        }

        return 4 - (places[4] - places[countZeros]) <= countZeros && 4 - (places[4] - places[countZeros]) >= 0;
    }
}
```

实际上 `4 - (places[4] - places[countZeros]) <= countZeros && 4 - (places[4] - places[countZeros]) >= 0` 可以被进一步简化为 `places[4] - places[countZeros] <= 4`，但在推导中对应着不同的思考路径。