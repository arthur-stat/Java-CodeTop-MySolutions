题目简述：

> 珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。
>
> 珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 
>
> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
>
> 返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。

题目链接：[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

# 思路

就是说，`h` 固定时，让 `k` 尽可能小，要让以 `k - 1` 的吃香蕉速度珂珂都不能吃完所有的香蕉。

看，这不就是存在一个分割点让我们可以考虑二分查找吗？因为如果问题的解为 `k`，则以更快的速度 `k' > k` 吃香蕉珂珂是一定能吃完的，但她喜欢慢慢吃；而以更慢的速度 `k' < k` 吃香蕉珂珂就不能吃完所有的香蕉了，否则问题的解就不会是 `k`，而是比 `k` 更小的数。这里体现了单调性，因此可以应用二分查找算法。

我们可以设计一个函数 `boolean canEat(int k)` 表示以速度 `k` 吃香蕉时珂珂能不能在警卫回来前吃完所有香蕉，然后二分查找找到最小的使 `canEat` 返回 `true` 的 `k` 即可。

# 代码

算法的时间复杂度为 $O\big(n\log(\text{maxPile})\big)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int maxPile = 0;
        for (int pile : piles) maxPile = Math.max(maxPile, pile);

        int l = 1;
        int r = maxPile;
        while (l <= r) {
            int mid = l + (r - l) / 2;

            if (!canEat(piles, h, mid)) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        return l;
    }

    private boolean canEat(int[] piles, int h, int k) {
        long spend = 0;
        for (int pile : piles) {
            spend += (int) Math.ceil(1.0 * pile / k);
        }

        return spend <= h;
    }
}
```

