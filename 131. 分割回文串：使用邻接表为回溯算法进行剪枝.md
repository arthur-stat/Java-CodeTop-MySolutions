题目简述：

> 给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

题目链接：[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

# 思路

我已经替你试过了，暴力回溯将会超时（我在文末贴出来最初的超暴力回溯代码），所以必须考虑剪枝方案。

一个好的思路是考虑邻接表 `List<List<Integer>>`，邻接表 `List.get(i)` 定义为所有可能的以 `s.charAt(i)` 作为左端点的回文串的长度。

可以证明，该邻接表构成一张有向无环图（DAG），因此这一方案和标准动态规划有一定程度的相同。

为了逻辑上的简便，可以考虑中心拓展的方式构建这样的邻接表，然后再利用邻接表进行回溯算法即可，可以剪掉大部分不可能为解的分支。

# 代码

算法的最坏时间复杂度为 $O(n^2+n2^{n+1})$，空间复杂度为 $O(n^2)$，空间开销主要来自于邻接表。

```java
class Solution {

    int n;
    String s;
    List<List<Integer>> adj;
    Deque<String> path;
    List<List<String>> res;

    public List<List<String>> partition(String s) {
        this.s = s;
        n = s.length();
        adj = new ArrayList<>(n);
        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());

        // 奇数回文串构造邻接表
        for (int i = 0; i < n; i++) {
            for (int j = 0; i - j >= 0 && i + j < n; j++) {
                if (s.charAt(i - j) == s.charAt(i + j)) {
                    adj.get(i - j).add(1 + 2 * j);
                } else {
                    break;
                }
            }
        }

        // 偶数回文串构造邻接表
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; i - j >= 0 && i + j + 1 < n; j++) {
                if (s.charAt(i - j) == s.charAt(i + j + 1)) {
                    adj.get(i - j).add(2 * j + 2);
                } else {
                    break;
                }
            }
        }

        path = new ArrayDeque<>();
        res = new ArrayList<>();
        dfs(0);

        return res;
    }

    private void dfs(int i) {
        if (i == n) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int j : adj.get(i)) {
            path.addLast(s.substring(i, i + j));
            dfs(i + j);
            path.removeLast();
        }
    }
}
```

下面是最初版的实现，将会超时而无法 AC（嗯……引以为戒？）。

```java
class Solution {

    private String s;
    private int n;
    private Deque<String> path;
    private Set<List<String>> res;

    public List<List<String>> partition(String s) {
        this.s = s;
        n = s.length();
        path = new ArrayDeque<>();
        res = new HashSet<>();
        boolean[] used = new boolean[n];
        dfs(0, used, 0);
        List<List<String>> answer = new ArrayList<>();
        answer.addAll(res);
        return answer;
    }

    private void dfs(int i, boolean[] used, int usedCounter) {
        if (i == n) {
            if (usedCounter == n) res.add(new ArrayList<>(path));
            return;
        }

        int usedCounterCopy = usedCounter;

        for (int m = i; m < n; m++) {
            // case 1: 选择该元素，考虑奇数回文串
            used[m] = true;
            usedCounter++;
            path.addLast(String.valueOf(s.charAt(m)));
            dfs(m + 1, used, usedCounter);
            path.removeLast();

            int counter = 0;
            for (int j = 1; m - j >= 0 && m + j < n && s.charAt(m - j) == s.charAt(m + j) && !used[m - j] && !used[m + j]; j++) {
                used[m - j] = true;
                used[m + j] = true;
                usedCounter += 2;
                path.addLast(s.substring(m - j, m + j + 1));
                dfs(m + j + 1, used, usedCounter);
                path.removeLast();
                counter++;
            }
            for (int k = counter; k > 0; k--) {
                used[m - k] = false;
                used[m + k] = false;
            }
            usedCounter = usedCounterCopy;
            used[m] = false;

            // case 2: 选择该元素，考虑偶数回文串
            counter = -1;
            for (int j = 0; m - j >= 0 && m + j + 1 < n && s.charAt(m - j) == s.charAt(m + j + 1) && !used[m - j] && !used[m + j + 1]; j++) {
                used[m - j] = true;
                used[m + j + 1] = true;
                usedCounter += 2;
                path.addLast(s.substring(m - j, m + j + 2));
                dfs(m + j + 2, used, usedCounter);
                path.removeLast();
                counter++;
            }
            for (int k = counter; k >= 0; k--) {
                used[m - k] = false;
                used[m + k + 1] = false;
            }
            usedCounter = usedCounterCopy;

            // case 3: 不选择该元素
            dfs(m + 1, used, usedCounter);
        }
    }
}
```

