题目简述：

> 给定一系列的会议时间间隔 `intervals`，包括起始和结束时间 `[[s1,e1],[s2,e2],...] (si < ei)`，找到所需的最小的会议室数量。
>
> `(0,8), (8,10)` 在 `8` 这一时刻不冲突。

题目链接：[253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/)

LintCode 题目链接：[919 · 会议室 II](https://www.lintcode.com/problem/919/)

# 思路

> 本问题很像活动选择问题（activity-selection problem），在《Introduction to Algorithms》中作者以活动选择问题为例子用动态规划的方式解决了问题。作者也提到，这一问题也是一个典型的适合贪心算法解决的问题。
>
> 活动选择问题是典型的区间排序问题，而本问题显然也要进行区间排序，但除了进行区间排序外还需要额外的顺序最小值维护。

这是一个典型的区间排序问题。

首先将所有区间按左端点进行排序，然后使用一个优先队列（小顶堆）维护已访问区间的右端点。遍历按左端点排序后的区间，

- 若优先队列非空，检查当前区间左端点与优先队列中最小值的大小，

  1. 若当前区间左端点严格小于优先队列的最小值，意味着此时优先队列内的所有记录在案的区间右端点对应的会议在整个当前区间内都会持续召开，因此至少需要优先队列当前大小再加一间会议室才能确保当前区间会议召开时所有过去已开始的会议均能顺利继续召开；

  2. 若当前区间左端点大于或等于优先队列的最小值，则至少有一个过去曾召开的会议是能够在当前会议开始时结束的，于是优先队列出队一个元素，然后继续判断，直到回到第一种情况或优先队列为空，那么就能够得到当前区间对应的会议召开期间所需的最小会议室数量为优先队列大小再加一。

- 将当前区间的右端点加入至优先队列，继续访问下一个区间。

# 代码

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
/**
 * Definition of Interval:
 * public class Interval {
 *     int start, end;
 *     Interval(int start, int end) {
 *         this.start = start;
 *         this.end = end;
 *     }
 * }
 */

public class Solution {
    /**
     * @param intervals: an array of meeting time intervals
     * @return: the minimum number of conference rooms required
     */
    public int minMeetingRooms(List<Interval> intervals) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        intervals.sort((a, b) -> a.start - b.start);
        int minRoomsNum = 0;

        for (Interval interval : intervals) {
            while (!pq.isEmpty() && pq.peek() <= interval.start) {
                pq.poll();
            }

            minRoomsNum = Math.max(minRoomsNum, pq.size() + 1);
            pq.offer(interval.end);
        }

        return minRoomsNum;
    }
}
```

