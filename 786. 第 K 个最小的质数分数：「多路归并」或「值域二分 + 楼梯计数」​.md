题目简述：

> 给你一个按递增顺序排序的数组 `arr` 和一个整数 `k` 。数组 `arr` 由 `1` 和若干 **质数** 组成，且其中所有整数互不相同。
>
> 对于每对满足 `0 <= i < j < arr.length` 的 `i` 和 `j` ，可以得到分数 `arr[i] / arr[j]` 。
>
> 那么第 `k` 个最小的分数是多少呢? 以长度为 `2` 的整数数组返回你的答案, 这里 `answer[0] == arr[i]` 且 `answer[1] == arr[j]` 。
>
> **进阶：**你可以设计并实现时间复杂度小于 $O(n^2)$ 的算法解决此问题吗？

题目链接：[786. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)

# 若干姊妹问题

- [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)：多路归并
- [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)：多路归并，二分查找
- [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)：多路归并，值域二分 + 楼梯计数
- [786. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)：多路归并，值域二分 + 楼梯计数

# 模拟分数

## 思路

将所有可能的真分数加入到优先队列，然后不断出队，第 $k$ 次出队的分数即为所求的分数。

枚举所有可能的真分数需要 $O(n^2)$ 的时间复杂度代价，尽管效率较低，但在 `2 <= arr.length <= 1000` 的数据范围下是能够 AC 的。

该方案非常简单直接，但效率低下。

## 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
record Frac(int a, int b) implements Comparable<Frac> {
    @Override
    public int compareTo(Frac o) {
        return Integer.compare(this.a() * o.b(), o.a() * this.b());
    }
}

class Solution {
    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        int n = arr.length;
        PriorityQueue<Frac> pq = new PriorityQueue<>();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                pq.offer(new Frac(arr[j], arr[i]));
            }
        }

        for (int i = 0; i < k - 1; i++) {
            pq.poll();
        }
        Frac f = pq.poll();
        return new int[]{f.a(), f.b()};
    }
}
```

# 多路归并模拟分数

## 思路

本问题与 [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) 是比较相似的，都是***给定多个升序的数组，要求给出某种序定义下的第 $k$ 个数对***。

可以考虑多路归并以实现时间复杂度低于 $O(n^2)$ 的算法，与 [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) 中的操作一样的，首先固定 $i$ 为 $0$，将所有分数 $\forall j>0,\frac{arr[0]}{arr[j]}$ 加入到优先队列，然后每次从优先队列中令一个元素出队，假设出队数对为 $(i_0,j_0)$，那么我们就把 $(i_0+1,j_0)$ 新加入到优先队列，重复该过程，直到第 $k$ 次出队。

如果读者对多路归并不熟悉，建议先看看我为 [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) 撰写的题解，在那里对多路归并有比较详细的分析与论断。

## 代码

算法的时间复杂度为 $O(n+k\log n)$，空间复杂度为 $O(n)$。

```java
class Solution {

    private static int[] arr;

    private record Frac(int i, int j) implements Comparable<Frac> {
        @Override
        public int compareTo(Frac o) {
            return Integer.compare(arr[this.i()] * arr[o.j()], arr[o.i()] * arr[this.j()]);
        }
    }

    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        int n = arr.length;
        this.arr = arr;
        PriorityQueue<Frac> pq = new PriorityQueue<>();

        for (int i = 1; i < n; i++) {
            pq.offer(new Frac(0, i));
        }

        for (int i = 0; i < k - 1; i++) {
            Frac f = pq.poll();
            if (f.i() < n - 1) pq.offer(new Frac(f.i() + 1, f.j()));
        }

        Frac res = pq.poll();
        return new int[]{arr[res.i()], arr[res.j()]};
    }
}
```

# 值域二分 + 楼梯计数

## 思路

类似 [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 中的方案，可以考虑 “值域二分 + 楼梯计数”。

以 `[1,2,3,5,9]` 为例，我们将所有分数的组合按自然数分子与自然数分母编制为一张表，如下所示：
$$
\begin{array}{c|c|c|c|c|c|}
& 1 & 2 & 3 & 5 & 9\\\hline
1 & & \frac{1}{2} & \frac{1}{3} & \frac{1}{5} & \frac{1}{9}\\\hline
2 & &  & \frac{2}{3} & \frac{2}{5} & \frac{2}{9}\\\hline
3 & &  & & \frac{3}{5} & \frac{3}{9}\\\hline
5 & &  & & & \frac{5}{9}\\\hline
9 & &  & & & \\\hline
\end{array}
$$
可以看出，真分数实际上只存在于该表的右上角，构成主对角元均为 $0$ 的上三角矩阵。

而且，在该上三角矩阵中，存在下述规律——是不难证明的：

1. 同一行中，按列递减
2. 同一列中，按行递增

这实际上就与 [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 在本质上是相同的了：如果我们从右上角出发，可以认为向左与向下移动都会使值变得更大，这完全符合有序矩阵的定义，因此自然地想到「值域二分 + 楼梯计数」思路。

这里再简单说说 “值域二分 + 楼梯计数” 的具体实践。首先进行值域二分，选取一个值域中值 `mid`，沿 Z 字型、按楼梯状对表中小于 `mid` 的元素进行计数，一次计数的时间复杂度为 $O(n)$，然后我们按情况更新 `mid` 再继续二分搜索，直到某个 `mid` 值恰使得表中小于其的元素数量为 `k`，然后我们再找到该浮点数对应的分数即可。

## 代码

算法的时间复杂度为 $O\big(n\log(\frac{1}{\varepsilon})\big)$，空间复杂度为 $O(1)$。

这个代码有点不好写……

```java
class Solution {

    public static final double EPSILON = 1e-8;
    private int[] pair;

    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        pair = new int[2];
        double lo = 0;
        double hi = 1;
        int[] res = new int[2];

        while (Math.abs(hi - lo) > EPSILON) {
            double mid = lo + (hi - lo) / 2;
            int sta = count(arr, mid);
            if (sta < k) {
                lo = mid;
            } else {
                hi = mid;
                res[0] = pair[0];
                res[1] = pair[1];
            }
        }

        return res;
    }

    private int count(int[] arr, double mid) {
        int n = arr.length;
        int i = n - 2;
        int j = n - 1;
        int sta = 0;
        pair[0] = arr[0];
        pair[1] = arr[n - 1];

        while (i >= 0 && j >= 0) {
            double num = (double) arr[i] / arr[j];
            if (num > mid + EPSILON) {
                i--;
            } else {
                if (num > (double) pair[0] / pair[1]) {
                    pair[0] = arr[i];
                    pair[1] = arr[j];
                }

                sta += i + 1;
                if (j > i + 1) {
                    j--;
                } else {
                    i--;
                    j = i + 1;
                }
            }
        }

        return sta;
    }
}
```
