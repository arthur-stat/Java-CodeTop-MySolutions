题目简述：

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

题目连接：[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

# 思路

典型的动态规划问题。

比起 [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)，多了一个第一个房屋和最后一个房屋相邻的新条件。

最简单的做法是先考虑 [198. 打家劫舍](https://leetcode.cn/problems/house-robber/) 的情况，然后分三种情况讨论：

- 抢劫第一家，但不抢劫最后一家；
- 抢劫最后一家，但不抢劫第一家。

最后取三个子问题解的最大值作为全局解即可。这样时间复杂度为 $O(n)$，利用滚动数组可实现 $O(1)$ 空间复杂度。

实际上这不仅是很简单的做法，而且就是最优解。

---

先考虑 [198. 打家劫舍](https://leetcode.cn/problems/house-robber/) 的情景，设 $dp[i]$ 表示考虑前 $i+1$ 家抢劫可能时我们今晚能够偷窃到的最高金额，那么
$$
dp[i]=\max\big\{dp[i-1],\ \ dp[i-2]+\mathrm{nums}[i]\big\}
$$
初始化条件：
$$
dp[0]=\mathrm{nums}[0],\ \ dp[1]=\max\big\{\mathrm{nums}[0],\ \mathrm{nums}[1]\big\}
$$
记解为 $dp^{\ast}$，则 $dp^{\ast}=\max\limits_{i}dp[i]$。

---

排除掉第一家计算 $dp^{\ast}_{1}$，再排除掉最后一家计算 $dp^{\ast}_{2}$，该问题的全局最优解即为 $\max\{dp^{\ast}_{1},\ dp^{\ast}_{2}\}$。

# 代码

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        if (nums.length == 2) return Math.max(nums[0], nums[1]);
        int res = Math.max(dp(nums, 0, nums.length - 2), dp(nums, 1, nums.length - 1));
        return res;
    }

    private int dp(int[] nums, int start, int end) {
        int dp1 = nums[start];
        int dp2 = Math.max(nums[start], nums[start + 1]);

        for (int i = start + 2; i <= end; i++) {
            int tmp = dp2;
            dp2 = Math.max(dp2, dp1 + nums[i]);
            dp1 = tmp;
        }

        return dp2;
    }
}
```