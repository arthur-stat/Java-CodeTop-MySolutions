题目简述：

> 给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a^2 + b^2 = c` 。

题目链接：[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)

# 遍历平方数，再考虑两数之和

## 思路

这是最直白的思路，我们先遍历所有平方数，将平方数都添加至哈希表中以便高效查询其存在性，然后问题转化为两数之和，我们只需要判断针对一个平方数 `a^2`，是否存在另一个平方数等于 `c - a^2` 即可，即类似 [两数之和](https://leetcode.cn/problems/two-sum/description/) 的思路。

## 代码

算法的时间复杂度为 $O(\sqrt{c})$，空间复杂度为 $O(\sqrt{c})$。

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        Set<Integer> square = new HashSet<>();
        for (int i = 0; i <= (int) Math.floor(Math.sqrt(c)); i++) {
            square.add(i * i);
        }

        Iterator<Integer> it = square.iterator();
        while (it.hasNext()) {
            int val = it.next();
            if (square.contains(c - val)) return true;
        }

        return false;
    }
}
```

# 双指针

## 思路

整体思路不变，但可以用双指针优化算法以将空间复杂度降至 $O(1)$。

双指针算法成立的前提是存在某种单调性，在这里单调性就是二元函数 $f(a,b)=a^2+b^2$（$a,b\geqslant 0$）在固定其中一个值时，另一个值减小将使得函数值减小，另一个值增大将使得函数值增大。因此，初始化 $a=0$、$b=\lfloor\sqrt{c}\rfloor$，判断是否有 $a^2+b^2=c$，如果有则返回 `true`，否则如果过大就缩小 $b$，反之则增大 $a$，直到满足 $a^2+b^2=c$ 或 $a>b$。

## 代码

算法的时间复杂度仍为 $O(\sqrt{c})$，但空间复杂度为 $O(1)$。算法的时间常数因子也更小。

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        long a = 0;
        long b = (long) Math.floor(Math.sqrt(c));

        while (a <= b) {
            if (a * a + b * b == c) return true;
            else if (a * a + b * b > c) b--;
            else a++;
        }
        return false;
    }
}
```

