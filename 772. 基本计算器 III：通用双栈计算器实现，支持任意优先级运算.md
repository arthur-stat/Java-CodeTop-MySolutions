题目简述：

> 实现一个基本的计算器来计算一个简单的表达式字符串。
>
> 表达式字符串只包含**非负**整数、`+`, `-`, `*`, `/`操作符、左括号 `(`，右括号 `)`和空格。
>
> 您可以假设**给定的表达式总是有效的**。所有中间结果将在“[-2147483648,2147483647]”范围内。

题目链接：[772. 基本计算器 III](https://leetcode.cn/problems/basic-calculator-iii/description/)

LintCode 题目链接：[849 · 基础计算器 III](https://www.lintcode.com/problem/849/)

# 思路

双栈实现（数字栈 + 运算符栈）的关键在于为运算定义优先级***，如果当前操作符的优先级不高于运算符栈栈顶操作符的优先级（而不只是当前操作符优先级严格小于运算符栈栈顶操作符优先级时）***，则弹出运算符栈栈顶以及数字栈栈顶进行合并计算。而且***该操作必须是循环的，如果弹出栈顶后发现新栈顶依然满足条件，则继续执行***。如此便能够保证合并相同优先级的运算，并且自栈顶向下维护降序的运算优先级顺序。<u>这是一个相当重要的不变式</u>。

这样做的好处是，<u>对于最终结果式（也包括括号内的子式，见下文），我们可以保证其中相同优先级的运算符被合并且至多只有一个，同时结果表达式中运算符的优先级从左至右必然是升序的</u>，因此直接按照 LIFO 的顺序（从右至左，出栈）进行计算即可，而这天然就是栈的特性。

我们可以单独处理括号，因为括号较为特殊：当遇见左括号时只需要将左括号压栈，遇见右括号时则按 LIFO 的顺序出栈并计算，直到弹出左括号。之所以能按照 LIFO 顺序进行计算，也是因为我们可以确定括号内子式中相同优先级的运算已被合并，且自栈顶向下运算优先级越来越低。***这里要单独定义左括号的优先级为最低，可以将左括号视为一个屏障，这样才能保证同优先级运算符的合并与运算符栈栈顶高优先级运算符的优先计算不会跨越左括号进行，从而维护括号内子式与全局表达式的分割***。

<u>万分注意务必解耦合数字的转换计算与符号的处理，不要等遇见符号再结算数字，应对一旦发现数字立刻尝试匹配出整个数字，否则无法避免 `(((123)))` 重复压入 `0` 的问题。</u>

> 加粗与下划线的部分都是我血与泪的教训……花了几个小时后终于彻底明白。希望你可以避免这些易错点！

 # 代码

```java
public class Solution {
    /**
     * @param s: the expression string
     * @return: the answer
     */
    public int calculate(String s) {
        Deque<Integer> nums = new ArrayDeque<>();
        Deque<Character> ops = new ArrayDeque<>();
        int num = 0;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            if (c == ' ') continue;

            if (Character.isDigit(c)) {
                num = c - '0';
                while (i < s.length() - 1 && Character.isDigit(s.charAt(i + 1))) {
                    num = num * 10 + s.charAt(++i) - '0';
                }
                nums.push(num);
                num = 0;
            } else if (c == '(') {
                /* 单独处理括号，因为我们认为括号相对特殊 */
                ops.push('(');
            } else if (c == ')') {
                while (ops.peek() != '(') {
                    int b = nums.pop();
                    int a = nums.pop();
                    nums.push(cal(a, b, ops.pop()));
                }
                ops.pop();
            } else {
                while (!ops.isEmpty() && priotiry(ops.peek()) >= priotiry(c)) {
                    int b = nums.pop();
                    int a = nums.pop();
                    nums.push(cal(a, b, ops.pop()));
                }
                ops.push(c);
            }
        }
        while (!ops.isEmpty()) {
            int b = nums.pop();
            int a = nums.pop();
            nums.push(cal(a, b, ops.pop()));
        }

        return nums.pop();
    }

    public int cal(int a, int b, char op) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        throw new IllegalArgumentException();
    }

    public int priotiry(char op) {
        switch (op) {
            case '(': return 0;  // 作为屏障设为最低优先级，不允许任何运算符合并括号
            case ')': return 0;
            case '+': return 1;
            case '-': return 1;
            case '*': return 2;
            case '/': return 2;
        }
        throw new IllegalArgumentException();
    }
}
```

