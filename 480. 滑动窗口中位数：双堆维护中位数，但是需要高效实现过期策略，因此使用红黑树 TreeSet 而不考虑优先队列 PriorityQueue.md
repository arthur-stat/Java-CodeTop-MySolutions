题目简述：

> 中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。
>
> 例如：
>
> - `[2,3,4]`，中位数是 `3`
> - `[2,3]`，中位数是 `(2 + 3) / 2 = 2.5`
>
> 给你一个数组 *nums*，有一个长度为 *k* 的窗口从最左端滑动到最右端。窗口中有 *k* 个数，每次窗口向右移动 *1* 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

题目链接：[480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)

# 整体思路

双堆维护数据流的中位数，是优先队列 / 大小顶堆非常典型的应用之一。

在问题 [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) 中我们也有过细致的分析，只不过那里要求的是计算整个数据流的中位数，而这里则是要求计算数据流的滑动窗口内的中位数。并没有本质上的区别，只不过对于滑动窗口需要考虑如何实现使窗口外的数据在堆中过期的逻辑。

先实现双堆，将滑动窗口内的数据按数值大小划分为小于区 `less` 与大于区 `gter`，小于区内的每个数值都小于等于大于区内的任何数值。对小于区应用大顶堆数据结构，对大于区应用小顶对数据结构，这样，要么大顶堆 `less` 的最大值就是窗口的中位数，要么大顶堆 `less` 的最大值与小顶堆 `gter` 的最小值的平均值就是窗口的中位数——取决于窗口尺寸的奇偶。

为了实现滑动窗口内元素过期的逻辑，可以考虑包装元素在 `nums` 中的索引以及元素的值，然后按索引进行更新删除。

# PriorityQueue？

下面的代码就是按上述思路用优先队列实现的，但实际运行时面对一些数据量较大且刻意构造过单调性的数据将会超时！

归根结底是优先队列获取最大最小值的时间复杂度为 $O(1)$，插入新元素、删除堆顶元素的时间复杂度均为 $O(\log k)$，但在我们的过期策略实现下，需要删除一个指定的已过期元素，该元素很可能并不是堆顶，这时时间复杂度将来到 $O(k)$。最后，总的时间复杂度来到 $O(nk)$。当 $k$ 很大时，时间复杂度接近 $O(n^2)$。

```java
record Pair(int index, double val) {}

class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n - k < 0 || k < 1) return new double[0];
        if (k == 1) return Arrays.stream(nums).asDoubleStream().toArray();
        double[] res = new double[n - k + 1];

        PriorityQueue<Pair> less = new PriorityQueue<>((a, b) -> Double.compare(b.val(), a.val()));
        PriorityQueue<Pair> gter = new PriorityQueue<>((a, b) -> Double.compare(a.val(), b.val()));

        for (int i = 0; i < k; i++) less.offer(new Pair(i, nums[i]));
        for (int i = 0; i < k / 2; i++) gter.offer(less.poll());
        if (res.length >= 1) {
            res[0] = ((k & 1) == 1) ? less.peek().val() : (less.peek().val() + gter.peek().val()) / 2;
        }

        for (int i = k; i < n; i++) {
            Pair expired = new Pair(i - k, nums[i - k]);
            less.remove(expired);
            gter.remove(expired);

            if (!less.isEmpty() && nums[i] <= less.peek().val()) {
                less.offer(new Pair(i, nums[i]));
            } else {
                gter.offer(new Pair(i, nums[i]));
            }

            if ((k & 1) == 1) {
                while (less.size() > gter.size() + 1) {
                    gter.offer(less.poll());
                }
                while (less.size() < gter.size() + 1) {
                    less.offer(gter.poll());
                }
            } else {
                while (less.size() > gter.size()) {
                    gter.offer(less.poll());
                }
                while (less.size() < gter.size()) {
                    less.offer(gter.poll());
                }
            }

            res[i - k + 1] = ((k & 1) == 1) ? less.peek().val() : (less.peek().val() + gter.peek().val()) / 2;
        }

        return res;
    }
}
```

# TreeSet！

JDK 提供的 `TreeSet` 是基于红黑树的，是自平衡的 BST，因此 `TreeSet` 能够保证其内的数据有序，并且查询最大最小值的时间复杂度也为 $O(1)$、插入新元素与删除根节点的时间复杂度也为 $O(1)$，但不一样的是删除指定元素的时间复杂度仅为 $O(\log k)$。

- `PriorityQueue` 归根结底在逻辑上也是一棵二叉树，只不过利用了满二叉树层序遍历的性质，使用一个动态数组存储了所有内容，并没有显式的树节点。更重要的是，`PriorityQueue` 是大小顶堆的实现，并不保证全局有序，只确保我们能够以 $O(1)$ 的时间开销获取到最大值或最小值——这种特性允许我们在优先队列中存储重复元素，同时也减少了堆内存中对象寻址的开销，但却不支持我们高效地实现过期特定元素的策略；

- 而 `TreeSet` 则从代码层面上真正地实现了树的结构（显式 `Entry`），这是一棵真正的自平衡 BST，获取任何特定元素均只需要 $O(\log k)$ 的时间复杂度，其根本原因就是 `TreeSet` 维护了全局有序，因此可以利用 BST 的性质减治地寻找目标元素。

  要说明的是 `TreeSet` 并不总是在任何地方都优于优先队列或者说大小顶堆的。抛开 `TreeSet` 会真的在堆内存中建一棵树这点不谈，红黑树与优先队列最大的区别就是由于 BST 的性质要求，`TreeSet` 不可重复存储同一个值。这倒很符合其名字中的 `Set`。

改为 `TreeSet` 后，算法的时间复杂度降至 $O(n\log k)$，算法 AC。不计入输出的空间占用时，空间复杂度为 $O(k)$。

```java
record Pair(int index, double val) {}

class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n - k < 0 || k < 1) return new double[0];
        if (k == 1) return Arrays.stream(nums).asDoubleStream().toArray();
        double[] res = new double[n - k + 1];

        TreeSet<Pair> less = new TreeSet<>((a, b) -> {
            if (a.val() != b.val()) return Double.compare(b.val(), a.val());
            return Integer.compare(a.index(), b.index());
        });
        TreeSet<Pair> gter = new TreeSet<>((a, b) -> {
            if (a.val() != b.val()) return Double.compare(a.val(), b.val());
            return Integer.compare(a.index(), b.index());
        });

        for (int i = 0; i < k; i++) less.add(new Pair(i, nums[i]));
        for (int i = 0; i < k / 2; i++) gter.add(less.removeFirst());
        if (res.length >= 1) {
            res[0] = ((k & 1) == 1) ? less.first().val() : (less.first().val() + gter.first().val()) / 2;
        }

        for (int i = k; i < n; i++) {
            Pair expired = new Pair(i - k, nums[i - k]);
            if (!less.remove(expired)) gter.remove(expired);

            if (!less.isEmpty() && nums[i] <= less.first().val()) {
                less.add(new Pair(i, nums[i]));
            } else {
                gter.add(new Pair(i, nums[i]));
            }

            if ((k & 1) == 1) {
                while (less.size() > gter.size() + 1) {
                    gter.add(less.removeFirst());
                }
                while (less.size() < gter.size() + 1) {
                    less.add(gter.removeFirst());
                }
            } else {
                while (less.size() > gter.size()) {
                    gter.add(less.removeFirst());
                }
                while (less.size() < gter.size()) {
                    less.add(gter.removeFirst());
                }
            }

            res[i - k + 1] = ((k & 1) == 1) ? less.first().val() : (less.first().val() + gter.first().val()) / 2;
        }

        return res;
    }
}
```

