题目简述：

> 如果序列 `x1, x2, ..., xn` 满足下列条件，就说它是 *斐波那契式* 的：
>
> - `n >= 3`
> - 对于所有 `i + 2 <= n`，都有 `xi + xi+1 == xi+2`
>
> 给定一个 **严格递增** 的正整数数组形成序列 `arr` ，找到 `arr` 中最长的斐波那契式的子序列的长度。如果不存在，返回 `0` 。
>
> **子序列** 是通过从另一个序列 `arr` 中删除任意数量的元素（包括删除 0 个元素）得到的，同时不改变剩余元素顺序。例如，`[3, 5, 8]` 是 `[3, 4, 5, 6, 7, 8]` 的子序列。

题目链接：[873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)

# 思路

考虑动态规划，设 $dp[i][j]$ 表示以 $arr[i]$ 作为倒数第二个元素、以 $arr[j]$ 作为倒数第一个元素的最长斐波那契式序列的长度，则有状态转移方程
$$
dp[i][j]=dp[k][i]+1,\ \ \text{where }\ arr[k]=arr[j]-arr[i]
$$
上式利用了斐波那契式序列的性质：假设 $arr[k],arr[i],arr[j]$ 是某个斐波那契式序列中连续的三个元素，则一定满足 $arr[k]+arr[i]=arr[j]$，这能够推导出 $arr[k]=arr[j]-arr[i]$。

我们可以用哈希表存储已扫描元素的值到索引的映射，以便我们以 $O(1)$ 的时间复杂度找到满足 $arr[k]=arr[j]-arr[i]$ 的那个 $k$——题目保证了 `arr` 内的元素均为正数且严格递增，因此如果 $k$ 存在，那么必然是唯一的。

# 代码

算法的时间复杂度为 $\Theta(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int lenLongestFibSubseq(int[] arr) {
        int n = arr.length;
        Map<Integer, Integer> valToIndex = new HashMap<>();
        int[][] dp = new int[n][n];
        int res = 0;

        for (int j = 0; j < n; j++) {
            for (int i = 0; i < j; i++) {
                Integer k = valToIndex.get(arr[j] - arr[i]);
                if (k != null && k < i) {
                    dp[i][j] = dp[k][i] + 1;
                } else {
                    dp[i][j] = 2;
                }
                res = Math.max(res, dp[i][j]);
            }
            valToIndex.put(arr[j], j);
        }

        return (res == 2) ? 0 : res;
    }
}
```

# 剪枝

可以进一步减枝，因为题目保证 `arr` 是严格单调递增的，所以对于序列中连续的 $arr[k],arr[i],arr[j]$ 存在 $arr[k]<arr[i]<arr[j]$ 的大小关系，因此当 $i$ 足够小而导致 $2arr[i]<arr[j]$ 的时候，我们是无论如何也无法找到满足条件的 $k$ 使得 $arr[k]+arr[i]=arr[j]$ 成立的，这时对 $\forall k'<i$ 无论如何都成立 $arr[k']+arr[i]<arr[j]$，所以对这部分情况可以直接减枝。

虽然该剪枝不影响理论时间复杂度上限 $O(n^2)$，但却可以显著降低常数时间开销，因为减少了相当一部分针对不可能存在解情况的哈希查表操作。

```java
class Solution {
    public int lenLongestFibSubseq(int[] arr) {
        int n = arr.length;
        Map<Integer, Integer> valToIndex = new HashMap<>();
        int[][] dp = new int[n][n];
        int res = 0;

        for (int j = 0; j < n; j++) {
            for (int i = j - 1; i >= 0; i--) {
                if (2 * arr[i] < arr[j]) {  // 重要减枝！避免查哈希表的开销，仅做初始化
                    dp[i][j] = 2;
                } else {
                    Integer k = valToIndex.get(arr[j] - arr[i]);
                    if (k != null && k < i) {
                        dp[i][j] = dp[k][i] + 1;
                    } else {
                        dp[i][j] = 2;
                    }
                }

                res = Math.max(res, dp[i][j]);
            }
            valToIndex.put(arr[j], j);
        }

        return (res == 2) ? 0 : res;
    }
}
```

