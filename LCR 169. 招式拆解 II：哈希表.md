题目简述：

> 某套连招动作记作仅由小写字母组成的序列 `arr`，其中 `arr[i]` 第 `i` 个招式的名字。请返回第一个只出现一次的招式名称，如不存在请返回空格。

题目链接：[LCR 169. 招式拆解 II](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

# 双哈希表一次扫描

## 思路

用两个哈希表分别维护元素是否出现过一次以及是否出现过多次。

记两个哈希表分别为 `once` 与 `more`，其中 `once` 应为一个哈希映射以保存元素首次出现的索引，`more` 则只需要表示存在与否，对于扫描到的元素 `c`，

1. 如果 `once` 中不存在 key `c`，则插入 `c` 为 key 的记录，value 为 `c` 的索引 `i`；
2. 如果 `c` 作为 key 存在于 `once` 但在 `more` 中的值为 `false`（不存在），则置 `more` 值为 `true`；
3. 如果 `c` 作为 key 存在于 `once` 且在 `more` 中的值为 `true`（存在），那我们就不需要做出动作了，继续扫描下一个。

那么扫描结束时，

1. 如果在 `once` 的 key 中不存在该元素，则元素一次也没有出现；
2. 如果元素在 `once` 中作为 key 存在且在 `more` 中的值为 `false`，则元素仅出现过一次，并且首次出现索引为 value；
3. 如果元素在 `once` 中作为 key 存在但在 `more` 中的值为 `true`，则元素出现过多次。

这种实现适用于流式输入。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。如果不限定字符为小写拉丁字母，则空间复杂度为 $O(n)$。

```java
class Solution {
    public char dismantlingAction(String arr) {
        // 是否首次出现
        boolean[] once = new boolean[26];
        int[] map = new int[26];
        // 是否二次出现
        boolean[] more = new boolean[26];

        for (int i = 0; i < arr.length(); i++) {
            int index = arr.charAt(i) - 'a';
            if (!once[index]) {
                once[index] = true;
                map[index] = i;
            } else if (!more[index]) {
                more[index] = true;
            }
        }

        int min = Integer.MAX_VALUE;
        for (int i = 0; i < 26; i++) {
            if (once[i] && !more[i]) {
                min = Math.min(map[i], min);
            }
        }

        return min == Integer.MAX_VALUE ? ' ' : arr.charAt(min);
    }
}
```

# 单哈希表两次扫描

## 思路

两次扫描，第一次扫描时统计各字符出现的频次，第二次扫描时结合第一次扫描的频次统计，如果顺序扫描时发现有元素的频次为 1 则直接返回。

这种方式逻辑更简单（虽然本就根本不复杂），但不适用于流式输入。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。如果不限定字符为小写拉丁字母，则空间复杂度为 $O(n)$。

```java
class Solution {
    public char dismantlingAction(String arr) {
        int[] freq = new int[26];
        
        for (char c : arr.toCharArray()) {
            freq[c - 'a']++;
        }

        for (char c : arr.toCharArray()) {
            if (freq[c - 'a'] == 1) return c;
        }

        return ' ';
    }
}
```

