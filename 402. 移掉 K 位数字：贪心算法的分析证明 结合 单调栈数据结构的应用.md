题目简述：

> 给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

题目连接：[402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)

# 贪心策略的思路与证明

我们先来观察一些特例：

- num = 21324，k = 1，结果为 1324
- num = 21324，k = 2，结果为 124
- num = 21324，k = 3，结果为 12
- num = 1324，k = 1，结果为 124
- num = 1324，k = 2，结果为 12
- num = 124，k = 1，结果为 12

看起来该问题可能具有递归子问题的结构，假设 $f(x)$ 表示对 $x$ 移除一位数字后的最小数字，那么移除 $x$ 的 $k$ 位数字结果可能为 $f^k(x)$。如果的确如此，这比较符合贪心算法的特征，在每一步追求局部最优解，最终能够得到全局最优解。直觉上，似乎也的确如此。

---

我们首先讨论如何计算 $f(x)$。既然要固定抽走一位，怎么抽才能让结果数字最小呢？从特例看，显然不是简单地抽走数码最大或最小的位，也不是抽走最高位或最低位。遍历抽取再比较的话效率太低，我们需要找到一个合理的算法。

观察特例，有没有可能是抽走从高位起第一段单调递减数码的起始位呢？或者等价地说，抽走从高位起第一段单调递增数码区间的下一个数码。用量化的语言描述，则应该是从高位开始搜索，找到第一个满足 $a_i>a_{i+1}$ 的数码，然后移除第 $i$ 位。好像的确是这样，就算高位或次高位为 0 也能正确计算。可是如何证明呢？

我们可以分情况逐个讨论：对于数字 $x=a_1a_2\cdots a_n$，即 $x=\sum\limits^n_{k=1}a_k\cdot10^{n-k}$，假设

1. $\{a_1,a_2,a_3,\cdots,a_m\}$（$m<n$）单调递增且 $a_m>a_{m+1}$（这意味着 $a_m\neq0$），那么我们根据猜想我们应抽掉 $a_m$，抽走后结果为 $f(x)=a_1a_2\cdots a_{m-1}a_{m+1}\cdots a_n$。

   - 假设我们从 $\{a_1,a_2,a_3,\cdots,a_{m-1}\}$ 中抽走一位，不妨设抽走 $a_i$，抽走后结果为 $a_1a_2\cdots a_{i-1}a_{i+1}\cdots a_m\cdots a_n$，由于 $\{a_1,a_2,a_3,\cdots,a_m\}$ 单调递增，因此 $a_i\leqslant a_{i+1}$，而 $f(x)$ 的高 $i$ 位与 $a_1a_2\cdots a_{i-1}a_{i+1}\cdots a_m\cdots a_n$ 的高 $i-1$ 位完全相同，但 $f(x)$ 的高第 $i$ 位为 $a_i$，后者的高第 $i$ 位为 $a_{i+1}$，如果此时有 $a_i<a_{i+1}$ 则已经可以断言后者必然比 $f(x)$ 更大；若 $a_i=a_{i+1}$，则抽走 $a_i$ 与抽走 $a_{i+1}$ 是等价的，我们视为抽走 $a_{i+1}$，继续讨论是否有 $a_{i+1}=a_{i+2}$……这样，要么由于存在某个 $a_{i+j}< a_{i+j+1}$ 且 $i+j+1\leqslant m$ 使得我们可以断言抽走 $a_i$ 必然比 $f(x)$ 更大，要么有 $a_i=a_{i+1}=\cdots=a_m$。对于 $a_i=a_{i+1}=\cdots=a_m$ 的情况，抽走 $a_i$ 与抽走 $a_m$ 是等价的，因此抽走 $a_i$ 不可能比 $f(x)$ 更小——至多抽走 $a_i$ 与抽走 $a_m$ 等价。

   - 假设我们从 $\{a_{m+1},a_{m+2},\cdots,a_n\}$ 中抽走一位，不妨设抽走 $a_i$，抽走后结果为 $a_1a_2\cdots a_m\cdots a_{i-1}a_{i+1}\cdots a_n$，不难知道 $f(x)$ 的高 $m-1$ 位与 $a_1a_2\cdots a_m\cdots a_{i-1}a_{i+1}\cdots a_n$ 的高 $m-1$ 位完全相同，但 $f(x)$ 的第高 $m$ 位为 $a_{m+1}$，后者的高第 $m$ 位为 $a_m$，由于 $a_m>a_{m+1}$，因此后者必然比 $f(x)$ 更大。

   综上所述，只要这样的 $a_m$ 存在，那么 $f(x)$ 必然是抽走一位后的最小值，尽管可能抽走其他数位也有可能得到最小值，但该值绝不可能比 $f(x)$ 更小。

   如果 $a_m=a_1>a_2$，可以进一步断言 $f(x)$ 是唯一最小值，抽走任何其他数位都不可能获得最小值，这对应单调递增集合 $\{a_1,a_2,a_3,\cdots,a_m\}$ 为空集而只可能从 $\{a_{m+1},a_{m+2},\cdots,a_n\}$ 中抽走一位的情况。

   即使存在前导零也不影响结论，因为 $a_m\neq0$，因此前导零可以直接视为单调递增集合 $\{a_1,a_2,a_3,\cdots,a_m\}$ 中的元素。

2. 如果找不到这样的 $a_m$，说明 $\{a_1,a_2,a_3,\cdots,a_n\}$ 单调递增（这包括了所有数码全为零的情况），那么自然地，移除最低位就能够得到最小值。

---

现在我们已经证明了 $f(x)$ 局部最优并给出了 $f(x)$ 的计算方法，那么如何严谨证明 $f^k(x)$ 全局最优呢？可以考虑交换法，这一步我就不继续推导了，公式化、模板化地套用证明流程即可。以下是 gpt-4o 生成的最优子结构性质证明：

>假设贪心算法选择了某个元素 $a_i$ 放在当前位 $p$，而最优解选择了另一个元素 $a_j$。
>
>我们要做的就是比较：
>
>- 把 $a_i$ 放在位置 $p$、$a_j$ 放在位置 $q$
>- 与之相对的，把 $a_j$ 放在位置 $p$、$a_i$ 放在位置 $q$
>
>然后比较两个值的大小。只要能说明前者更优，就说明我们的选择更优。
>
>具体差值是：
>$$
>(a_i-a_j)(10^p-10^q)
>$$
>由于 $a_i\geqslant a_j$（单调递增），而且 $p<q$（更高位），可以推得：
>$$
>(a_i-a_j)(10^p-10^q)>0\Rightarrow a_i\text{ 在高位比 }a_j\text{ 更优}
>$$
>所以，贪心选择成立。

# 算法和数据结构

我们可以按照证明的思路，首先实现 $f(x)$ 函数，然后递归或流式调用 $k$ 次 $f(x)$ 函数，便能够得到最终结果。但我们最好是“一步到位”，一方面是出于算法性能的考虑，另一方面是在如 Java 等一些语言里输入的字符串是不可变数据，频繁新建字符串会带来很大的开销。要做到“一步到位”，我们可以对算法进行额外的设计，也可以使用数据结构简洁地实现。

---

也可以使用数据结构。观察我们此前的分析，$f(x)$ 相较于 $x$ 移除的是 $a_m$，而 $x$ 的前缀数码集 $\{a_1,a_2,a_3,\cdots,a_m\}$ 是单调递增的。也就是说，我们移除 $a_m$ 是为了尽可能使移除数位后 $x$ 的单调递增前缀数码集更大。自然地，可以想到使用单调栈维护这样一个单调不减的序列，直到单调栈弹出 $k$ 个数码便终止，或在未弹出 $k$ 个数码但扫描结束时移除低位以补足移除的数码数量。

不考虑数据结构是完全可行的，但为了做到“一步到位”的同时避免不必要的重复扫描（确保 $O(n)$ 的时间复杂度而非 $O(nk)$），这要求我们自行维护指针，而这可能会带来一点麻烦。举个例子：我们定义满足 $a_i>a_{i+1}$ 的 $a_i$ 为数字 $x$ 的一个*下降点*，对于输入 $x=124121$，求解 $f^3(x)$ 等价于寻找序列 [1, 2, 4, 1, 2, 1] 的 3 个顺序下降点。如果不使用单调栈，我们就需要在扫描到第一个下降点 4 时将指针回退至 2，然后对 4 “视而不见”、转而考察 2 与 4 的下一个数码 1 的关系，显然此时 2 也是一个下降点，于是我们要同时忽略 2、4 并将指针回退至 1，继续考察 1 和 4 的下一个数码 1 的关系——比起单调栈，这显然繁琐且冗余了。毕竟，使用单调栈的话，我们只需要不断让新的数码入栈就好了。

在 [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/) 中我们也使用了单调栈，目的是寻找下一个更大/更小元素，这里我们也可以使用单调栈，目的是维护一个单调序列。二者均为单调栈这一数据结构的最典型应用。

# 代码实现

```java
class Solution {

    private class MonoStack {
        private Deque<Character> stack;
        private int k;  // 应移除位数
        private int n;  // 已移除位数

        MonoStack(int k) {
            stack = new ArrayDeque<>();
            this.k = k;
            this.n = 0;
        }

        public void push(char i) {
            while (n < k && !stack.isEmpty() && i < stack.peek()) {
                stack.pop();
                n++;
            }

            stack.push(i);
        }

        public void finalizeRemoval() {
            while (n < k) {
                stack.pop();
                n++;
            }
        }

        public String buildResult(){
            trimLeadingZeros();
            StringBuilder res = new StringBuilder();
            for (char c : stack) {
                res.append(c); 
            }
            return res.reverse().toString();
        }

        private void trimLeadingZeros() {
            while (!stack.isEmpty() && stack.peekLast() == '0') {
                stack.removeLast();
            }

            if (stack.isEmpty()) {
                stack.addLast('0');
            }
        }
    }

    public String removeKdigits(String num, int k) {
        MonoStack monoStack = new MonoStack(k);
        for (int i = 0; i < num.length(); i++) {
            monoStack.push(num.charAt(i));
        }
        monoStack.finalizeRemoval();
        return monoStack.buildResult();
    }
}
```

