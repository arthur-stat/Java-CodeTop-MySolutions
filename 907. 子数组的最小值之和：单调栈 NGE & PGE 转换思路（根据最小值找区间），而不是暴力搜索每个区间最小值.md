题目简述：

> 给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。
>
> 由于答案可能很大，因此 **返回答案模 `10^9 + 7`** 。
>
> **提示：**
>
> - `1 <= arr.length <= 3 * 10^4`
> - `1 <= arr[i] <= 3 * 10^4`

题目链接：[907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

为什么是返回对 `10^9 + 7` 取模的结果呢？因为这是一个大质数，同理的还有 `10^9 + 9`。这两个数字在算法中还是比较常见的。

# 暴力解法（区间找最小值，超时）

## 思路

设 $dp[i][j]$ 表示 `arr[i]` 至 `arr[j]` 的最小值，其中 $i>j$，则
$$
dp[i][j]=\min\big\{dp[i][j-1],arr[j]\big\}
$$
初始化条件：
$$
\forall i,\ \ dp[i][i]=arr[i]
$$
则 `min(b)` 总和为所有 $dp[i][j]$ 相加，即遍历所有子数组寻找其最小值。

## 代码

该方案时间复杂度为 $O(n^2)$，在 `1 <= arr.length <= 3 * 10^4`、`1 <= arr[i] <= 3 * 10^4` 的数据范围下会超时。

 ```java
 class Solution {
 
     private static final long MOD = 1000000007L;
 
     public int sumSubarrayMins(int[] arr) {
         int n = arr.length;
         int[] dp = new int[n];
         long res = 0;
         /* 对于 int res，也可以利用模运算性质 (a + b) % m = ((a % m) + (b % m)) % m 避免溢出 */
 
         for (int i = 0; i < n; i++) {
             dp[i] = arr[i];
             res += arr[i];
             res %= MOD;
             for (int j = i + 1; j < n; j++) {
                 dp[j] = Math.min(dp[j - 1], arr[j]);
                 res += dp[j];
                 res %= MOD;
             }
         }
 
         return (int) res;
     }
 }
 ```

# 单调栈（最小值找区间）

## 思路

在暴力解法中我们遍历了所有子数组，这里蕴含了大量重复运算。实际上，通过从 “区间 → 最小值” 的旧思路转变为 “最小值 → 区间” 的新思路，借助 NGE / PGE 的算法，我们可以一次性得到多个区间（子数组）的最小值。

可以使用两个单调栈分别进行两次扫描，找出每个元素的上一个更小元素的索引与下一个更小元素的索引。不妨设 `arr[i]` 的上一个更小元素为 `arr[j]`、下一个更小元素为 `arr[k]`，那么所有区间 $(j,k)$ 上包含 `arr[i]` 的子区间的最小值均为 `arr[i]`——这样的区间一共有 $(i-j)\cdot(k-i)$ 个。

> 其实用一个单调栈扫描一次就可以了，因为计数的起点可选范围与终点可选范围被要求是半开半闭的，下文会着重分析原因。

由于有限长数组内的每个区间（子数组）内必然存在一个最小值，因此在考虑了每个数字作为区间最小值的可能后，我们就考虑到了所有的区间。

可以看出，如果我们考虑每一个区间（子数组）并通过每个区间寻找每个子数组最小值，由于一共有 $O(n^2)$ 个区间，因此即使我们维护了 DP 表、将对每个区间寻找最小值的时间开销降至 $O(1)$，算法的总时间复杂度依然来到 $O(n^2)$。但如果我们借助单调栈，通过值去寻找以该值作为最小值的区间（的个数），由于原数组中不同的值至多只有 $n$ 个，而单调栈又帮助我们以摊还 $O(1)$ 的时间代价得到以每个值作为最小值的区间（的个数），因此算法的时间复杂度降至线性复杂度。

## 为什么计数的起点可选范围与终点可选范围应当是半开半闭区间？

这是实现正确算法的关键因素：计数时，起点可选范围与终点可选范围区间必须是半开半闭的，否则无法正确处理重复值的情况。例如当 `nle` 数组语义为下一个严格更小元素的索引时，那么 `ple` 数组的语义就只能为上一个非严格更小元素的索引，不能让两个数组的语义都取严格更小或非严格更小，对应单纯开区间与单纯闭区间。

不妨看这样一个简单的例子：对于数组 `[1, 2, 1]`，如果我们考虑单纯开区间，即 `nle` 与 `ple` 的语义分别为下一个严格更小元素的索引与上一个严格更小元素的索引，那么两个数组的值分别为

- `nle`：`[3, 2, 3]`
- `ple`：`[-1, 0, -1]`

这样的话，数组中第一个 1与第二个 1 对应的 NLE 均为 `3`、PLE 均为 `-1`，于是我们就同时将第一个 1 认为是 `[1, 2, 1]` 的最小值、也将第二个 1 认为是 `[1, 2, 1]` 的最小值。尽管从数学定义上看的确如此——虽然一个区间只有一个最小值、可是最小值可能出现多次，但问题在于我们的算法是通过最小值去寻找区间的（而不是反过来，对区间找最小值），如果我们同时将第一个 1 与第三个 1 视为区间 `[1, 2, 1]` 的最小值，我们就会重复计数，造成结果比实际值更大。同理，如果考虑单纯闭区间，则得到的结果将比实际值更小。

正确的做法就是在计数时只让起点或终点中的一个考虑为严格相等、另一个考虑为非严格相等——具体是左开右闭还是右开左闭都无所谓，重点是这样才能确保正确地计数、不重不漏，这样才能保证对区间内包含重复最小值的子数组只进行一次计数。

也正因为区间应当是半开半闭的，所以不必使用两个单调栈扫描两次，只需要一次扫描即可。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {

    private static final long MOD = 1000000007L;

    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] nle = new int[n];
        Arrays.fill(nle, n);
        int[] ple = new int[n];
        Arrays.fill(ple, -1);

        int[] stack = new int[n];
        int top = -1;

        // NLE
        for (int i = 0; i < n; i++) {
            while (top > -1 && arr[i] <= arr[stack[top]]) {
                nle[stack[top--]] = i;
            }
            if (top > -1) ple[i] = stack[top];  // 替代显式反向扫描 PLE，因为区间应当是半开半闭的，一次扫描即可
            stack[++top] = i;
        }

        // // PLE
        // top = -1;
        // for (int i = n - 1; i >= 0; i--) {
        //     while (top > -1 && arr[i] < arr[stack[top]]) {
        //         ple[stack[top--]] = i;
        //     }
        //     stack[++top] = i;
        // }

        long res = 0;
        for (int i = 0; i < n; i++) {
            res += (long) arr[i] * (i - ple[i]) * (nle[i] - i);
            res %= MOD;
        }
        return (int) res;
    }
}
```

