题目简述：

> 给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

题目连接：[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

# BFS 层次拓展 + 贪心策略

## 思路

我第一反应是这可能是一个贪心算法问题。但是，在贪心策略的框架下，我们可以考虑 BFS 层次拓展的算法，这样不仅能做到 $O(n)$ 的时间复杂度，而且算法经过简单修改后便可以直接用来解决 [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)（添加一个层次 / 跳跃计数器）。有更加 “长得像” 贪心算法的实现，但我认为没有层次拓展直观，关键是无法直接用来直接解决 [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)，虽然他足够简单（只有一层循环），但不够灵活，因为没有显式的层次。

简单讲，我们通过维护 `minRange`、`maxRange` 以表达在一次跳跃中最多可达的区间，其中 `maxRange` 直接表示在当前情况下能到达的最远距离，而维护 `minRange` 的目的是为了不重复探索已处理的平凡元素——所谓不吃回头草。在下一次跳跃中，我们在 `minRange` 至 `maxRange` 的范围内的每一个元素上尝试一次跳跃，并更新在范围内经过一次跳跃后的 `minRange` 与 `maxRange`，于是递进到下一个层次。

这样，每个元素至多被处理一次，尽管算法的实现中看上去存在一个嵌套循环。BFS 层次遍历的层次便体现在第几次跳跃中。

## 代码

算法的空间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

 虽然存在嵌套循环，但 `minRange` 与 `maxRange` 的设计使得算法的内层循环对 `nums` 的每个元素只会进行一次处理。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int maxRange = nums[0];
        int minRange = 0;

        while (maxRange < n - 1 && maxRange != minRange) {
            int newMaxRange = maxRange;
            for (int i = minRange + 1; i <= maxRange; i++) {
                newMaxRange = Math.max(newMaxRange, nums[i] + i);
            }
            minRange = maxRange;
            maxRange = newMaxRange;
        }

        return maxRange >= n - 1 ? true : false;
    }
}
```

# 一层循环的贪心算法

# 思路

虽然这样设计的算法没那么灵活，只能用于解决本问题，但确实可以这样写，即隐含层次的贪心算法——区别于我们此前实现的 BFS 层次拓展算法。

只需要做一个工作：取消 `minRange` 与 `maxRange`  的显式层次设计，改用一个变量保存最大可达距离，然后在一个循环里遍历 `nums`。其核心思想是：在我们能跳到的范围内，一边走一边维护我当前能跳到的最远位置，如果最终能覆盖终点，则成功；如果最大可达位置已经落后于当前位置，则失败。

这样实现的算法只有一层非嵌套的循环，看上更简洁，但算法的性能与此前实现的 BFS 层次拓展算法是相同的，而且失去了层次计数的灵活性。

## 代码

算法的空间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
public boolean canJump(int[] nums) {
    int maxReach = 0;
    for (int i = 0; i <= maxReach; i++) {
        maxReach = Math.max(maxReach, i + nums[i]);
        if (maxReach >= nums.length - 1) return true;
    }
    return false;
}
```

