题目简述：

> 序列化二叉树的一种方法是使用 **前序遍历** 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。
>
> ```
>        9
>       / \
>      3   2
>    / \   \
> 4   1   6
> ```
>
> 例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。
>
> 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。
>
> **保证** 每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。
>
> 你可以认为输入格式总是有效的
>
> - 例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。
>
> **注意：**不允许重建树。

题目链接：[331. 验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)

# 在序列化结果上模拟先序遍历

## 思路

这个方法很直观，按照先序遍历的逻辑尝试在先序遍历序列化结果上进行 DFS，如果最后我们能够恰访问到所有的节点，那么树就是合法的，否则树不合法。

> 只要先序遍历过程中记录了所有非空节点的子节点（但不记录空节点的子节点），即使子节点是空节点，那么按先序遍历顺序序列化后就能够唯一地确认一棵合法的二叉树，即我们能够唯一地反序列化出原二叉树。

具体而言，按照先序遍历的『中 → 左 → 右』顺序，逻辑上一个节点在序列化结果中的下一个节点必然是其左子节点，由于在该序列化方案下记录了所有非空节点的非空子节点与空子节点，因此我们可以肯定对于序列化索引 $i$ 对应的节点，序列化索引 $i+1$ 就是其左子节点。于是按照『中 → 左 → 右』的顺序，我们可以通过左子节点先递归地搜索当前节点的左子树。

那么如何找到节点 $i$ 的右子节点并进而搜索右子树呢？我们只需要递归地让 DFS 返回以该节点作为根的子树所包含的节点数量，那么在遍历了『左』以后，DFS 的递归调用将返回当前节点的左子树内节点数量 $l$，按照『中 → 左 → 右』的整体顺序，我们可以肯定 $i+l+1$ 就是其右子节点的索引，进而可以遍历『右』，记录递归调用返回的当前节点的右子树内节点数量为 $r$。最后，为了使递归调用的返回值符合我们此前所期望的实际意义，在遍历了左右子树后返回 $l+r+1$ 即可，表示以当前节点作为根的子树内全部节点的数量。

该方法需要进行两个特判，因为例如序列化结果 `[1, #]` 是非法的，因为没有记录全部非空节点的右子节点，就算右子节点为空节点也应该序列化为 `[1, #, #]`，但在控制不产生数组索引越界的情况下 DFS 的先序遍历是无法感知这一点的。两个特判具体为：

1. 特判 $n=1$ 时只允许根节点为 `#`，否则根节点是非空节点，$n$ 至少应为 $3$；
1. 特判 $n\geqslant2$ 时序列化的最后两个节点必须是空节点。

其实也可以考虑 `goto`、抛出异常并捕获等非局部流程控制，或者将索引是否越界与子树尺寸一起封装到递归调用的返回值中，让上层调用发现索引越界后立即终止探索、返回 `false`，这样不仅不需要特判，还能进行剪枝——但这几种实现方式的代码可读性都比较差，因此这里没有考虑这样的实现。

这种方案稍加改动就能直接反序列化出原本的树。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(\log n)$。

```java
class Solution {

    private String[] pre;
    private boolean[] visited;
    private int n;

    public boolean isValidSerialization(String preorder) {
        pre = preorder.split(",");
        n = pre.length;
        if (n == 1) return pre[0].equals("#");
        if (n >= 2 && !pre[n - 1].equals("#") || !pre[n - 2].equals("#")) return false;
        visited = new boolean[n];
        dfs(0);
        for (boolean v : visited) if (!v) return false;
        return true;
    }

    // 返回子树内所有节点的数量，包括非空子节点的空子节点
    private int dfs(int i) {
        if (i >= n) return 0;
        visited[i] = true;

        if (pre[i].equals("#")) return 1;

        // left subtree size
        int l = dfs(i + 1);

        // right subtree size
        int r = dfs(i + l + 1);

        return l + r + 1;
    }
}
```

# 图论

## 思路

任何树（包括多叉树）的所有节点总入度应等于所有节点总出度，例如

```
    9 (入度 0, 出度 2)
   / \
  3   2 (节点3: 入度 1, 出度 2)
 / \    (节点2: 入度 1, 出度 0)
4   1
(节点4: 入度 1, 出度 0)
(节点1: 入度 1, 出度 0)
```

因此可以遍历一次序列化结果，统计所有节点的入度与出度，通过总入度与总出度是否相同判断树的序列化结果是否合法。

该方法虽然不能在遍历的同时反序列化树，但其优点是不再需要区分节点与左右子树的节点，并且可以利用任何时候出度都不能大于入度这一点进行提前减枝。具体做法是：

- 扫描到新节点时，先令总入度加 $1$；
- 如果该节点是非空子节点，再总出度加 $2$；
- 出度在任何时候都不能大于入度，如果出现这种情况，可以肯定该序列化结果是非法的。

注意要特别处理根子节点，根子节点的入度为 $0$，不提供任何入度。

## 代码

```java
class Solution {
    public boolean isValidSerialization(String preorder) {
        String[] pre = preorder.split(",");
        int n = pre.length;

        int outDegree = 0;
        int inDegree = -1;

        for (String val : pre) {
            inDegree++;
            if (inDegree > outDegree) return false;

            if (!val.equals("#")) outDegree += 2;
        }

        return inDegree == outDegree;
    }
}
```

