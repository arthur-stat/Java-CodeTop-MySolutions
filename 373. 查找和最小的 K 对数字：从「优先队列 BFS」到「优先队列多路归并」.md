题目简述：

> 给定两个以 **非递减顺序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。
>
> 定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。
>
> 请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。

题目链接：[373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

# 若干姊妹问题

- [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)：多路归并
- [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)：多路归并，二分查找
- [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)：多路归并，值域二分 + 楼梯计数
- [786. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)：多路归并，值域二分 + 楼梯计数

# 去重优先队列 BFS

## 思路

对于单调递增的两个数组 `nums1` 和 `nums2`，不难知道对于 $nums1[i],nums2[j]$，必然有
$$
\forall k>0,\ \ nums1[i+k]+nums2[j]\geqslant nums1[i]+nums2[j]
$$

$$
\forall k>0,\ \ nums1[i]+nums2[j+k]\geqslant nums1[i]+nums2[j]
$$

$$
\forall k>0,\ \ nums1[i-k]+nums2[j]\leqslant nums1[i]+nums2[j]
$$

$$
\forall k>0,\ \ nums1[i]+nums2[j-k]\leqslant nums1[i]+nums2[j]
$$

从以上四式可以导出在 $i'\geqslant i$、$j'\geqslant j$ 且 $i'+j'>i+j$ 的限制下，最小的那个大于 $nums1[i]+nums2[j]$ 的数对和要么是 $nums1[i+1]+nums2[j]$，要么是 $nums1[i]+nums2[j+1]$。

因此，我们可以从 $i=0,j=0$ 开始，每次从优先队列中取出和最小的数对 $(i_0,j_0)$ 并将其加入至结果集，然后将新的数对 $(i_0+1,j_0)$ 与 $(i_0,j_0+1)$ 都压入优先队列中，循环往复。

这里有一个问题，数对可能是重复的，例如 $i_0=1,j_0=0$ 会产生新的后继数对 $i=1,j=1$，而 $i_0=0,j_0=1$ 也会产生新的后继数对 $i=1,j=1$。最简单的去重方案当然就是使用哈希表进行去重。

实际上这是一种实现去重的广度优先遍历，你是否有看出来这其中蕴含着 Dijkstra BFS 的框架呢？

## 代码

算法的时间复杂度为 $O(k\log k)$，空间复杂度为 $O(k)$。

如果将 `Set<Long>` 改为 `boolean[][] visited`，算法的实际性能表现会更佳。

```java
record Pair(int i, int j, int sum) {}

class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> res = new ArrayList<>(k);
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Integer.compare(a.sum(), b.sum()));
        Set<Long> set = new HashSet<>();
        pq.offer(new Pair(0, 0, nums1[0] + nums2[0]));
        set.add(0L);

        int m = nums1.length;
        int n = nums2.length;

        for (int x = 0; x < k; x++) {
            Pair p = pq.poll();
            int i = p.i();
            int j = p.j();
            res.add(List.of(nums1[i], nums2[j]));

            if (i < m - 1 && !set.contains(zip(i + 1, j))) {
                pq.offer(new Pair(i + 1, j, nums1[i + 1] + nums2[j]));
                set.add(zip(i + 1, j));
            }
            if (j < n - 1 && !set.contains(zip(i, j + 1))) {
                pq.offer(new Pair(i, j + 1, nums1[i] + nums2[j + 1]));
                set.add(zip(i, j + 1));
            }
        }

        return res;
    }

    private long zip(int x, int y) {
        return ((long) x << 32) | (y & 0xffffffffL);
    }
}
```

# 优先队列多路合并

## 思路

该方案与「去重优先队列 BFS」是没有本质区别的，但是用更巧妙的办法实现了去重，不再需要去重哈希表。

我们首先将索引对 $(0,0),(1,0),(2,0),\cdots,(m-1,0)$ 都加入到优先队列中，然后进行「去重优先队列 BFS」中的流程，但不一样的是：对于出队的数对 $(i,j)$，不再需要将 $(i+1,j)$ 与 $(i,j+1)$ 都加入到优先队列中，我们只需要让 $(i,j+1)$ 加入到队列即可。在这一方案下，我们不需要额外的去重的逻辑，天然就保证了结果的唯一性，因为我们永远也只会让其中一个进入优先队列，优先队列中新元素的来源是单调且唯一的。例如，在原本的方案中，$(i_0,j_0)$ 有两个来源，要么作为 $(i_0-1,j_0)$ 的后继数对、要么作为 $(i_0,j_0-1)$ 的后继数对，现在我们强制 $(i_0,j_0)$ 只视为 $(i_0,j_0-1)$ 的后继数对，于是任何情况下 $(i_0,j_0)$ 都只有一个来源，自然也就不会再产生重复计数。

那为什么不需要再将 $(i+1,j)$ 加入到优先队列呢？不是说最小的大于 $nums1[i]+nums2[j]$ 的后继数对和可能是 $nums1[i+1]+nums2[j]$、也可能是 $nums1[i]+nums2[j+1]$ 吗？

是的，$nums1[i+1]+nums2[j]$ 的确可能比 $nums1[i]+nums2[j+1]$ 更小，但我们可以保证如果是这种情况的话，数对 $(i+1,j)$ 会比 $(i,j+1)$ 更先进入优先队列。如果 $nums1[i+1]+nums2[j]<nums1[i]+nums2[j+1]$，那么优先队列在接收 $(i,j+1)$ 并让其出队前必然会先从 $(i+1,0)$ 出发并一步步地先让 $(i+1,j)$ 出队。

一句话总结：我们只是让每个「起点」（即 $(i_0,0)$）出发探索的路径唯一了（原本只有 $(0,0)$ 这一个「起点」，但路径不唯一），但因为我们在确保了分支路径唯一的情况下已经事先将所有可能的「起点」都纳入到了优先队列中，于是新方案依然能够覆盖所有的全部情况，故从优先队列中出队的元素必然是剩余数对和中全局最小的，这有些多路归并的意味。

## 代码

算法的时间复杂度为 $O(k\log k)$，空间复杂度为 $O(k)$。

```java
record Pair(int i, int j, int sum) {}

class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> res = new ArrayList<>(k);
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Integer.compare(a.sum(), b.sum()));
        int m = nums1.length;
        int n = nums2.length;
        for (int i = 0; i < m; i++) pq.offer(new Pair(i, 0, nums1[i] + nums2[0]));

        for (int x = 0; x < k; x++) {
            Pair p = pq.poll();
            int i = p.i();
            int j = p.j();
            res.add(List.of(nums1[i], nums2[j]));

            if (j < n - 1) pq.offer(new Pair(i, j + 1, nums1[i] + nums2[j + 1]));
        }

        return res;
    }
}
```

# 二分查找

## 思路

这是个不一样的视角，是个有趣的思路，在此仅作记录，参考自 [【宫水三叶】详解「多路归并」&「二分」两种思路](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/1209848/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5/)。

> 我们还能够使用多次「二分」来做。
>
> 假设我们将所有「数对和」按照升序排序，两端的值分别为 $l=nums1[0]+nums2[0]$ 和 $r=nums1[n−1]+nums2[m−1]$。
>
> 因此我们可以在值域 $[l,r]$ 上进行二分，找到第一个满足「点对和小于等于 $x$ 的，且数量超过 $k$ 的值 $x$」。
>
> 之所以能够二分，是因为 $x$ 所在的点对和数轴上具有***二段性***：
>
> - 点对和小于 $x$ 的点对数量少于 $k$ 个；
>
> - 点对和大于等于 $x$ 的点对数量大于等于 $k$ 个。

其实我认为把他说的「二段性」改为「单调性」更合适，只不过值域中只有两个值而已。
