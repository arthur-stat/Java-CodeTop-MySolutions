题目简述：

> 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。
>
> - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
>
> 请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

题目连接：[207. 课程表](https://leetcode.cn/problems/course-schedule/)

# 分析

如果课程 $A$ 是另一个课程 $B$ 的先修课程，那么我们称 $B$ 依赖于 $A$。在这一定义下，课程间的依赖关系构成有向图。显然，我们能否修完所有课程，等价于有向图是否为无环有向图（DAG）。

因此，本问题实际上就是一个纯粹的拓扑排序 / 循环依赖检验问题。

最简单的方案是从每个节点出发进行 DFS，如果遍历到已访问且未完成回溯的节点则认为存在环。这一方法比较直观，但是开销较大，是比较暴力的算法。

对于这类问题，推荐基于入度的 Kahn 拓扑排序算法，也称为基于 BFS 的拓扑排序算法。

# 入度与 Kahn 拓扑排序

> 基于 BFS 的拓扑排序算法

入度（in-degree）：在一个有向图中，一个节点的入度是 “指向它的边的数量”。

如果一个节点的入度为 $0$，意味着该节点没有任何依赖，因此它可以作为拓扑排序下的起点。

Kahn 算法非常自然：首先统计所有节点的入度，将所有已知的入度为 $0$ 的节点加入队列。依次从队列中取出节点，并且在每取出一个节点时，移除未入队列节点对该节点的依赖——相对于移除该节点的边，然后更新剩余未入队列节点的入度，如果更新后存在新的入度为 $0$ 的节点，则将其也加入队列。不断重复操作，直到不剩下任何节点，或者剩余节点入度均不为 $0$。前者对应 DAG，后者对应存在环路。

Kahn 算法是一种拓扑排序算法，环路检测仅是其 “附赠品”，相比之下 DFS 则无法给出拓扑序：拓扑序即为节点从队列中取出的顺序。

# 邻接表

要高效率地更新入度表，邻接表（adjacency list）是必不可少的。

邻接表是图的标准表示方法，在这里可以帮助我们以常量时间复杂度更新入度表，而不必每一次都重新构建新的入度表。邻接表可以用 `Map<Integer, List<Integer>>` 或 `List<List<Integer>>` 表示，邻接表直接存储了针对某一节点有哪些节点依赖该节点。

# 「课程表」代码实现

对于该问题而言，判断 `numCourses` 是否等于可达节点数量即可。算法结束时，队列中的节点即为可达节点。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] inDegree = new int[numCourses];
        Map<Integer, List<Integer>> adj = new HashMap<>();

        // 构建邻接表和入度表
        for (int[] pre : prerequisites) {
            int course = pre[0], prereq = pre[1];
            inDegree[course]++;
            adj.computeIfAbsent(prereq, k -> new ArrayList<>()).add(course);
        }

        // 初始化队列，加入所有入度为 0 的课程
        Deque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) queue.offer(i);
        }

        int finishedCourses = 0;

        // 拓扑排序
        while (!queue.isEmpty()) {
            int course = queue.poll();
            finishedCourses++;

            List<Integer> nextCourses = adj.getOrDefault(course, Collections.emptyList());
            for (int next : nextCourses) {
                inDegree[next]--;
                if (inDegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }

        return finishedCourses == numCourses;
    }
}
```

