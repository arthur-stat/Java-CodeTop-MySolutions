题目简述：

> 给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
>
> **提示：**
>
> - `0 <= s.length <= 5 * 10^4`
> - `s` 仅由小写英文字母组成

题目链接：[214. 最短回文串](https://leetcode.cn/problems/shortest-palindrome/)

# 难点一：转换问题

本问题是求最长前缀回文子串长度的等价问题。

想想，设原字符串 `s` 长 `n`，如果我们知道最长前缀回文子串的长度为 `m`，那么只需要为尾部的 `n - m` 个字符在字符串首部补齐相应的 `n - m` 个字符，这样就能得到补充后的最短回文串。需要补齐的字符不可能少于 `n - m`，否则这意味着存在一个长度大于 `m` 的前缀回文子串，这存在矛盾。

因此，本问题实际上是最长前缀回文子串长度的等价问题，务必要看透这一点。

# 难点二：如何高效计算最长前缀回文子串

可以考虑 DP 或中心扩展寻找以 `s[0]` 起始的最长回文子串，但这显然不是一个好办法，时间复杂度将来到 $O(n^2)$。本问题的数据范围为 `0 <= s.length <= 5 * 10^4`，该时间复杂度很可能导致超时。

我们应该针对前缀回文子串的特点设计一个新的 $O(n)$ 时间复杂度方案。

比较常见的解决方案有字符串哈希与 LPS-based 的算法。也可以考虑 Manacher 算法，算法效率也不错，但我不认为针对本问题这是一个优雅的方案。

# 解决方案一：字符串哈希

关于字符串哈希的具体理论及实现细节请参见我为问题 [1044. 最长重复子串](https://leetcode.cn/problems/longest-duplicate-substring/) 撰写的题解，这里给出主要思路。

回文串有一个基本的定义，就是他的**正向扫描得到的字符串与逆向扫描得到的字符串结果应是相等**的。从该定义角度出发研究回文串的最大好处是我们不必再区分奇数长度回文串与偶数长度回文串，这与 Manacher 算法有相似之处。

由于本问题中我们实际上需要讨论的是最长前缀回文子串，因此我们可以确定可能的最长前缀回文子串必然以 `s[0]` 开头（前缀子串必须以 `s[0]` 起始），那么我们就可以肯定对于一个长度为 `m` 的前缀子串，他是一个回文串当且仅当 `s[:m] == s[:m][::-1]` 成立。

所以，我们可以分别取长度为 `m` 的前缀子串正向扫描与逆向扫描的哈希值进行对比，如果相等则认为我们找到了一个前缀回文子串。

对于字符串 `s[:m]`（顺序），我们考虑其哈希值为
$$
H_m=(a_1B^{m-1}+a_2B^{m-2}+\cdots+a_{m}B^0)\mod{M}
$$
对于字符串 `s[:m][::-1]`（逆序），我们考虑其哈希值为
$$
H'_m=(a_1B^0+a_2B^1+\cdots+a_{m}B^{m-1})\mod{M}
$$
如果 $H_m=H'_m$，则我们认为 `s[:m]` 是一个前缀回文子串。

不难知道，
$$
H_{m+1}=(H_m\times B+a_{m+1})\mod{M}
$$

$$
H'_{m+1}=(H'_m+a_{m+1}\times B^{m})\mod{M}
$$

上式也被称为 rolling hash。

因此，我们完全可以只进行一遍扫描就得到结果，各前缀串正序与反序的哈希值是可以在一遍扫描中就递进地构建起来的。

由于每次我们都能得到更大长度的前缀字符串正序哈希值与反序哈希值，我们可以立即进行比对，所以本问题中我们不必存储所有哈希值，可以用滚动数组的方式降低空间开销。

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$（不计入因 Java 字符串对象不可变带来的反转字符串必须 new 新字符串对象的空间开销）。

```java
class Solution {

    private static final Random rand = new Random("SAKI".hashCode());
    public static final long M1 = (long) 1e9 + 7;
    public static final long M2 = (long) 1e9 + 9;
    public static final long B1 = rand.nextLong(2, M1);
    public static final long B2 = rand.nextLong(2, M2);

    public String shortestPalindrome(String s) {
        int n = s.length();
        long forwardHash_1 = 0;
        long forwardHash_2 = 0;
        long reverseHash_1 = 0;
        long reverseHash_2 = 0;

        int validLen = 0;
        long powB1 = 1;
        long powB2 = 1;

        for (int len = 1; len <= n; len++) {
            int c = s.charAt(len - 1) - 'a';
            forwardHash_1 = (forwardHash_1 * B1 + c) % M1;
            forwardHash_2 = (forwardHash_2 * B2 + c) % M2;
            reverseHash_1 = (reverseHash_1 + c * powB1) % M1;
            reverseHash_2 = (reverseHash_2 + c * powB2) % M2;

            powB1 = (powB1 * B1) % M1;
            powB2 = (powB2 * B2) % M2;

            if (forwardHash_1 == reverseHash_1 && forwardHash_2 == reverseHash_2) {
                validLen = Math.max(validLen, len);
            }
        }

        return reverseSubstring(s, validLen, n) + s;
    }

    private String reverseSubstring(String s, int start, int end) {
        StringBuilder res = new StringBuilder(s.substring(start, end));
        return res.reverse().toString();
    }
}
```

# 解决方案二：LPS

>  LPS（longest prefix suffix），最长相同前后缀，在 KMP 算法中各前缀串的 LPS 长度也被称为 `next` 数组。

字符串哈希的方案之所以高效，是因为从回文串的定义入手避免了讨论奇偶长度回文串的麻烦。我们利用 LPS 同样可以做到这一点。

实际上，在字符串哈希的方案中，我们的目的就是快速判断前缀子串是否是回文串，即他的正序扫描串与逆序扫描串是否相同，只不过是利用哈希值进行相等性判断的。记 `s` 的逆序串为 `ss`，可以考虑 `s + '#' + ss`，那么 `s + '#' + ss` 的前缀子串就是 `s` 前缀子串的正向扫描串，`s + '#' + ss` 的后缀子串就是 `s` 前缀子串的逆向扫描串。所以，我们只需要寻找 `s + '#' + ss` 的最长公共前后缀就可以了，`s + '#' + ss` 的最长公共前后缀就是 `s` 的最长前缀回文串，而 `s + '#' + ss` 的最长公共前后缀就是 `next` 数组的最后一个元素表示的 LPS。

这里像 Manacher 算法一样插入 `#` 是为了阻断 `s` 与 `ss`，否则 LPS 可能大于 `s` 的长度——我们并不希望前后缀逾越所处的

等价但更抽象地，可以将 `s` 作为模式、将 `s` 的逆序字符串 `ss` 作为目标字符串，计算其 LPS 的长度，该长度即为 `s` 的最长前缀回文子串长度。

进一步的理解可以参考题解 [「手画图解」从简单的暴力法想到 KMP](https://leetcode.cn/problems/shortest-palindrome/solutions/392676/shou-hua-tu-jie-cong-jian-dan-de-bao-li-fa-xiang-d/) 的分析。

算法的时间复杂度与空间复杂度均为 $O(n)$。

```java
class Solution {
    public String shortestPalindrome(String s) {
        int n = s.length();
        String t = s + '#' + reverseSubstring(s, 0, n);
        int m = t.length();

        int[] lps = new int[m];
        // lps[0] = 0;
        int len = 0;
        for (int i = 1; i < m; ) {
            if (t.charAt(i) == t.charAt(len)) {
                len++;;
                lps[i] = len;
                i++;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }

        return reverseSubstring(s, lps[m - 1], n) + s;
    }

    private String reverseSubstring(String s, int start, int end) {
        StringBuilder res = new StringBuilder(s.substring(start, end));
        return res.reverse().toString();
    }
}
```
