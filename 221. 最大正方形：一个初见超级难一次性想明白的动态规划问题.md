题目简述：

> 在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

题目连接：[221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

# 我的思考过程

这个问题初见真的很难很难想出来状态转移，主要是不知道正确的状态定义是什么。如果一开始状态就没定义正确，那么很容易陷进思考半天白忙活的处境。

虽然初见时我一眼就看出来这很可能是个动态规划问题，但想了半天也没想出来状态转移是什么。

最开始我定义 $dp[i][j]$ 为 $(i+1)\times(j+1)$ 范围内的二维矩阵中只包含 `'1'` 的最大正方形面积，根本想不出来合适的状态转移，只能想到时间复杂度 $O(mn\min\{m^2,n^2\})$ 的暴力解法。按这样的状态定义，$dp[i][j]=dp[i-1][j-1]$ 或 $dp[i][j]=dp[i-1][j-1]+1$，但我始终想不出来什么时候加 $1$、什么时候不加 $1$。

想了十分钟没思路，选择与自己和解，瞟了一眼题解的一小部分，发现我状态定义都不合理，比较合适的状态是定义 $dp[i][j]$ 为以矩阵中第 $i+1$ 行、第 $j+1$ 列元素为最后一个主对角元的只包含 `'1'` 最大正方形的边长（或面积）。

仔细一想，的确这样定义状态更合理一点。我们在处理字符串最长子串、最长子序列以及其变形（例如最长递增子序列）时，不也常常定义 $dp[i]$ 为以第$\text{str}[i]$ 结尾的相应最长子串、子序列长度吗？这里定义 $dp[i][j]$ 为以矩阵中第 $i+1$ 行、第 $j+1$ 列元素为最后一个主对角元的只包含 `'1'` 最大正方形的边长（或面积），其实依然延续了这一思想，只不过给其应用原封不到地推广到了二维。这里我们以边长的定义为例。

那么新的问题又产生了，在新的状态定义下，我们该如何找到状态转移方程呢？最简单地，有
$$
dp[i][j]=0,\ \ \ \text{matrix}[i][j]=\text{'0'}
$$
那么当 $\text{matrix}[i][j]=\text{'1'}$ 时又是什么情况呢？首先可以很容易的知道，如果 $dp[i][j-1]=0$ 或 $dp[i-1][j]=0$，则必然有 $dp[i][j]=0$。对于更一般的情况该怎么办呢？

我们将以上结论延拓一下，假设 $dp[i][j-1]=a$、$dp[i-1][j]=b$，这里为方便示意我画一个图，如下所示：

![示意图](/images/221.png)

看！是不是一画图这个问题看起来就迎刃而解了？图中纯色区块（绿色和紫色）就是可以确保只包含 `'1'` 的正方形区域！而且，我们可以保证以矩阵特定位置作为主对角元的正方形区域不可能更大了，否则就违背了状态 $dp$ 的定义。

根据图意，似乎此时有
$$
dp[i][j]=\min\{a,b\}+1=\min\big\{dp[i][j-1],\ \ dp[i-1][j]\big\}+1
$$

可实际上这是错误的状态转移方程！至少是不充分的。因为我们忽视了一种情况：当 $a>b$ 或 $a<b$ 时更大的色块可以覆盖更小的色块（除了外侧的一行或一列），并且被覆盖的范围正是一个完美的矩形，即上图中的情况。可如果 $a=b\neq0$，则其中一个色块无法完全覆盖另一个色块，导致左上角出现一个无法确定是 `'0'` 还是 `'1'` 的格子，从而可确定的范围不再是矩形、而是缺了左上角的一格，如下图所示：

![特殊情况](/images/221_1.png)

上图中标记有问号的区域就是两个色块都涂不到的格子，显然此时我们不能肯定 $dp[i][j]=\min\{a,b\}+1$，因为如果问号格子是 `'0'`，则应修改为 $dp[i][j]=\big(\min\{a,b\}+1\big)-1=\min\{a,b\}$。不过我们可以确认 $dp[i][j]\leqslant\min\{a,b\}+1$，否则与前提相左，这点可以用反证法证明。

综上所述，我们最终的完整状态转移方程为：
$$
\text{let }\ a=dp[i][j-1],\ \ b=dp[i-1][j]
$$

$$
\boxed{dp[i][j]=\left\{\begin{aligned}&0,&&\text{matrix}[i][j]=\text{'0'}\\\\&a,&&\text{matrix}[i][j]=\text{'1'},\,a=b\,\text{ and\, matrix}[i-a][j-a]=\text{'0'}\\\\&\min\{a,b\}+1,&&\text{Others}\end{aligned}\right.}
$$

最后，Base case：
$$
\left\{\begin{align}
&dp[0][j]=\text{matrix}[0][j]-\text{'0'}\\\\
&dp[i][0]=\text{matrix}[i][0]-\text{'0'}
\end{align}\right.
$$
对于不涉及状态压缩、插头DP等复杂算法的初等DP，难点在于分析。一旦我们分析出了正确的状态定义与状态转移，程序设计是非常非常容易的！！！

最后，在更新 $dp$ 数组时记录其最大值，那么该最大值的平方就是所求只包含 `'1'` 的最大正方形的面积。

> 其实我是测试出错后debug才发现的漏考虑了 a = b 的情况，，，


# 我的动态规划代码

由于我们在按行更新 $dp$ 数组时只会用到本行前一次更新的数据与上一行的数据，因此我们这里采用动态数组的方法压缩空间开销，最终算法的时间复杂度为 $O(mn)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int maxSize = 0;

        int[] dpOld = new int[n];
        int[] dpNew = new int[n];
        for (int j = 0; j < n; j++) {
            dpOld[j] = matrix[0][j] - '0';
            maxSize = Math.max(maxSize, dpOld[j]);
        }

        for (int i = 1; i < m; i++) {
            dpNew[0] = matrix[i][0] - '0';
            maxSize = Math.max(maxSize, dpNew[0]);

            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == '0') {
                    dpNew[j] = 0;
                } else if (dpOld[j] == dpNew[j - 1] && matrix[i - dpOld[j]][j - dpOld[j]] == '0') {
                    dpNew[j] = dpOld[j];
                } else {
                    dpNew[j] = Math.min(dpNew[j - 1], dpOld[j]) + 1;
                }
                maxSize = Math.max(maxSize, dpNew[j]);
            }
            dpOld = dpNew;
        }
        return maxSize * maxSize;
    }
}
```

算法的性能很强，击败绝大部分代码。

![算法评估](/images/221_2.png)

可能可以进一步原地修改矩阵实现 $O(1)$ 的空间复杂度，不过我没有做进一步研究和尝试。

# 其他人的实现思路

按相同的状态定义，在其他人的实现中常见的状态转移方程形式是
$$
\boxed{dp[i][j]=\left\{\begin{aligned}&0,&&\text{matrix}[i][j]=\text{'0'}\\\\&\min\big\{a,\,b,\,dp[i-1][j-1]\big\} + 1,&&\text{matrix}[i][j]=\text{'1'}\end{aligned}\right.}
$$
读者可以思考一下为什么我的实现和他人实现的状态转移方程在数学上没有区别。
