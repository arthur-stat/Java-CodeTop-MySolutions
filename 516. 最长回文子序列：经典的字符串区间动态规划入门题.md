题目简述：

> 给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。
>
> 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

题目连接：[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

# 思路

典型的字符串动态规划问题。

定义 $dp[i][j]$ 为以 `s[i]` 为起点至 `s[j]` 为终点的最长回文子序列长度，则
$$
\forall i>j,\ \ dp[i][j]=0
$$

$$
\forall i,\ \ dp[i][i]=1
$$

$$
\forall i<j,\ \ dp[i][j]=\left\{\begin{align}&dp[i+1][j-1]+2,&&s[i]=s[j]\\\\&\max\big\{dp[i][j-1],\ dp[i+1][j]\big\},&&\text{Otherwise}\end{align}\right.
$$

---

题外话：如果是求最长回文子串的长度，那么状态转移比较相似但有不同，是这样的：
$$
\forall i>j,\ \ dp[i][j]=0
$$

$$
\forall i,\ \ dp[i][i]=1
$$

$$
\forall i,\ \ dp[i][i+1]=\left\{\begin{align}&2,&&s[i]=s[i+1]\\\\&0,&&\text{Otherwise}\end{align}\right.
$$

$$
\forall i<j-1,\ \ dp[i][j]=\left\{\begin{align}&dp[i+1][j-1]+2,&&s[i]=s[j]\,\text{ and }\,dp[i+1][j-1]\neq0\\\\&0,&&\text{Otherwise}\end{align}\right.
$$

# 代码

时间复杂度与空间复杂度均为 $O(n^2)$，但滚动数组可以轻易把空间复杂度优化到 $O(n)$，比较简单就不写了。

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        if (s.isEmpty()) return 0;

        int n = s.length();
        int[][] dp = new int[n][n];
        int maxDp = 1;
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        for (int row = n - 2; row >= 0; row--) {
            for (int col = row + 1; col < n; col++) {
                if (s.charAt(row) == s.charAt(col)) {
                    dp[row][col] = dp[row + 1][col - 1] + 2;
                } else {
                    dp[row][col] = Math.max(dp[row][col - 1], dp[row + 1][col]);
                }
                maxDp = Math.max(maxDp, dp[row][col]);
            }
        }

        return maxDp;
    }
}
```

