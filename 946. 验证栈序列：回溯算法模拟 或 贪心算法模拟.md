题目简述：

> 给定 `pushed` 和 `popped` 两个序列，每个序列中的 **值都不重复**，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 `true`；否则，返回 `false` 。

题目链接：[946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/)

# 回溯算法模拟

## 思路

第一反应是回溯算法或动态规划。动态规划或许需要验证，但回溯算法是极大概率可行的——在数据量 `1 <= pushed.length <= 1000` 下。

回溯算法的好处是其作为一种优化后的暴力搜索算法的通用性，即便本问题改为允许序列中的值存在重复，回溯算法依然可以轻松应对。但显然地，考虑回溯算法就没有利用上值均不重复的信息——但回溯算法依然不失为一种可行的解决方案。

## 代码

算法的时间复杂度为 $\Theta(nC_n)$，空间复杂度为 $O(n)$，其中 $C_n$ 为卡特兰数。

```java
class Solution {

    private int[] pushed;
    private int[] popped;
    private Deque<Integer> stack;
    private int n;

    public boolean validateStackSequences(int[] pushed, int[] popped) {
        this.pushed = pushed;
        this.popped = popped;
        this.n = pushed.length;
        this.stack = new ArrayDeque<>(n);
        return dfs(0, 0);
    }

    private boolean dfs(int push, int pop) {
        if (push == n && pop == n) return true;

        if (push < n) {
            stack.push(pushed[push]);
            if (dfs(push + 1, pop)) return true;
            stack.pop();
        }

        if (pop < n && !stack.isEmpty() && stack.peek() == popped[pop]) {
            int tmp = stack.pop();
            if (dfs(push, pop + 1)) return true;
            stack.push(tmp);
        }

        return false;
    }
}
```

# 贪心算法模拟

## 思路

利用上序列中各值都不重复的信息，就可以在模拟时将回溯算法换为针对本问题效率更高的贪心算法。

贪心算法的思路是顺序压栈 `pushed[i]`，且每次压完栈后都贪心地将栈顶尽可能弹出。最终，如果栈内是空的，则意味着我们结论是 `true`。

可以用一个显式栈进行模拟，这样空间复杂度为 $O(n)$；也可以用数组上的双指针模拟栈的行为，这样空间复杂度为 $O(1)$。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        int n = pushed.length;
        int[] stack = new int[n];
        int top = -1;

        int j = 0;
        for (int i = 0; i < n; i++) {
            stack[++top] = pushed[i];
            while (top >= 0 && stack[top] == popped[j]) {
                top--;
                j++;
            }
        }

        return top == -1;
    }
}
```

