题目简述：

> 给你一个整数数组 `nums`，将 `nums` 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。
>
> 返回满足此条件的 **任一数组** 作为答案。

题目链接：[905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)

# 前言

本问题有多种解决方案，

1. 视为荷兰国旗问题，线性时间复杂度且 $O(1)$ 空间开销的原地算法，但不是稳定算法；
2. 分治算法，属于原地算法但有递归栈空间开销，$O(n\log n)$ 时间复杂度，属于稳定算法；
3. 如果输出数组不算额外空间，即不要求原地算法，则双指针可以实现 $O(n)$ 时间复杂度的稳定算法。

看到有人说：

> “美团后端面试，要求时间复杂度ON，空间复杂度O1，并且不改变原奇数，偶数的相对次序”

那么面试官可能是认为输出数组不算额外空间，这属于第三种方案，考虑双指针方案。注意该方案不是原地算法。

如果要求原地算法，则考虑方案一与方案二：要求性能不在乎顺序则考虑方案一，性能要求不严格但要求保持顺序则考虑方案二。

一般来讲，本问题无法实现线性时间复杂度的稳定原地算法。

# 性能最优但不稳定的荷兰国旗

## 思路

荷兰国旗问题，只不过只存在 “大于” 和 “小于” 的二分关系，视 “等于” 关系不存在，然后将每个奇数元素归为大于区、将每个偶数元素归为小于区即可。

如果读者对荷兰国旗问题不熟悉，可以移步至我在 [75. 颜色分类](https://leetcode.cn/problems/sort-colors/) 问题中撰写的解析，这里不再赘述。

## 代码

算法的时间复杂度为 $O(n)$，严格仅进行一趟遍历，空间复杂度为 $O(1)$，系原地算法，但可能改变原数组中奇数元素和偶数元素的相对次序，不是稳定的算法。

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;

        while (mid <= right) {
            boolean even = (nums[mid] & 1) == 0;

            if (even) {
                swap(nums, left, mid);
                left++;
                mid++;
            } else {
                swap(nums, right, mid);
                right--;
            }
        }

        return nums;
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

# 性能欠佳但稳定的分治算法

## 思路

分治算法能实现稳定的原地算法，时间复杂度为 $O(n\log n)$。

递归地将区间内元素有序地区分为偶数段与奇数段即可，不过维护元素有序、使算法具有稳定性的关键是通过旋转操作调整各段的顺序，而一次旋转操作可以通过三次反转实现。

具体来说，设计一个递归方法 `order(l, r)`，语义为使 `nums[l]` 至 `nums[r]` 区间内的各元素有序地调整为 `{even, odd}` 形式，其中 `even` 表示一段偶数，`odd` 表示一段奇数。然后，对于递归体内，取 `l` 与 `r` 的中点 `mid` 作为分界点，分别递归调用 `order(l, mid)` 与 `order(mid+1, r)`。

子递归调用返回后，`nums[l]` 至 `nums[r]` 区间段内的形式是 `{even1, odd1, even2, odd2}`，我们旋转 `odd1` 与 `even2`，旋转后结果为 `{even1, even2, odd1, odd2}` ，这样就实现了将 `nums[l]` 至 `nums[r]` 区间内的各元素有序地调整为 `{even, odd}` 形式。

具体如何实现旋转呢？三次反转即可！首先反转 `odd1`，再反转 `even2`，最后再反转整段 `odd1` 与 `even2`，就可以实现一次旋转。

## 代码

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(\log n)$，系原地算法，不会改变原数组中奇数元素和偶数元素的相对次序，是一种稳定算法。

```java
class Solution {

    private int[] nums;

    public int[] sortArrayByParity(int[] nums) {
        this.nums = nums;
        order(0, nums.length - 1);
        return nums;
    }

    private void order(int l, int r) {
        if (l >= r) return;

        int mid = l + ((r - l) >>> 1);
        order(l, mid);
        order(mid + 1, r);

        // 此时 [l, r] 内是 {even1, odd1, even2, odd2}
        // 旋转 odd1 与 even2，如果任意一方不存在则无需旋转
        int i = l;
        while (i <= mid && (nums[i] & 1) == 0) i++;
        if (i == mid + 1) return;
        int j = mid + 1;
        while (j <= r && (nums[j] & 1) == 0) j++;
        if (j == mid + 1) return;

        rotate(i, mid, j - 1);
    }

    private void rotate(int l, int mid, int r) {
        reverse(l, mid);
        reverse(mid + 1, r);
        reverse(l, r);
    }

    private void reverse(int l, int r) {
        while (l < r) {
            swap(l, r);
            l++;
            r--;
        }
    }

    private void swap(int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

# 双指针算法

## 思路

如果不要求实现原地算法、输出数组不算额外空间开销，那么可以考虑双指针。

需要进行两次遍历，首次遍历时统计出偶数元素的个数，然后在输出数组上初始化两个写指针 `i = 0` 与 `j = evenCount`，接着再扫描一次原数组，判断元素奇偶并分别在对应的写指针上写入即可。

## 代码

算法的时间复杂度为 $O(n)$，空间开销取决于是否视输出数组为额外开销（$O(1)$ 或 $O(n)$），是稳定算法。

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length;
        int[] output = new int[n];

        int evenCount = 0;
        for (int num : nums) if ((num & 1) == 0) evenCount++;

        int evenPtr = 0;
        int oddPtr = evenCount;

        for (int num : nums) {
            if ((num & 1) == 0) {
                output[evenPtr++] = num;
            } else {
                output[oddPtr++] = num;
            }
        }
        return output;
    }
}
```

