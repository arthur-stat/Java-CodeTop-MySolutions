题目简述：

> 给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。

题目链接：[204. 计数质数](https://leetcode.cn/problems/count-primes/)

# 埃拉托斯特尼筛

## 思路

常见的筛质数算法有两个，埃拉托斯特尼筛与欧拉筛。

埃拉托斯特尼筛的时间复杂度为 $O(n\log\log n)$，欧拉筛的时间复杂度则为 $O(n)$。

埃拉托斯特尼筛的思路很简单：

1. 首先初始化一个布尔数组 `isPrime` 表示相应数字是否为质数，初始化为 `true`，默认为质数；

2. 然后从 2 开始递增遍历 `i`，直到抵达 $\lfloor\sqrt{n}\rfloor$，

   - 如果 `isPrime[i]` 为 `true` 则认为 `i` 为质数，于是考虑所有包含质因子 `i` 的数：`i * i`、`(i + 1) * i`、`(i + 2) * i`……直到 `j * i` 大于等于 `n`，对所有小于 `n` 且含质因子 `i` 的数置其相应的 `isPrime` 为 `false`，表示对应数为合数；
   - 如果 `isPrime[i]` 为 `false` 则认为 `i` 为合数，不可能作为质因子，忽略。

   当 `i` 为质数时，考虑包含质因子 `i` 的合数从 `i * i` 开始搜寻的原因是如果 `1 * i`、`2 * i`、……、`(i - 1) * i` 为合数，则他们早被遍历中小于 `i` 的质数作为质因子已经筛掉了，因此可以跳过他们节省时间。

这样最终可以找出所有小于 `n` 的数字中的全部合数与全部质数，每个大于等于 2 的数字都被布尔数组 `isPrime` 二分为质数或合数。

## 代码

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);

        for (int i = 2; i * i < n; i++) {
            if (isPrime[i]) {
                for (int j = i; i * j < n; j++) {
                    isPrime[i * j] = false;
                }
            }
        }

        int res = 0;
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) res++;
        }

        return res;
    }
}
```

# 欧拉筛

欧拉筛在埃拉托斯特尼筛的基础上保证每个合数只被它的最小质因子筛掉一次，进而得到了更低的时间复杂度。

欧拉筛在除了布尔数组 `isPrime` 外，额外维护一个已知的质数列表，如果 `i` 是质数则加入质数列表，如果 `i` 是合数则遍历当前质数列表，依次对每个已知的质数 `p` 与 `i` 相乘以得到新的合数，直到 `i % p == 0`——这意味着 `p` 是 `i` 的最小质因子，因此遍历可以在此提前停止。