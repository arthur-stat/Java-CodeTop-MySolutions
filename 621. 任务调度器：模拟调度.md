题目简述：

> 给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表，用字母 A 到 Z 表示，以及一个冷却时间 `n`。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个 **相同种类** 的任务之间必须有长度为 `n` 的冷却时间。
>
> 返回完成所有任务所需要的 **最短时间间隔** 。

题目链接：[621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

# 严格模拟（小顶堆）

## 思路

我服了，本来刚读完题目我就有了该模拟的灵感，但一直觉得，这个问题不会这么简单吧？

想了好一阵子也没有想出更好的办法，决定先试试模拟的思路。

结果真就直接 AC 了……？

总之就是考虑贪心策略，将最终的调度队列视为若干个长 `n + 1` 的段（除最后一段），显然每段里是可以放置任意互不相同的任务的，这样段内就不会产生冲突，于是我们从待安排任务中按剩余安排次数从高至低依次在一个段内进行调度安排——这点可以用优先队列实现。如果该段不能被剩余待安排的不同的任务完全填充，即剩余任务已经少于 `n + 1` 个了，假设我们仍需要开启下一个段以安排完剩余任务，则当前段剩余部分就用默认任务 `idle` 填充。

段内可以安排互不相同的任务，那段间相同的任务呢？我们也可以保证他们之间至少间隔 `n`。不妨设当前段内安排的顺序是 `[a, b, c, ...]`，因为我们在该段内是按待安排任务中剩余安排次数从高至低依次调度的，因此在当前段任务剩余安排次数满足 $freq(a)\geqslant freq(b)\geqslant freq(c)\geqslant\cdots$ 的顺序。

进行到下一个段时，可能有新的任务剩余安排次数大于 `a`、`b` 或 `c` 的剩余待安排次数，这不重要，因为新任务是上一段内未安排的任务，绝不会与上一段产生冲突。重要的是，假设不存在新的任务剩余安排次数大于 `a` 的新任务，那么下一段内的安排顺序依然是 `[a, b, c, ...]`，即上一段内出现的任务他们互相之间的相对剩余待安排次数顺序是不变的，所以他们从优先队列中出队的顺序也是不变的。假设在本段存在新的任务 `u` 剩余安排次数大于 `[a, b, c, ...]` 中的某个任务，不妨设为 `b`，那么他的剩余安排次数也会大于 `c` 及 `c` 右侧的任务，故他会插入在 `[a, b, c, ...]` 间（`[a, u, b, c, ...]`），并使上一段被末位安排的任务在本段暂不再被调度（假设该任务还没有被安排完毕的话）。相对于上一段来说，相同任务间的间隔要么是段的长度 `n + 1`，要么因为新的任务 “插队” 而大于 `n + 1`，总之这样调度必然是合法的。于是，利用数学归纳法，我们可以证明每个段（相对上一段）都是合理的。

这里蕴含了一些周期性，实际上我就是从周期性得到的灵感。

## 代码

算法的时间复杂度为 $O(n)$，因为逐任务安排地给出了一个准确的调度队列，其中 $n$ 是所有任务需要被调度的次数，空间复杂度为 $O(1)$。

```java
class Pair implements Comparable<Pair> {

    int task;
    int num;

    Pair(int task, int num) {
        this.task = task;
        this.num = num;
    }

    @Override
    public int compareTo(Pair o) {
        return Integer.compare(o.num, this.num);
    }
}

class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] count = new int[26];
        for (char task : tasks) count[task - 'A']++;
        PriorityQueue<Pair> pq = new PriorityQueue<>();

        for (int i = 0; i < 26; i++) {
            if (count[i] > 0) pq.offer(new Pair(i, count[i]));
        }

        Deque<Pair> cache = new ArrayDeque<>();

        int step = 0;
        while (!pq.isEmpty()) {
            int tmp = 0;

            for (int i = 0; i < n + 1 && !pq.isEmpty(); i++) {
                Pair p = pq.poll();
                p.num--;
                if (p.num > 0) cache.push(p);
                tmp++;
            }

            if (cache.isEmpty()) {
                step += tmp;
            } else {
                step += n + 1;
            }

            while (!cache.isEmpty()) pq.offer(cache.pop());
        }

        return step;
    }
}
```

# 简化模拟

## 思路

为了提高性能、降低复杂度，我们可以只保留抽象的逻辑，而不进行严格的一比一按调度策略进行模拟。

我想简化模拟直接看代码会更容易看出思路，这里就不长篇大论了。其实逻辑上与上一个方案并没有区别，只是更高效地进行了计算。

## 代码

复杂度同上，但常数因子极小。

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] count = new int[26];
        for (char task : tasks) count[task - 'A']++;
        Arrays.sort(count);

        int step = 0;
        while (count[25] > 0) {
            int i = 25;
            int gap = n + 1;
            
            while (i >= 0 && gap > 0) {
                if (count[i] > 0) {
                    count[i]--;
                    step++;
                    gap--;
                }
                i--;
            }
            
            if (count[25] > 0) {
                step += gap;
            }
            
            Arrays.sort(count);
        }

        return step;
    }
}
```

# 更数学化地构造（非模拟）

参见官方题解 [任务调度器](https://leetcode.cn/problems/task-scheduler/)，这里不再赘述。本质上是进一步抽象了模拟的思路，将其总结为了数学公式。
