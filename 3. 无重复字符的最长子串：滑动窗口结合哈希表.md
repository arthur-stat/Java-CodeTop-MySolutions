题目简述：

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

题目链接：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

# 滑动窗口 + HashSet

## 思路

考虑滑动窗口（双指针的特殊情况），保证窗口内的元素不重复，尽可能使窗口更大。例如，设窗口的左端点索引为 $i$、窗口的右端点索引为 $j$，那么固定 $j$，尽可能让 $i$ 在窗口内元素不重复的情况下窗口尺寸最大，于是就可以得到每个元素作为窗口右端点时窗口的最大长度。其中，判断当前 $i$ 是否可能导致滑动窗口内元素重复的数据结构可以考虑 Set，用于判断某个元素在当前窗口内是否已存在。

这里能利用滑动窗口，是因为双指针存在单调性：固定增长右边界时，左边界要么不变，要么也随之增长。

当我们令 $j$ 遍历了每个元素后，便能覆盖所有情况——因为任何窗口一定以某个元素作为右端点，最长的窗口也不例外，进而可以得到全局最大窗口的尺寸。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(|\mathcal{C}|)$，其中 $|\mathcal{C}|$ 为可能出现的不同种类的字符数量。

这份代码会完整地遍历两次字符串，时间复杂度的常数因子较大。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        /* i: 滑动窗口左边界，闭区间
         * j: 滑动窗口右边界，闭区间 */
        Set<Character> set = new HashSet<>();
        int res = 0;
        int i = 0;
        for (int j = 0; j < s.length(); j++) {
            char c = s.charAt(j);
            boolean ok = set.add(c);
            if (ok) {
                // ====== 未重复 ======
                res = Math.max(j - i + 1, res);
            } else {
                // ====== 字符在历史上曾出现，尝试更新左边界 ======
                while (s.charAt(i) != c) {
                    set.remove(s.charAt(i));
                    i++;
                }
                i++;
                res = Math.max(j - i + 1, res);
            }
        }
        return res;
    }
}
```

# 滑动窗口 + HashMap 改进

## 思路

在上一个实现方案中，当 $j$ 自增后发现当前窗口内存在重复元素时，我们是让 $i$ 也逐个递增并寻找重复元素的。

实际上，尽管 $i,j$ 均为严格单调递增的，但我们可以改 Set 为 Map，让 $i$ 的自增一步到位——用 Map 记录该字符上一次出现的位置即可，然后下次更新时让 $i$ 跳跃至该位置的下一个位置。

并且，该方案更加高效，因为我们记录的是一个元素上一次出现的位置，那么在一步到位更新 $i$ 后就不必再回头更新哈希表——因为我们所记录的是一个元素上一次出现的位置，而不再是在当前窗口内是否存在。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(|\mathcal{C}|)$，其中 $|\mathcal{C}|$ 为可能出现的不同种类的字符数量。

这份代码的时间复杂度常数因子更小，因为收缩滑动窗口、左边界右移时是 “一步到位” 的。但在 Java 的测试环境下花费的时间更多一点，这应该主要是 Java 自己对象带来的开销导致的。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        /* i: 滑动窗口左边界，闭区间
         * j: 滑动窗口右边界，闭区间
         * k: 上一个重复字符位置 */
        Map<Character, Integer> map = new HashMap<>();
        int res = 0;
        int i = 0;
        for (int j = 0; j < s.length(); j++) {
            char c = s.charAt(j);
            Integer k = map.putIfAbsent(c, j);
            if (k == null) {
                // ====== 未重复 ======
                res = Math.max(j - i + 1, res);
            } else {
                // ====== 字符在历史上曾出现 ======
                if (k < i) {
                    // 1. 字符上次出现的位置已不在滑动窗口范围内，按未重复处理，仅更新哈希表
                    map.put(c, j);
                    res = Math.max(j - i + 1, res);
                } else {
                    // 2. 字符在滑动窗口内重复，调整滑动窗口左边界
                    i = k + 1;
                    map.put(c, j);
                    res = Math.max(j - i + 1, res);
                }
            }
        }
        return res;
    }
}
```

