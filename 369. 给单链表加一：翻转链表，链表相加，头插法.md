题目简述：

> 给定一个用单链表表示的整数，然后把这个整数加一。
>
> 数据范围：链表长度满足 $1\leqslant n\leqslant1000$，链表上每个节点的值满足 $0\leqslant val\leqslant 9$，可以保证链表在非 0 的情况下没有前导零。
>
> 例如输入 {1, 2, 3} 时，对应的输出为 {1, 2, 4}。

题目链接：[369. 给单链表加一](https://leetcode.cn/problems/plus-one-linked-list)

牛客题目链接：[[编程题]给单链表加一](https://www.nowcoder.com/questionTerminal/a2f1105d2ac5466e9ba8fd61310ba6d1)

# 思路

首先<u>反转链表</u>，然后考虑对原本的尾节点、反转后的头节点加一。在加一（考虑进位）的过程中使用头插法，最终就能直接得到加一后的链表，而无需进行第二次反转。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    public ListNode plusOne(ListNode head) {
        ListNode tail = reverse(head);
        tail.val++;
        boolean carry = false;
        ListNode dummy = new ListNode(0);

        while (tail != null) {
            int num = tail.val + (carry ? 1 : 0);
            if (num > 9) {
                num -= 10;
                carry = true;
            } else {
                carry = false;
            }

            tail.val = num;
            ListNode tmp1 = dummy.next;
            dummy.next = tail;
            ListNode tmp2 = tail.next;
            tail.next = tmp1;
            tail = tmp2;
        }

        if (carry) {
            dummy.next.val = 0;
            ListNode tmp = dummy.next;
            dummy.next = new ListNode(1);
            dummy.next.next = tmp;
        }

        return dummy.next;
    }

    public ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode tmp = head.next;
            head.next = prev;
            prev = head;
            head = tmp;
        }
        return prev;
    }
}
```

有一种递归的解法也比较优雅，但空间复杂度为 $O(n)$。个人感觉这样就不如直接将链表进行数组化然后直接操作了。
