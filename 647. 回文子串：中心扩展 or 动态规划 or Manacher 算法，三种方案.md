题目简述：

> 给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。
>
> **回文字符串** 是正着读和倒过来读一样的字符串。
>
> **子字符串** 是字符串中的由连续字符组成的一个序列。

题目链接：[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

# 中心拓展

## 思路

中心拓展是最简单直接的方案，即遍历扫描元素，考虑每个元素（奇数长度回文串）或元素间的间隙（偶数长度回文串）作为回文串中点的可能性，从中点逐个尝试向两侧拓展，这样可以找出所有可能的回文串。

这种方案很直观，效率在大多数情况下也是较高的，只是并非最优解。

## 代码

算法的最坏时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int count = 0;

        // 奇数长度回文串
        for (int i = 0; i < n; i++) {
            count++;
            for (int j = 1; i - j >= 0 && i + j < n; j++) {
                if (s.charAt(i - j) == s.charAt(i + j)) {
                    count++;
                } else {
                    break;
                }
            }
        }

        // 偶数长度回文串
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; i - j >= 0 && i + j + 1 < n; j++) {
                if (s.charAt(i - j) == s.charAt(i + j + 1)) {
                    count++;
                } else {
                    break;
                }
            }
        }

        return count;
    }
}
```

# 动态规划

## 思路

本问题也可以用动态规划算法解决，本问题本身也是字符串动态规划的一个经典应用——虽然动态规划依然并非最优解。

定义 $dp[i][j]$ 表示以 `s[i]` 为左端点、以 `s[j]` 为右端点的回文子串数量，那么
$$
\forall i>j,\ \ dp[i][j]=0
$$

$$
\forall i,\ \ dp[i][i]=1
$$

$$
\forall i,\ \ dp[i][i+1]=\left\{\begin{align}&1,&&s[i]=s[j]\\\\&0,&&s[i+1]\neq s[i+1]\end{align}\right.
$$

$$
\forall i<j-1,\ \ dp[i][j]=\left\{\begin{align}&1,&&s[i]=s[j]\,\text{ and }\,dp[i+1][j-1]=1\\\\&0,&&\text{Otherwise}\end{align}\right.
$$

最终 $\displaystyle\sum_{i,j}dp[i][j]$ 即为问题的解。

实现算法时，务必注意 $dp[i][j]$ 的更新依赖于 $dp[i+1][j-1]$，因此最佳填表方向是自右下角始、向左上角进行，从下至上、从左至右。

## 基本 DP 代码

算法的最坏时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int count = 0;
        int[][] dp = new int[n][n];

        // init
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
            count++;
            if (i < n - 1 && s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = 1;
                count++;
            }
        }


        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 2; j < n; j++) {
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] == 1) {
                    dp[i][j] = 1;
                    count++;
                }
            }
        }

        return count;
    }
}
```

## 滚动数组优化空间开销

易见更新 DP 表的一行时，其状态只由其上一行决定，因此不必存储整个 DP 表，使用滚动数组能够将空间复杂度降至 $O(n)$。

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int count = 0;
        int[] dp1 = new int[n];
        int[] dp2 = new int[n];

        // init
        dp1[n - 1] = 1;
        count++;


        for (int i = n - 2; i >= 0; i--) {
            dp2[i] = 1;
            count++;
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp2[i + 1] = 1;
                count++;
            }

            for (int j = i + 2; j < n; j++) {
                if (s.charAt(i) == s.charAt(j) && dp1[j - 1] == 1) {
                    dp2[j] = 1;
                    count++;
                }
            }

            int[] tmp = dp1;
            dp1 = dp2;
            dp2 = tmp;
            Arrays.fill(dp2, 0);
        }

        return count;
    }
}
```

# Manacher 算法

Manacher 算法在求解回文子串问题上十分强大，能够做到 $O(n)$ 的时间复杂度并高效求出解。

推荐阅读 [马拉车算法，其实并不难!!!](https://blog.nowcoder.net/n/f8738331dbe04deaa3daaaa2bf139e73)，这篇文章写得很好，图文并茂，此处就不展开了。
