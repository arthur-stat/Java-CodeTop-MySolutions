题目简述：

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。
>
> **进阶：**
>
> - 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
> - 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

题目连接：[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

# 方案一：直接拼接

时间复杂度为 $O(n)$，空间空间复杂度为 $O(n)$。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        int[] res = new int[n];
        System.arraycopy(nums, n - k, res, 0, k);
        System.arraycopy(nums, 0, res, k, n - k);

        System.arraycopy(res, 0, nums, 0, n);
    }
}
```

# 方案二：原地三次翻转

这一方案时间复杂度为 $O(n)$，空间空间复杂度为 $O(1)$，系原地算法，不使用额外空间。是非常好的方案。

该方案和方案一（直接拼接）同样利用了翻转数组的性质，流程为

1. 先将数组全部翻转；
2. 然后翻转数组的前 $k$ 个元素；
3. 最后翻转数组的剩余元素。

可以从数学上证明，这样翻转后的数组即为轮转数组。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    private void reverse(int[] nums, int start, int end) {
        int times = (end - start + 1) / 2;
        for (int i = 0; i < times; i++) {
            swap(nums, start + i, end - i);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

