题目简述：

> 给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：
>
> - `'?'` 可以匹配任何单个字符。
> - `'*'` 可以匹配任意字符序列（包括空字符序列）。
>
> 判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

题目链接：[44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

# 二维动态规划

## 思路

比起 [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)，本问题要简单上不少，因为通配符匹配不需要考虑前驱字符，通配符能够匹配任意字符，状态转移很好找。

本问题本身也是一个比较经典的字符串动态规划问题，定义二值布尔状态 $dp[i][j]$ 表示字符模式 `p` 的长度为 $j$ 的前缀子串 `pp` 能否完全匹配输入字符串 `s` 的长度为 $i$ 的前缀子串 `ss`（1-based，便于初始化），则

- 若 `p[j-1]`（0-based）为 `'?'`，则 $dp[i][j]=dp[i-1][j-1]$

- 若 `p[j-1]`（0-based）为 `'*'`，则 $dp[i][j]=dp[i][j-1]\ \vee\ dp[i-1][j]$

  这里 $dp[i-1][j]$ 便利用了最优子结构，表示 `'*'` 匹配长度至少为 1 的任意字符序列情况。

- 其他情况下，当且仅当 `p[j-1]` 等于 `s[i-1]` 时 $dp[i][j]=dp[i-1][j-1]$，否则 $dp[i][j]=\mathrm{false}$

初始化条件：
$$
dp[0][0]=\mathrm{true}
$$

$$
\forall i>0,\ dp[i][0]=\mathrm{false}
$$

$\forall j>0$，若 `pp` 为若干 `'*'` 的组合则 $dp[0][j]$ 为 $\mathrm{true}$，否则为 $\mathrm{false}$。

最终 $dp$ 矩阵的最后一个主对角元即为问题的全局解。

## 代码

算法的时间复杂度为 $O(mn)$，空间复杂度为 $O(mn)$，但可以很轻易地利用滚动数组优化空间复杂度至 $O\big(\min\{m,n\}\big)$。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        char[] ss = s.toCharArray();
        char[] pp = p.toCharArray();
        boolean[][] dp = new boolean[m + 1][n + 1];

        dp[0][0] = true;
        for (int j = 1; j < n + 1; j++) {
            if (pp[j - 1] == '*') {
                dp[0][j] = true;
            } else {
                break;
            }
        }

        for (int row = 1; row < m + 1; row++) {
            char c = ss[row - 1];

            for (int col = 1; col < n + 1; col++) {
                char cc = pp[col - 1];
                
                switch (cc) {
                    case '?':
                        dp[row][col] = dp[row - 1][col - 1];
                        break;
                    case '*':
                        dp[row][col] = dp[row][col - 1] || dp[row - 1][col];
                        break;
                    default:
                        dp[row][col] = cc == c ? dp[row - 1][col - 1] : false;
                        break;
                }
            }
        }

        return dp[m][n];
    }
}
```

# 贪心算法

## 思路

本问题也可以用贪心算法解决，而且算法会比二维动态规划更快，虽然渐进时间复杂度也为 $O(mn)$，但平均时间复杂度为 $O(m\log n)$。其思路大概是 `'*'` 能匹配任意字符序列，那么就分割 `'*'`，使用两个指针回溯标记 `'*'` 的位置。

更具体说，该方案下将匹配规则 `p` 视为 `(*) + p1 + * + p2 + * + p3 + ...` 的形式，如果我们能在字符串 `s` 中按次序分别找到不重叠的 `p1`、`p2`、`p3` 等子串，那么 `p` 就能够匹配 `s`，否则不能匹配。如果某个子串多次出现，则只考虑首次出现的子串，因为这将使得后续子串匹配成功的可能性最大化，换句话说覆盖了匹配二次出现子串的情况。不过这里要单独考虑一下 `p` 的首尾是否为 `'*'`。

据说还可以用 AC 自动机继续优化，反正我不会了。
