题目简述：

> 给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
> 请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。
>
> 你必须找到一个内存复杂度优于 `O(n^2)` 的解决方案。
>
> **进阶：**
>
> - 你能否用一个恒定的内存（即 `O(1)` 内存复杂度）来解决这个问题？
> - 你能在 `O(n)` 的时间复杂度下解决这个问题吗？这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) ）很有趣。

题目链接：[378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

# 若干姊妹问题

- [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)：多路归并
- [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)：多路归并，二分查找
- [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)：多路归并，值域二分 + 楼梯计数
- [786. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)：多路归并，值域二分 + 楼梯计数

# 值域二分 + 楼梯计数

## 思路

这是常规思路中最高效的一种。

本方法和常规的二分搜索不同——通常意义的二分搜索是利用值对索引进行二分。但在本问题中，我们直接对值域进行二分。根据给定矩阵的性质，范围内的最大值与最小值我们是可以直接得出来的——左上角元即为最小值，右下角元即为最大值。因此，我们取 `mid` 为最大值与最小值的均值——二分取 `mid` 为某个索引，然后统计矩阵中小于等于该值的元素数量。

统计这一数量的具体做法就是**楼梯计数**。如果矩阵内小于 `mid` 的数的数量大于 $k$，则收缩右边界，否则增加左边界。

本方法的分析和推理，我比较推荐直接阅读力扣官方题解：[有序矩阵中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/solutions/311472/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/)。这里就不多说啦~

本问题的官方题解写得很好！请直接移步至力扣官方题解。

## 代码

算法总体的时间复杂度为 $O\big(n\log(\max-\min)\big)$，空间复杂度为 $O(1)$。

其中，`countLessMid()` 方法的时间复杂度为 $O(n)$。

```java
class Solution {

    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int min = matrix[0][0];
        int max = matrix[n - 1][n - 1];

        while (min <= max) {
            int mid = min + (max - min) / 2;
            int count = countLessMid(matrix, mid);
            if (count < k) {
                min = mid + 1;
            } else {
                max = mid - 1;
            }
        }

         return min;
    }

    private int countLessMid(int[][] matrix, int mid) {
        int n = matrix.length;
        int count = 0;

        int x = n - 1;
        int y = 0;
        
        while (x >= 0 && y < n) {
            if (matrix[x][y] <= mid) {
                y++;
            } else {
                count += y;
                x--;
            }
        }

        if (x >= 0) {
            count += (x + 1) * y;
        }

        return count;
    }
}
```

# 去重小顶堆 BFS (Dijkstra)

## 思路

不难证明，对于 $matrix[i][j]$，其后继数（大于 $matrix[i][j]$ 的数中最小的那一个）要么是 $matrix[i+1][j]$，要么是 $matrix[i][j+1]$，因此可以将索引数对 $(0,0)$ 加入优先队列作为起点，然后循环地从优先队列中取出当前值最小的索引数对 $(i_0,j_0)$，同时尝试将 $(i_0+1,j_0)$ 与 $(i_0,j_0+1)$ 加入到优先队列。

这里存在重复加入数对的风险，最简单的办法是使用哈希表去重，更高效的方案是考虑多路归并，从根本上避免重复计数、数对重复进入优先队列。

这实际上是一种 Dijkstra 风格的 BFS。

## 代码

算法的时间复杂度为 $O(k\log k)$，空间复杂度为 $O(k)$。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        Set<Long> visited = new HashSet<>();
        PriorityQueue<Long> pq = new PriorityQueue<>((a, b) -> {
            int ai = (int) (a.longValue() >>> 32);
            int aj = (int) a.longValue();
            int bi = (int) (b.longValue() >>> 32);
            int bj = (int) b.longValue();
            return Integer.compare(matrix[ai][aj], matrix[bi][bj]);
        });

        pq.offer(0L);
        visited.add(0L);
        for (int x = 0; x < k - 1; x++) {
            long zip = pq.poll();
            int i = (int) (zip >>> 32);
            int j = (int) zip;

            long zip1 = ((long) (i + 1) << 32) | (j & 0xffffffffL);
            long zip2 = ((long) i << 32) | ((j + 1) & 0xffffffffL);
            if (i < n - 1 && !visited.contains(zip1)) {
                pq.offer(zip1);
                visited.add(zip1);
            }
            if (j < n - 1 && !visited.contains(zip2)) {
                pq.offer(zip2);
                visited.add(zip2);
            }
        }

        long res = pq.poll();
        return matrix[(int) (res >>> 32)][(int) res];
    }
}
```

# 小顶堆多路归并

## 思路

在去重小顶堆 BFS 的基础上考虑多路归并。这类计算数对在某种序下的第 $k$ 个元素的问题，都很适合多路归并。

多路归并的分析与论断请移步并查阅我为 [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) 撰写的题解，这里就不再赘述了。

## 代码

算法的时间复杂度为 $O(k\log n)$，空间复杂度为 $O(n)$。

该方案的实际性能表现是优于去重小顶堆 BFS 的，尽管从理论复杂度上看并不更优。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        PriorityQueue<Long> pq = new PriorityQueue<>((a, b) -> {
            int ai = (int) (a.longValue() >>> 32);
            int aj = (int) a.longValue();
            int bi = (int) (b.longValue() >>> 32);
            int bj = (int) b.longValue();
            return Integer.compare(matrix[ai][aj], matrix[bi][bj]);
        });

        // init
        for (int i = 0; i < n; i++) {
            pq.offer(i & 0xffffffffL);
        }
        
        for (int x = 0; x < k - 1; x++) {
            long zip = pq.poll();
            int i = (int) (zip >>> 32);
            int j = (int) zip;
            if (i < n - 1) pq.offer(((long) (i + 1) << 32) | (j & 0xffffffffL));
        }

        long res = pq.poll();
        return matrix[(int) (res >>> 32)][(int) res];
    }
}
```

# 转化为 Top-K

## 思路

显然地，只要我们算出最小的 $k$ 个元素，那么就能直接得到顺序第 $k$ 小的元素，于是问题可以被转化为 Top-K 问题。利用快速选择算法或大顶堆（优先队列）都可以实现解决 Top-K 问题的算法，且空间复杂度远低于 $O(n^2)$。

但这样做其实意义不大，因为时间复杂度太高。

## 代码

这里以大顶堆为例，使用 Java 提供的优先队列内置实现。快速排序与手搓大小顶堆请参见我以前的题解。

算法的时间复杂度为 $O(n^2\log k)$，空间复杂度为 $O(k)$，满足内存复杂度低于 $O(n^2)$ 的要求。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        PriorityQueue<Integer> pq = new PriorityQueue<>(k, (a, b) -> b - a);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                pq.offer(matrix[i][j]);
                if (pq.size() > k) pq.poll();
            }
        }
        
        return pq.poll();
    }
}
```
