题目简述：

> 给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。
>
> **进阶：**使用 `O(n)` 空间复杂度的解法很容易实现。你能想出一个只使用 `O(1)` 空间的解决方案吗？

题目链接：[99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

# 思路

二叉搜索树的中序遍历即为升序结果。因此，可以想象我们现在有一个升序数组 `[1, 2, ..., n]`，我们任意交换了其中两个元素，然后要求找出这两个元素。

很显然，如果我们任意交换升序数组中两个相异的元素，必然会导致数组被划分为三段局部升序但全局无序的部分，例如 `[1, 2, 3, 4, 5]`，我们交换其中的 `2` 与 `4`，得到 `[1, 4, 3, 2, 5]`，其中 `[1, 4]` 就是第一段局部升序部分，`[3]` 是第二段局部升序的部分，`[2, 5]` 是第三段局部升序的部分。第二段部分可能为空集，例如交换 `3` 与 `4` 这两个相邻元素时。

在首尾分别布置左右指针，左指针不断递增、右指针不断递减以寻找首个逆序的相邻元素，两个指针分别找到的第一个逆序元素就是第一段部分的末位元素与第三段部分的首位元素，即需要被交换的元素。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。如果要求 $O(1)$ 的空间复杂度，请考虑莫里斯遍历。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    private List<TreeNode> arr;

    public void recoverTree(TreeNode root) {
        // if (root == null) return;
        arr = new ArrayList<>();
        arr.add(new TreeNode(Integer.MIN_VALUE));
        dfs(root);
        arr.add(new TreeNode(Integer.MAX_VALUE));

        int i = 0;
        while (arr.get(i).val <= arr.get(i + 1).val) i++;
        int j = arr.size() - 1;
        while (arr.get(j).val >= arr.get(j - 1).val) j--;

        int tmp = arr.get(i).val;
        arr.get(i).val = arr.get(j).val;;
        arr.get(j).val = tmp;
    }

    private void dfs(TreeNode node) {
        if (node.left != null) dfs(node.left);
        arr.add(node);
        if (node.right != null) dfs(node.right);
    }
}
```

