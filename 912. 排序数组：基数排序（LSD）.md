题目简述：

> 给你一个整数数组 `nums`，请你将该数组升序排列。
>
> 你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

题目链接：[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

# 无符号数的基数排序

快速排序、堆排序与归并排序是最基本的基于比较的高效排序算法，他们的平均时间复杂度均为 $O(n\log n)$，适用于任何有序的数据，是通用的排序算法——不过如果对象是链表而非数组的话，归并排序最适合，因为另外两种算法需要进行随机访问。

基数排序只适用于定长的数据，例如 32 位有符号整数、定长字符串，忽略常数时理论时间复杂度为 $O(n)$，但实际时间开销往往会高于快速排序。此处只讲述基于整数的基数排序实现细节，如果对基数排序原理不熟悉，可以阅读《Introduction to Algorithms》进行学习。

这里考虑基于二进制段的 LSD（低位优先）基数排序实现，每轮选取 8 个连续的二进制位，于是一共需要进行 $32\div 8=4$ 轮主循环，每个主循环中在逻辑上使用 $2^8=256$ 个桶，并在每个桶内考虑计数排序作为子排序算法（因为基数的范围是有限的，所以可以考虑 $O(n)$ 开销的计数排序，而不需要使用快速排序等基于比较的排序算法，也可以说基数排序通过基数限制了桶的范围，从而可以让我们结合其他非比较排序算法）。不过我们实际上不需要真的把某个数据结构的实例作为桶，这样不仅存在额外空间开销、缓存不友好，还不可避免地每轮需要对 `nums` 进行三次完整的遍历：第一次遍历统计各桶的元素数量，第二次遍历将元素按顺序放入各个桶内，第三次遍历将各桶内元素再按桶间与桶内的顺序写回数组。

实际上，我们可以维护一个桶的首个元素在原数组中起始索引的前缀和数组以减少一次对 `nums` 的完整遍历。第一次遍历维持不变、统计各桶的尺寸，但随后暂不进行对 `nums` 的完整遍历，而是计算第一次遍历结果各桶桶内元素数量数组的前缀和数组，然后进行第二次完整遍历，这次遍历直接将 `nums[i]` 写到临时数组上，写入临时数组的索引位置即为前缀和数组中对应的值，同时更新前缀和数组（`prefix[val++]`）。最后，交换临时数组与 `nums` 的引用以进行下一轮主循环的迭代，或是在返回结果前根据循环次数的奇偶判断是否需要将临时数组的内容完整写回 `nums`——如果要求直接修改 `nums` 的话。偶数次不需要最后完整写回。

有一个小细节是如何正确实现负数的处理。如果能够保证需要排序的数组都是正整数、无符号数，则记 `i` 为主循环轮次（0-based）、`j` 为完整遍历 `nums` 的索引，那么 `nums[j] >>> (8 * i) & 0xff` 就是元素对应的桶的编号（0-based），因此令 `prefix[nums[j] >>> (8 * i) & 0xff]++` 即可在第一次遍历的过程中完成一个元素的分桶计数——但为了后续能够直接利用 `prefix` 构造前缀和数组，通常会改用 1-based 以留出首位，即 `prefix[(nums[j] >>> (8 * i) & 0xff) + 1]++`。

一个简单的例子，算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$：

```java
/* 仅适用于 32 位有符号非负整数或 32 位无符号数 */
public void sortArray(int[] nums) {
    int n = nums.length;
    int[] prefix = new int[256 + 1];
    int[] tmp = new int[n];

    for (int i = 0; i < 4; i++) {
        Arrays.fill(prefix, 0);

        for (int j = 0; j < n; j++) {
            prefix[(nums[j] >>> (8 * i) & 0xff) + 1]++;
        }

        for (int k = 1; k <= 256; k++) {
            prefix[k] += prefix[k - 1];
        }

        for (int j = 0; j < n; j++) {
            tmp[prefix[nums[j] >>> (8 * i) & 0xff]++] = nums[j];
        }

        // System.arraycopy(tmp, 0, nums, 0, n);
        int[] arr = nums;
        nums = tmp;
        tmp = arr;
    }
}
```

显然，这份简单的处理方案是不能直接作用于负数的，因为负数的符号位大于正数的符号位。

# 有符号数的基数排序

针对数组中存在负数的情况，常考虑按位偏移（翻转符号位），这是一个特别的小技巧。具体做法是：

1. 将所有数的符号位（最高位）翻转，可以通过将每个元素与 `Integer.MIN_VALUE` 异或得到；
2. 现在我们再将每个数解释为无符号数，就可以确保原正数恒大于原负数了，并且不需要修改任何其他的逻辑，原正数与原正数之间与原负数与原负数之间照常对比即可；
3. 最后我们再将每个数的符号位翻转回去即可，可以通过将每个元素与 `Integer.MIN_VALUE` 再次异或得到。

这样，我们就能实现时间复杂度为 $O(n)$、空间复杂度为 $O(n)$ 且能够真正处理有符号数的基数排序算法了：

```java
class Solution {
    /* 适用于 32 位有符号数 */
    public int[] sortArray(int[] nums) {
        int n = nums.length;
        int[] prefix = new int[256 + 1];
        int[] tmp = new int[n];

        for (int i = 0; i < n; i++) nums[i] ^= Integer.MIN_VALUE;

        for (int i = 0; i < 4; i++) {
            Arrays.fill(prefix, 0);

            for (int j = 0; j < n; j++) {
                prefix[(nums[j] >>> (8 * i) & 0xff) + 1]++;
            }

            for (int k = 1; k <= 256; k++) {
                prefix[k] += prefix[k - 1];
            }

            for (int j = 0; j < n; j++) {
                tmp[prefix[nums[j] >>> (8 * i) & 0xff]++] = nums[j];
            }

            // System.arraycopy(tmp, 0, nums, 0, n);
            int[] arr = nums;
            nums = tmp;
            tmp = arr;
        }

        for (int i = 0; i < n; i++) nums[i] ^= Integer.MIN_VALUE;

        return nums;
    }
}
```

