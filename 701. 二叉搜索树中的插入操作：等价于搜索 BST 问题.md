题目简述：

> 给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。
>
> **注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

题目链接：[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

# 思路

因为只需要返回任意合法结果，那么本问题可以等价于搜索 BST，只不过那个值不存在，所以最终我们需要记录前驱节点并在算法终止时为前驱节点新挂上目标值节点作为子节点。

问题保证了目标值不会出现在 BST 内，这种情况下搜索 BST 的话，显然地：

- 如果当前节点的值小于目标值，则向当前节点的左子节点搜索；
- 如果当前节点的值大于目标值，则向当前节点的右子节点搜索；
- 当发现当前节点为叶子节点时，为当前节点挂上新的子节点，该子节点的值为目标值，算法结束。

# 代码

算法的平均时间复杂度为 $O(\log n)$，空间复杂度为 $O(1)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        TreeNode node = root;

        while (true) {
            if (node.val > val) {
                if (node.left != null) {
                    node = node.left;
                } else {
                    node.left = new TreeNode(val);
                    break;
                }
            } else {
                if (node.right != null) {
                    node = node.right;
                } else {
                    node.right = new TreeNode(val);
                    break;
                }
            }
        }

        return root;
    }
}
```

