题目简述：

> 给你一个字符串数组 `tokens` ，表示一个根据逆波兰表示法表示的算术表达式。
>
> 请你计算该表达式。返回一个表示表达式值的整数。
>
> **注意：**
>
> - 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
> - 两个整数之间的除法总是 **向零截断** 。
> - 表达式中不含除零运算。
> - 输入是一个根据逆波兰表示法表示的算术表达式。
> - 答案及所有中间计算结果可以用 **32 位** 整数表示。

题目链接：[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

# 思路

计算器的实现一般有两个简洁的方案，一个是双栈（数字栈 + 运算符栈），另一个就是将原本的适合人类阅读的中缀表达式转为适合计算机一次遍历处理的后缀表达式，也称为逆波兰表达式。

对于已经给定的逆波兰表达式，他与中缀表达式的区别是：

1. 运算符后置，例如 `["1", "2", "-"]` 表示 $1-2$。在中缀表达式中，顺序为 `["1", "-", "2"]`。
2. 构造逆波兰表达式时已经考虑了运算符的优先级。中缀表达式需要我们人为控制运算符的优先级，双栈的计算器实现方案就是直接基于中缀表达式的。而在逆波兰表达式中，由于逆波兰表达式本身已经表示的是考虑运算符顺序后的结果，因此计算机只需要从左到右进行一遍扫描，直接计算。

所以如果要计算已经构造好的逆波兰表达式，我们只需要一个栈，栈中只存入数字。遍历扫描 `tokens`，如果是数字就压入栈，如果是运算符就弹出两个栈顶，然后按相应的运算符，计算两个数字，并将结果重新压入栈。

最终，栈中只剩下一个元素，即为最终结果。

---

对于本问题，是给定一个已构造好的逆波兰表达式，我们来计算其结果。用一个数字栈即可。

可如果要我们对于一个中缀表达式，计算其逆波兰表达式呢？考虑 Dijkstra 提出的调度场算法：

用两个栈（或栈+输出表）：

- **输出序列**（结果栈/队列）：保存最终的后缀表达式；
- **运算符栈**：保存运算符，确保按照优先级/括号正确出栈。

扫描中缀表达式的每个 token：

1. **操作数（数字/变量）** → 直接加入输出序列。
2. **左括号 "("** → 压入运算符栈。
3. **右括号 ")"** → 把运算符栈弹出到输出序列，直到遇到 "("。丢弃这一对括号。
4. **运算符（+ - \* / …）** →
   - 当栈顶存在**优先级 ≥ 当前运算符**的符号时，把栈顶弹出到输出序列；
   - 然后再把当前运算符压入栈。
5. **表达式读完** → 把运算符栈剩下的全部弹出到输出序列。

# 代码

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<String> stack = new ArrayDeque<>();

        for (int i = 0; i < tokens.length; i++) {
            if (tokens[i].equals("+")) {
                int b = Integer.parseInt(stack.pop());
                int a = Integer.parseInt(stack.pop());
                stack.push("" + (a + b));
            } else if (tokens[i].equals("-")) {
                int b = Integer.parseInt(stack.pop());
                int a = Integer.parseInt(stack.pop());
                stack.push("" + (a - b));
            } else if (tokens[i].equals("*")) {
                int b = Integer.parseInt(stack.pop());
                int a = Integer.parseInt(stack.pop());
                stack.push("" + (a * b));
            } else if (tokens[i].equals("/")) {
                int b = Integer.parseInt(stack.pop());
                int a = Integer.parseInt(stack.pop());
                stack.push("" + (a / b));
            } else {
                stack.push(tokens[i]);
            }
        }

        return Integer.parseInt(stack.pop());
    }
}
```

