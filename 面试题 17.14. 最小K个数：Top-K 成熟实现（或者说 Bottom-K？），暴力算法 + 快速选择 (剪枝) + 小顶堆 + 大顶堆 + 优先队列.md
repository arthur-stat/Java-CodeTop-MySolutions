题目简述：

> 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。

题目链接：[面试题 17.14. 最小K个数](https://leetcode.cn/problems/smallest-k-lcci/)

# 暴力算法

时间复杂度为 $O(kn)$，再慢一点点就要超时了，不建议！空间复杂度为 $O(k)$。

AC 时耗时 2772ms。

```java
class Solution {

    private int[] minK;

    public int[] smallestK(int[] arr, int k) {
        minK = new int[k];
        Arrays.fill(minK, Integer.MAX_VALUE);
        for (int a : arr) {
            update(a);
        }
        return minK;
    }

    private void update(int num) {
        int k = minK.length;
        for (int i = 0; i < k; i++) {
            if (minK[i] >= num) {
                for (int j = k - 1; j > i; j--) {
                    minK[j] = minK[j - 1];
                }
                minK[i] = num;
                return;
            }
        }
    }
}
```

# 快速选择 + 剪枝

算法的平均时间复杂度为 $O(n)$，最坏时间复杂度为 $O(n^2)$，空间复杂度为 $O(\log n)$。空间开销主要来自于递归栈。

AC 时耗时 2ms。

```java
class Solution {

    private int[] arr;
    private int k;
    private Random rand;

    public int[] smallestK(int[] arr, int k) {
        this.arr = arr;
        this.k = k;
        rand = new Random(666);
        quickSelect(0, arr.length - 1);
        return Arrays.copyOf(arr, k);
    }

    private void quickSelect(int low, int high) {
        if (low >= high) return;

        int r = rand.nextInt(low, high + 1);
        int pivot = arr[r];

        int left = low;
        int right = high;
        int i = low;
        while (i <= right) {
            if (arr[i] < pivot) {
                swap(i, left);
                left++;
                i++;
            } else if (arr[i] == pivot) {
                i++;
            } else {
                swap(i, right);
                right--;
            }
        }

        // quickSelect(low, left - 1);
        // quickSelect(right + 1, high);
        if (k - 1 < left) {
            quickSelect(low, left - 1);
        } else if (k - 1 > right) {
            quickSelect(right + 1, high);
        } else {
            return;
        }
        // ↑ 快选剪枝优化 ↑
    }

    private void swap(int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

如果不剪枝，则 AC 时耗时 7ms，花费的时间与大小顶堆是一样的。

# 优先队列（JDK 提供的大顶堆）

算法的时间复杂度为 $O(n\log k)$，空间复杂度为 $O(k)$。

AC 时耗时 18ms。

```java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        if (k == 0) return new int[0];

        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        for (int a : arr) {
            if (pq.size() < k) {
                pq.offer(a);
            } else {
                if (pq.peek() > a) {
                    pq.poll();
                    pq.offer(a);
                }
            }
        }

        return toArray(pq);
    }

    public static int[] toArray(PriorityQueue<Integer> pq) {
        int size = pq.size();
        int[] result = new int[size];
        int i = 0;
        for (int num : pq) {
            result[i++] = num;
        }
        return result;
    }
}
```

# 大顶堆（数组）

算法的时间复杂度为 $O(n\log k)$，空间复杂度为 $O(k)$。

AC 时耗时 7ms。

```java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        if (k == 0) return new int[0];
        MaxHeap maxHeap = new MaxHeap(k);

        for (int a : arr) {
            if (maxHeap.size() < k) {
                maxHeap.offer(a);
            } else {
                if (maxHeap.peek() > a) {
                    maxHeap.poll();
                    maxHeap.offer(a);
                }
            }
        }

        return maxHeap.toIntArray();
    }

    static class MaxHeap {

        // 将数组改为动态数组 ArrayList，那么这就是一个优先队列的实现了
        private int[] nums;
        private int size;

        public MaxHeap(int k) {
            nums = new int[k];
            size = 0;
        }

        public MaxHeap(int[] arr) {
            nums = arr;
            size = nums.length;

            for (int i = size / 2 - 1; i >= 0; i--) {
                shiftDown(i);
            }
        }

        public void offer(int num) {
            size++;
            nums[size - 1] = num;
            shiftUp(size - 1);
        }
        
        public void poll() {
            swap(0, size - 1);
            size--;
            shiftDown(0);
            // return nums[size];
        }

        public int[] toIntArray() {
            return nums;
        }

        public int peek() {
            return nums[0];
        }

        public int size() {
            return size;
        }

        private void shiftUp(int i) {
            while (true) {
                int p = parent(i);
                if (!check(p)) break;

                if (nums[p] < nums[i]) {
                    swap(i, p);
                    i = p;
                } else {
                    break;
                }
            }
        }

        private void shiftDown(int i) {
            while (true) {
                int l = leftChild(i);
                int r = rightChild(i);
                boolean ll = check(l);
                boolean rr = check(r);
                int maxSubNode;
                if (ll && rr) {
                    maxSubNode = nums[l] > nums[r] ? l : r;
                } else if (ll) {
                    maxSubNode = l;
                } else if (rr) {
                    maxSubNode = r;
                } else {
                    break;
                }

                if (nums[i] < nums[maxSubNode]) {
                    swap(i, maxSubNode);
                    i = maxSubNode;
                } else {
                    break;
                }
            }
        }

        private int leftChild(int i) {
            return 2 * i + 1;
        }

        private int rightChild(int i) {
            return 2 * i + 2;
        }

        private int parent(int i) {
            return (i - 1) / 2;
        }

        private boolean check(int i) {
            return i >= 0 && i < size;
        }

        private void swap(int i, int j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }
}
```

# 小顶堆（数组）

算法的时间复杂度为 $O(n+k\log n)$，空间复杂度为 $O(n)$。

AC 时耗时 7ms。

```java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        if (k == 0) return new int[0];
        MinHeap minHeap = new MinHeap(arr);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) res[i] = minHeap.poll();
        return res;
    }

    static class MinHeap {

        // 将数组改为动态数组 ArrayList，那么这就是一个优先队列的实现了
        private int[] nums;
        private int size;

        public MinHeap(int k) {
            nums = new int[k];
            size = 0;
        }

        public MinHeap(int[] arr) {
            nums = arr;
            size = nums.length;

            for (int i = size / 2 - 1; i >= 0; i--) {
                shiftDown(i);
            }
        }

        public void offer(int num) {
            size++;
            nums[size - 1] = num;
            shiftUp(size - 1);
        }
        
        public int poll() {
            swap(0, size - 1);
            size--;
            shiftDown(0);
            return nums[size];
        }

        public int[] toIntArray() {
            return nums;
        }

        public int peek() {
            return nums[0];
        }

        public int size() {
            return size;
        }

        private void shiftUp(int i) {
            while (true) {
                int p = parent(i);
                if (!check(p)) break;

                if (nums[p] > nums[i]) {
                    swap(i, p);
                    i = p;
                } else {
                    break;
                }
            }
        }

        private void shiftDown(int i) {
            while (true) {
                int l = leftChild(i);
                int r = rightChild(i);
                boolean ll = check(l);
                boolean rr = check(r);
                int minSubNode;
                if (ll && rr) {
                    minSubNode = nums[l] < nums[r] ? l : r;
                } else if (ll) {
                    minSubNode = l;
                } else if (rr) {
                    minSubNode = r;
                } else {
                    break;
                }

                if (nums[i] > nums[minSubNode]) {
                    swap(i, minSubNode);
                    i = minSubNode;
                } else {
                    break;
                }
            }
        }

        private int leftChild(int i) {
            return 2 * i + 1;
        }

        private int rightChild(int i) {
            return 2 * i + 2;
        }

        private int parent(int i) {
            return (i - 1) / 2;
        }

        private boolean check(int i) {
            return i >= 0 && i < size;
        }

        private void swap(int i, int j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }
}
```

