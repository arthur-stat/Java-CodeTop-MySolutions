题目简述：

> 给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

题目链接：[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

# 枚举

## 思路

从 1 开始，遍历每个可能的子串长度 `substringLen` 即可，判断长度为 `substringLen` 的子串能不能作为重复子串的 base case。

这样子效率也是很高的，时间复杂度近似 $O(n)$。有时间复杂度严格为 $O(n)$、常数时间开销极小的最优方案，考虑前缀匹配 / KMP，难度比枚举高出不少。

## 代码

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;

        main_loop:
        for (int substringLen = 1; substringLen <= n / 2; substringLen++) {
            if (n % substringLen == 0) {
                int i = substringLen;
                while (i < n) {
                    for (int j = 0; j < substringLen; j++) {
                        if (ss[j] != ss[i + j]) continue main_loop;
                    }
                    i += substringLen;
                }
                return true;
            }
        }

        return false;
    }
}
```

# 利用周期性的字符串方法

## 思路

利用编程语言提供的字符串操作，拼接 `s` 自身为 `s + s`，然后判断 `s + s` 中子串 `s` 是否在索引 0 以后、`s + s` 中位以前再次出现。

这个方法本质上也是利用了 KMP 算法——只不过是现成的，例如 Java 的 `indexOf` 内部实现是基于优化过的 Two-Way/KMP 算法。

可能比较 tricky，请结合代码。

## 代码

由于 Java 字符串是不可变对象，因此相当一部分字符串操作在 Java 中如此操作的效率很低。

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s + s).indexOf(s, 1) != -1 && (s + s).indexOf(s, 1) < s.length();
    }
}
```

# 前缀匹配 / KMP

## 思路

可以像上一种方案那样，实现 KMP 算法，然后将 `indexOf` 替换为我们自己的 KMP 算法，这样也是完全可行的。

但更高效率的方式是 KMP “只实现一半”，即利用最长相同前后缀 LPS 直接找出重复子串。这主要是因为我们并不关心实际的匹配位置，只关心子串是否有周期——KMP 算法会给出具体的匹配位置，这样的话如果希望不要将问题复杂化就不太好避免拼接 `s + s`。

当然，实现 LPS 后，更进一步地就是 KMP 算法了。

## 代码

LPS 和 KMP 看一次忘一次。嗯……

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        int[] lps = LPS(s);
        return lps[n - 1] > 0 && n % (n - lps[n - 1]) == 0;
    }

    public int[] LPS(String s) {
        int n = s.length();
        int[] lps = new int[n];
        
        int i = 1;
        int len = 0;
        while (i < n) {
            if (s.charAt(i) == s.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
        return lps;
    }
}
```

