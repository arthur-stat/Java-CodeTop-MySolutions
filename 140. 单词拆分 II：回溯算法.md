题目简述：

> 给定一个字符串 `s` 和一个字符串字典 `wordDict` ，在字符串 `s` 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。**以任意顺序** 返回所有这些可能的句子。
>
> **注意：**词典中的同一个单词可能在分段中被重复使用多次。
>
> **提示：**
>
> - `1 <= s.length <= 20`
> - `1 <= wordDict.length <= 1000`
> - `1 <= wordDict[i].length <= 10`
> - `s` 和 `wordDict[i]` 仅有小写英文字母组成
> - `wordDict` 中所有字符串都 **不同**

题目链接：[140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

# 回溯算法思路

[139. 单词拆分](https://leetcode.cn/problems/word-break/) 中，只要求给出一个字符串能否被字典中的单词拆分的结果，因此考虑动态规划。本问题则要求给出所有可能的句子，那么最好考虑回溯算法以遍历所有可能的解空间。

我的想法是首先对字典 `wordDict` 里的词按长度进行分桶，回溯算法的状态设计为起始索引，即我们认为起始索引以前的字符们是已被证明可以构建出合法的子句（并且子句可以从路径直接得到，拼接路径上的字符串即可），于是在当前起始索引位置上，遍历下一个单词可能的长度（即进行长度分桶时作为划分依据的单词长度），取其子串，考察与子串相等的字符串是否存在于对应长度桶内，如果存在则意味着我们成功延长了子句，如果不存在则当前分支非法、不存在合法解，进行回溯。

# 代码

```java
class Solution {

    private Map<Integer, Set<String>> buckets;
    private int[] tryLen;
    private List<String> path;
    private List<String> res;
    private String s;
    private int n;

    public List<String> wordBreak(String s, List<String> wordDict) {
        res = new ArrayList<>();
        this.s = s;
        n = s.length();

        buckets = new HashMap<>();
        for (String word : wordDict) {
            int len = word.length();
            Set<String> set = buckets.get(len);
            if (set == null) {
                set = new HashSet<>();
                buckets.put(len, set);
            }
            set.add(word);
        }

        tryLen = buckets.keySet().stream().mapToInt(Integer::intValue).toArray();
        Arrays.sort(tryLen);

        path = new ArrayList<>();
        dfs(0);
        return res;
    }

    private void dfs(int start) {
        if (start == n) {
            res.add(build(path));
            return;
        }

        for (int len : tryLen) {
            if (start + len > n) break;
            String sub = s.substring(start, start + len);
            if (buckets.get(len).contains(sub)) {
                path.add(sub);
                dfs(start + len);
                path.removeLast();
            }
        }

    }

    private String build(List<String> list) {
        StringBuilder sb = new StringBuilder();
        for (String s : list) {
            sb.append(s);
            sb.append(' ');
        }
        sb.setLength(sb.length() - 1);
        return sb.toString();
    }
}
```

