题目简述：

> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。
>
> 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层（从第 0 层开始），则该层包含 `1~ 2h` 个节点。
>
> **进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

题目链接：[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

# 思路

要设计一个时间复杂度优于 $O(n)$ 的方案，或许我们可以考虑二分查找。

大体上，我们考虑先序遍历，设计一个用于统计节点数量的递归方法，该方法传入某个节点作为相应子树的根节点，然后返回该子树的节点数量。重点在于如何计算子树的节点数量。

考虑递归结构是为了方便计算。对于传入的一个非空节点，我们通过某种方式计算得其左子节点对应的子树与右子节点对应的子树的节点数量，合起来再加上该节点本身（加一）即得到该节点对应的子树节点数量。

关键在于如何高效计算左子树与右子树的节点数量。

- 如果左子树或右子树的最左侧叶子节点深度与最右侧叶子节点深度相等，由于整棵树是完全二叉树，因此该左子树或右子树是一棵满二叉树，而一棵深度为 $k$ 的满二叉树有 $2^k-1$ 个节点，因此我们可以直接算出该左子树或右子树拥有的节点数量；
- 否则，左子树或右子树最左侧叶子节点深度与最右侧子节点深度不等——即左侧叶子节点深度比最右侧子节点深度小一，那么就对该左子树或右子树递归应用节点数统计方法。

---

针对下文的代码实现，这里分析其时间复杂度，证明该算法优于 $O(n)$ 时间复杂度的全遍历方案。

假设整棵树共有 $h$ 层，则 `getRightDepth(root.left)` 沿左子树的右链搜索时间开销为 $O(h)$，`getLeftDepth(root.right)` 沿右子树的左链搜索时间开销也为 $O(h)$，同时递归深度至多为 $h$。也就是说，共有 $h$ 层计算，而每一层的计算开销为 $O(h)$，因此总的时间复杂度为 $O(h^2)$。对于完全二叉树而言 $h$ 接近 $\log n$，因此可以认为时间复杂度为 $O\big((\log n)^2\big)$。

这实际上是一种分治算法。

# 代码

算法的时间复杂度为 $O\big((\log n)^2\big)$，空间复杂度为 $O(\log n)$。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        return count(root, getLeftDepth(root), getRightDepth(root));
    }

    // 左子树：left <- subleft，右子树：subright -> right
    private int count(TreeNode root, int leftDepth, int rightDepth) {
        if (root.left == null && root.right == null) return 1;
        if (root.left != null && root.right == null) return 2;

        int subleftDepth = getRightDepth(root.left);
        int subrightDepth = getLeftDepth(root.right);
        int count = 0;

        // 左子树
        if (leftDepth == subleftDepth + 1) {
            count += (int) Math.pow(2, subleftDepth) - 1;
        } else {
            count += count(root.left, leftDepth - 1, subleftDepth);
        }

        // 右子树
        if (rightDepth == subrightDepth + 1) {
            count += (int) Math.pow(2, subrightDepth) - 1;
        } else {
            count += count(root.right, subrightDepth, rightDepth - 1);
        }

        return count + 1;
    }

    private int getLeftDepth(TreeNode root) {
        int depth = 0;
        while (root != null) {
            root = root.left;
            depth++;
        }
        return depth;
    }

    private int getRightDepth(TreeNode root) {
        int depth = 0;
        while (root != null) {
            root = root.right;
            depth++;
        }
        return depth;
    }
}
```

