题目简述：

> 给你一个正整数 `n` ，请你找出符合条件的最小整数，其由重新排列 `n` 中存在的每位数字组成，并且其值大于 `n` 。如果不存在这样的正整数，则返回 `-1` 。
>
> **注意** ，返回的整数应当是一个 **32 位整数** ，如果存在满足题意的答案，但不是 **32 位整数** ，同样返回 `-1` 。

题目链接：[556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)

# 思路

这个问题和 [31. 下一个排列](https://leetcode.cn/problems/next-permutation/) 基本上没啥区别，原理与推导请参考 [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)。

本质上，这是一个离散数学问题。

凭印象的话（因为推不来离散数学），流程应该是：

- 从后往前找到一对相邻但递增的元素，记较小者为 `nums[i]`；
- 再从后往前找第一个大于 `nums[i]` 的元素 `nums[j]`，交换 `nums[i]` 与 `nums[j]`；
- 把 `nums[i + 1]` 及其以后的元素全部反转。反转后，`nums[i + 1]` 及其以后的元素均为升序。

# 代码

嗯嗯我也不知道为什么这样一定对，反正结论就是这样。

```java
class Solution {
    
    public int nextGreaterElement(int n) {
        int place = getPlace(n);
        int[] nn = toIntArray(n, place);

        int i;
        for (i = place - 2; i >= 0; i--) {
            if (nn[i] < nn[i + 1]) break;
        }
        if (i < 0) return -1;

        int j;
        for (j = place - 1; j > i; j--) {
            if (nn[j] > nn[i]) break;
        }

        swap(nn, i, j);
        reverse(nn, i + 1, place - 1);

        if (!checkOverflow(nn)) return -1;

        return parseInt(nn);
    }

    private int getPlace(int n) {
        int place = 0;
        while (n > 0) {
            n /= 10;
            place++;
        }
        return place;
    }

    private int[] toIntArray(int n, int place) {
        int[] arr = new int[place];

        while (place > 0) {
            int digit = n % 10;
            arr[place - 1] = digit;
            n /= 10;
            place--;
        }

        return arr;
    }

    private int parseInt(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res = res * 10 + num;
        }
        return res;
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start++, end--);
        }
    }

    private boolean checkOverflow(int[] nums) {
        int maxPlace = getPlace(Integer.MAX_VALUE);
        if (nums.length < maxPlace) return true;

        int[] maxValueArr = toIntArray(Integer.MAX_VALUE, maxPlace);
        for (int i = 0; i < maxPlace; i++) {
            if (nums[i] > maxValueArr[i]) {
                return false;
            } else if (nums[i] < maxValueArr[i]) {
                return true;
            }
        }

        return true;
    }
}
```

