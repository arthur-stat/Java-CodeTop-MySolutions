题目简述：

> 给定一个 N 叉树，找到其最大深度。
>
> 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
>
> N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

题目链接：[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

# BFS

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public int maxDepth(Node root) {
        if (root == null) return 0;

        Deque<Node> queue = new ArrayDeque<>();
        queue.offer(root);
        int num = 1;
        int level = 0;

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            num--;

            queue.addAll(node.children);

            if (num == 0) {
                level++;
                num = queue.size();
            }
        }

        return level;
    }
}
```

# DFS 先序遍历、中序遍历（递归、迭代）略

这个没有任何难度，略。

# DFS 后序遍历（递归）

```java
class Solution {
    public int maxDepth(Node root) {
        return dfs(root, 0);
    }

    private int dfs(Node node, int level) {
        if (node == null) return level;

        int maxLevel = level;
        for (Node sub : node.children) {
            maxLevel = Math.max(maxLevel, dfs(sub, level + 1));
        }

        return (level == maxLevel) ? level + 1 : maxLevel;
    }
}
```

# DFS 后序遍历（迭代）

```java
class Solution {
    public int maxDepth(Node root) {
        if (root == null) return 0;

        Deque<Node> stack = new ArrayDeque<>();
        Deque<Integer> depthStack = new ArrayDeque<>();
        Deque<Boolean> visitedStack = new ArrayDeque<>();

        stack.push(root);
        depthStack.push(1);
        visitedStack.push(false);

        int maxDepth = 0;

        while (!stack.isEmpty()) {
            Node node = stack.pop();
            int depth = depthStack.pop();
            boolean visited = visitedStack.pop();

            if (node == null) continue;

            if (!visited) {
                stack.push(node);
                depthStack.push(depth);
                visitedStack.push(true);

                for (int i = node.children.size() - 1; i >= 0; i--) {
                    stack.push(node.children.get(i));
                    depthStack.push(depth + 1);
                    visitedStack.push(false);
                }
            } else {
                maxDepth = Math.max(maxDepth, depth);
            }
        }

        return maxDepth;
    }
}
```

