题目简述：

> 给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

题目链接：[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

# Binary Indexed Tree

## 思路

> 核心思路：用 BIT 动态维护频率的前缀和

BIT 的常见用途是动态维护前缀和数组，使得原数组的直接更新后能以 $O(\log n)$ 的代价动态更新前缀和数组。BIT 在查询与维护间取得了平衡，单次操作的时间复杂度均为 $O(\log n)$。

BIT 的原理可以参考一些其他的文章，这里再单独介绍就显得本文过于繁琐了。BIT 的实现相比其原理异常简洁，这里直接给出一个 BIT 的实现：

```java
class BIT {

    private final int[] bit;
    private final int N;

    public BIT(int length) {
        bit = new int[length + 1];
        N = length;
    }

    // 1-based
    public void update(int i, int delta) {
        while (i <= N) {
            bit[i] += delta;
            i += i & -i;
        }
    }

    // 1-based
    public int query(int i) {
        int res = 0;
        while (i > 0) {
            res += bit[i];
            i -= i & -i;
        }
        return res;
    }
}
```

对于本问题，我们并不需要动态维护原数组的前缀和，显然这对解决问题没有帮助。我们需要做的是利用 BIT 动态维护频数数组的前缀和，这样逆向扫描时，就可以知道已扫描元素中小于某数的元素个数了。假设已经拥有了数字值至频数的映射，那么在理论上我们可以维护一个 BIT，该 BIT 维护所有数字值的频数前缀和。

这样解释或许比较抽象，举一个具体例子：假设已知逆向扫描至当前数字 $3$ 时，已经有频数统计 $\{0\to2,\ 2\to1,\ 5\to3\}$，那么 BIT 动态维护了逻辑上的前缀和数组 `[2, 2, 3, 3, 3, 6]`。我们要知道目前已扫描的数字有多少个小于 $3$，只需要查询数字值 $2$ 对应的频数前缀和 $3$，就可以知道目前有三个元素小于数字值 $3$。

现在存在一个问题：如果我们用 HashMap 在扫描时动态维护数字值与频数的映射并直接据此更新 BIT，那么 BIT 在动态维护频数前缀和时，原数组中数据范围有多大，BIT 的长度就会有多大——显然这是不可接受的。否则，只要原数组中存在两个元素的差值绝对值足够大，就会造成我们的 BIT 很长很长。

因此，我们需要离散化的手段以压缩 BIT 的长度。

一个简单的思路是复制一份原数组副本并对其排序，然后额外用一个 HashMap 升序地映射数字值至编号，这样就可以通过该 HashMap，用范围更小的编号一一对应范围无限制的数字值。后续用于频率统计的 HashMap 与 BIT 只需要维护编号的频率及其前缀和，而再需要直接维护数字值的频率及其前缀和。

注：其实本问题中用于频率统计的 HashMap 是不必要的~

## 代码

算法的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

```java
class Solution {

    private class BIT {

        private final int[] bit;
        private final int N;

        public BIT(int length) {
            bit = new int[length + 1];
            N = length;
        }

        // 1-based
        public void update(int i, int delta) {
            while (i <= N) {
                bit[i] += delta;
                i += i & -i;
            }
        }

        // 1-based
        public int query(int i) {
            int res = 0;
            while (i > 0) {
                res += bit[i];
                i -= i & -i;
            }
            return res;
        }
    }

    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        int[] tmp = nums.clone();
        Arrays.sort(tmp);

        // 离散化
        Map<Integer, Integer> discrete = new HashMap<>();
        for (int i = 0, count = 0; i < n; i++) {
            if (!discrete.containsKey(tmp[i])) {
                discrete.put(tmp[i], count++);
            }
        }

        // BIT
        BIT bit = new BIT(discrete.size());
        // Map<Integer, Integer> freq = new HashMap<>(discrete.size());
        List<Integer> res = Arrays.asList(new Integer[n]);
        
        for (int i = n - 1; i >= 0; i--) {
            int num = nums[i];
            int index = discrete.get(num);
            res.set(i, bit.query(index));
            bit.update(index + 1, 1);
            // freq.merge(i, 1, Integer::sum);
        }

        return res;
    }
}
```

# 归并排序计算逆序对

## 思路

在问题 [LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 中，我们利用归并排序的性质实现了快速统计逆序对。

逆序对意味着两个元素满足更小元素位于更大元素右侧，因此归并排序统计逆序对的框架适合解决本问题。

我觉得这个问题 BIT 解决是最优雅的。如果读者对这个解法感兴趣，或许可以参考 [『 4种解法一网打尽 』 有序数组、归并排序、树状数组和线段树的实现及注释](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solutions/1308773/4chong-jie-fa-yi-wang-da-jin-pai-xu-shu-5vvds/)，这里我就不再重写了。

（其实主要是懒，刚刚写完 BIT，现在已经凌晨三点二十分了，困……）