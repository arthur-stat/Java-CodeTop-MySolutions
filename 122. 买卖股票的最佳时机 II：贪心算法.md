题目简述：

> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
> 返回 *你能获得的 **最大** 利润* 。

题目链接：[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

# 贪心算法

相比[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)，这里允许我们多次买入卖出，只要同时只持有至多一个股票就可以了。

这显然也是个动态规划问题，我们可以应用贪心算法，本质上也是一种动态规划，但是在每个局部问题中都求局部最优解，而不是直接考虑整体最优解。

第二天的股票价格相较于前一天要么上升，要么下降或不变。

- 如果趋势是上升，若未持有股票则在今日买入，若有股票就卖出再买入；
- 如果趋势是下降或不变，若持有股票则在今日卖出，若未持有股票则不进行操作。

我们对每一天都这样操作，实际上就是在每一天都求得局部最优解，那么从整个股票交易时间来看，我们就赚到了最多的钱。因为对每个上升的时间段，我们相当于都在最低点买入并在最高点卖出（按贪心算法，上升期内的每天都卖出然后重新买入，结果上看相当于上升期内没有操作，最终只在上升期起始买入、在结束卖出）；每个下降的时间段我们都未进行操作，今天等待下降只是为了等到明天的下一轮上升。

这一切的前提是我们已经知道每一天的股票价格，所以实际上这就是在放马后炮，毕竟真正的股票交易怎么可能预测第二天的走势呢，顶多是针对历史数据计算我们一段时间内最多能赚多少，然后将这一数值与自己这段时间的实际盈亏进行对比，评估实际所采用的股票交易策略的好坏。当然可以说这是贪心算法，但我看来倒不如说是个很直观很浅显的直观想法。

CodeTop评论区的一句话说的很好：

> - 用户JTFNG
>
>   可以用这题检测自己是不是做题做傻了
>
>   - 用户QVSYE
>
>     @用户JTFNG 鉴定完毕，我已经变傻了

这里运用贪心算法，用车轱辘话说就是将连续上涨分解为多个单日上涨的叠加。

# 代码

实际实现代码的时候就更ez了，***只要第二天价格比昨天高就累加差额，否则不计数***。当然也可以用一个布尔变量表示是否已持有股票然后分别讨论，但没必要。

那句话说的确实对，“可以用这题检测自己是不是做题做傻了”。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int gain = 0;

        for (int i = 0; i < prices.length - 1; i++) {
            if (prices[i + 1] > prices[i]) {
                gain += prices[i + 1] - prices[i];
            }
        }
        
        return gain;
    }
}
```
