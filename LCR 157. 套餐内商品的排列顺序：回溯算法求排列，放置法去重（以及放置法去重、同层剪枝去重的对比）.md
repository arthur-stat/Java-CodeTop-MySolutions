题目简述：

> 某店铺将用于组成套餐的商品记作字符串 `goods`，其中 `goods[i]` 表示对应商品。请返回该套餐内所含商品的 **全部排列方式** 。
>
> 返回结果 **无顺序要求**，但不能含有重复的元素。
>
> 注：所谓不能含有重复元素，指例如输入 `"aab"`，应返回 `["aba","aab","baa"]`

题目链接：[LCR 157. 套餐内商品的排列顺序](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

# 思路

排列嘛，典型的回溯算法问题。

只需要注意考虑去重即可。

如果不需要去重，那么很简单地，用布尔数组 `used` 控制不重复使用元素即可，DFS 深度表示构造字符串 `path` 的下一个插入字符的位置，每次 DFS 时都考虑到每一个未被使用元素即可：

```java
class Solution {

    private StringBuilder path;
    private boolean[] used;
    private String[] res;
    private char[] goods;
    private int count;
    private int N;

    public String[] goodsOrder(String goods) {
        this.goods = goods.toCharArray();
        N = goods.length();
        count = 0;
        res = new String[factorial(N)];
        used = new boolean[N];
        path = new StringBuilder(N);
        dfs(0);
        return res;
    }

    private void dfs(int len) {
        if (len == N) {
            res[count++] = path.toString();
            return;
        }

        for (int i = 0; i < N; i++) {
            if (!used[i]) {
                used[i] = true;
                path.append(goods[i]);
                dfs(len + 1);
                path.setLength(len);
                used[i] = false;
            }
        }
    }

    private int factorial(int n) {
        int res = 1;
        while (n > 1) {
            res *= n;
            n--;
        }
        return res;
    }
}
```

---

在要求得到去重后的排列结果的前提下，一个经典的避免重复计数的方案就是所谓的**放置法**。

放置法就是：

1. 先对字符串内每个字符排序；

2. DFS 深度不再具体表示构造字符串 `path` 的下一个插入字符的位置，改为表示已插入元素数量。

   这对 DFS 探索方式与 `used` 的定义均有所影响，原来 DFS 的探索是对下一个插入位置遍历每一个未使用元素，`used` 表示原数组中的元素是否被使用；现在 DFS 的探索是对构造字符串的所有未插入字符的位置考虑插入原数组中的**下一个元素**，`used` 表示构造字符串中一个位置是否已被填入元素。

   这就是为什么该方法被称为放置法。

3. 我们避免重复计数的关键就在于 DFS 考虑的是插入原数组的**下一个元素**，我们可以利用顺序特殊地控制重复元素的**下一个元素**，进而实现去重。

   具体的做法是：

   - 由于排序后数组彼此重复的元素是相邻的，因此我们只需要考虑每个元素的前一个元素就可以判定该元素是否与已填充的元素相重复。

   - 如果元素与他的前一个元素不相同，意味着该元素（的值）在目前的构造字符串中是唯一的，因此该元素可以被置于所有未填充的位置。

   - 如果元素与他的前一个元素相同，意味着该元素（的值）在目前的构造字符串中已经存在了，于是我们只需要获取到他的前一个元素的位置，只将该元素置于该位置后即可。这样，构造字符串中重复元素的不同对象之间的相对位置只存在一个合法的序关系，而序又是唯一的，于是我们就确保了对于重复结果只计一次。

     一个高效地获取前一个元素位置的办法是为 DFS 增加一个参数，调用者直接将本次填充位置通过参数传给递归调用。

---

回溯算法在计算排列时不止放置法这一种去重方案——事实上还存在着多种同样高效的剪枝去重方案。比如，在 [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) 问题的题解中我就是通过排序后邻接去重实现同一层去重剪枝的。

放置法按 “第 `len` 个元素” 来递进，层语义是元素序而非位置序，即我们知道已经填充了 `len` 个元素，不过构造字符串中具体哪些位置被填充需要通过 `used` 数组获取；另一种经典实现同层去重则属于 “按位置顺序填充” 的模型，当我们填入了 `len` 个元素，那么就可以确定构造字符串的前 `len` 个元素已被填充，此时 `used` 维护的是原数组中的元素是否被使用。

放置法要求相同值的拷贝在结果中的位置编号（编号可以考虑为在原数组中的索引）严格递增，这是放置法的核心不变式，通过唯一的递增编号确保不重复计数；同层去重则在搜索树上对同一层的重复值分支只考虑选择一个继续递归（常见的比如选取首个重复元素），对于其他重复值则直接剪枝，不再继续递归，从而确保了最终完成整个递归调用、到达叶子节点找到解的分支是唯一的、不重复的。

可以看到，同层去重的方法的剪枝直接体现在了搜索树上，而放置法的剪枝更多体现在逻辑上确保唯一性。

同层去重的示意图与代码实现可以参考我在 [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) 题解中给出的结果，尽管那是组合问题，但很容易直接改为排列。

# 代码

```java
class Solution {

    private char[] path;
    private char[] goods;
    private boolean[] used;
    private List<String> res;
    private int N;

    public String[] goodsOrder(String goods) {
        this.goods = goods.toCharArray();
        Arrays.sort(this.goods);
        N = goods.length();
        path = new char[N];
        res = new ArrayList<>();
        used = new boolean[N];
        dfs(0, -1);
        return res.toArray(new String[0]);
    }

    private void dfs(int len, int prev) {
        if (len == N) {
            res.add(new String(path));
            return;
        }

        int start = prev >= 0 && path[prev] == goods[len] ? prev + 1 : 0;
        for (int i = start; i < N; i++) {
            if (!used[i]) {
                used[i] = true;
                path[i] = goods[len];
                dfs(len + 1, i);
                used[i] = false;
            }
        }
    }
}
```

