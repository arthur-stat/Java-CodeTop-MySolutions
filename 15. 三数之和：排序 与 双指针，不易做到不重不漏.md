题目简述：

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
>
> **注意：**答案中不可以包含重复的三元组。

题目链接：[15. 三数之和](https://leetcode.cn/problems/3sum/)

# 思路

> 一个经典的双指针算法的问题。
>
> 一般来说，数组本身有序时常考虑相向双指针，而同向双指针一般是考虑快慢指针或滑动窗口。

这个问题算是两数之和的plus版本，但思路完全不一样。如果蛮力扫描搜索时间复杂度为 $O(N^3)$，这是不可接受的。

简而言之地概况，整体上思路是“排序 + 双指针”。

首先是排序，这里可以提前透露，本算法的时间复杂度为 $O(N^2)$，因此排序带来的 $O(N\log N)$ 时间复杂度是完全可以接受的，因为可以帮我们方便地使用双指针。因此我们先排序，让数组变得有序。

对排序后的有序数组我们遍历该数组，假设当前访问到 `cur` 索引，接下来我们需要（在嵌套内循环中使用）两个索引指针 `left` 与 `right` 用以搜索可能的解。`left` 与 `right` 均大于等于 `cur`，并且 `right` 大于 `left`。三者应遵循以下规则：

- 对一个新访问的 `cur`，`left` 初始化为 `cur + 1`、`right` 初始化为 `N - 1`；
- 检查 `nums[cur] + nums[left] + nums[right]`，记该值为 `sum`，
  - 如果 `sum = 0`，则记录三元数组 `[nums[cur], nums[left], nums[right]]`，随后让 `left` 自增直到指向下一个不同的元素，让 `right` 自减直到指向下一个不同的元素；
  - 如果 `sum > 0`，则让 `right` 自减直到指向下一个不同的元素；
  - 如果 `sum < 0`，则让 `left` 自增直到指向下一个不同的元素；
  - 嵌套内循环终止条件：
    - 如果 `left >= right`，则终止本次嵌套内循环的双指针搜索，随后在外层循环中让 `cur` 自增直到指向下一个不同的元素；
    - 如果 `nums[cur] + nums[left] > 0`，则必然有 `sum >= nums[cur] + nums[left] > 0`，这时 `cur` 与双指针 `left`、`right` 指向元素的三数之和必然不可能为 0，并且 `cur` 自增、`left` 自增或 `right` 自减均只会使得 `sum` 更大，因此可以提前结束嵌套内循环；
- 外循环终止条件：
  - 当 `cur >= N - 2`，终止外层循环的遍历；
  - 如果 `nums[cur] > 0`，则必然有 `sum >= nums[cur] > 0`，这时 `cur` 与双指针 `left`、`right` 指向元素的三数之和必然不可能为 0，并且 `cur` 自增、`left` 自增或 `right` 自减均只会使得 `sum` 更大，因此可以提前结束外层循环的遍历，返回最终结果。

为了使设计的代码更可读，可选择外层循环用 for 循环遍历所有可能的 `cur`、内层循环用 while 循环精确控制双指针的方式，但内层循环只有在 `cur` 指向下一个不同元素时才应激活，否则 `continue;`。

# 总结

这个问题的难点可以被总结为：

1. $O(N^2)$ 时间复杂度；
2. 需要意识到先进行排序能够简化问题，帮助我们实现 $O(N^2)$ 时间复杂度；
3. 不重不漏。仅仅是不重就多出来许多额外的逻辑了，要在不重的前提下实现不漏难度只会更大。

# 代码

> 这份代码是我在半年后重写的，与上文的「思路」可能并不能一一对应。但其实现思路一定是比原代码更好的。

算法的时间复杂度为 $O(n^2)$，空间复杂度取决于所使用的排序算法。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();

        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int j = i + 1;
            int k = n - 1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum < 0) {
                    while (j < k && nums[j] == nums[j + 1]) {
                        j++;
                    }
                    j++;
                } else if (sum > 0) {
                    while (k > j && nums[k] == nums[k - 1]) {
                        k--;
                    }
                    k--;
                } else {
                    res.add(List.of(nums[i], nums[j], nums[k]));
                    while (j < k && nums[j] == nums[j + 1]) {
                        j++;
                    }
                    j++;
                }
            }
        }
        return res;
    }
}
```

