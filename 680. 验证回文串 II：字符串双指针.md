题目简述：

> 给你一个字符串 `s`，**最多** 可以从中删除一个字符。
>
> 请你判断 `s` 是否能成为回文字符串：如果能，返回 `true` ；否则，返回 `false` 。

题目链接：[680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/)

# 思路

双指针，从字符串的两端开始以步长 1 向内逐渐收拢。如果两指针所指向的字符是一样的，则认为当前匹配成功。

允许有一次失配的机会，当发生失配——即匹配失败时，可以选择丢弃左指针的元素——左指针加一，或者丢弃右指针的元素——右指针减一，于是产生两个子搜索。当花掉失配机会后，如果两个子搜索最终至少有一个返回 `true`，则主搜索返回 `true`，否则返回 `false`。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean validPalindrome(String s) {
        int n = s.length();
        int i = 0;
        int j = n - 1;
        while (i < j) {
            if (s.charAt(i) == s.charAt(j)) {
                i++;
                j--;
            } else {
                return subvalidPalindrome(s, i + 1, j) || subvalidPalindrome(s, i, j - 1);
            }
        }
        return true;
    }

    private boolean subvalidPalindrome(String s, int start, int end) {
        int i = start;
        int j = end;
        while (i < j) {
            if (s.charAt(i) == s.charAt(j)) {
                i++;
                j--;
            } else {
                return false;
            }
        }
        return true;
    }
}
```

