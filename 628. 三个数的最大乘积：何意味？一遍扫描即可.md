题目简述：

> 给你一个整型数组 `nums` ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

题目链接：[628. 三个数的最大乘积](https://leetcode.cn/problems/maximum-product-of-three-numbers/)

# 思路

这个问题乍一看让人想起 [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)，但定睛一看显然并不需要动态规划。

如果数组中不存在负数，最大的三数之积当然就是顺序最大的三个数的乘积。

数组中存在负数时，不必动态规划维护负数积最大值，因为这里限定了只选取三个数，那么除了顺序最大的三个数的乘积，最大乘积也可能是最小的两个负数之积再乘最大正数之积。因为两个负数的积等于两个负数各自相反数的积，所以如果只要存在至少两个负数，那么两个负数就可以被视为正数，这时就等价于数组中不存在负数的情况了。当然，一次三数之积的计算中这样的 “等价” 只能发生零次或两次。

不难证明，对于更一般的情况，比如数组全为负数，也是如此，结论仍成立。

因此，只有两种情况可能产生最大的三数之积：

1. 顺序最大的三个数
2. 顺序最小的两个数与顺序最大的三个数

于是一次遍历，保存数组最大的三个数和最小的两个数即可。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int maximumProduct(int[] nums) {
        int[] max3 = new int[3];
        int[] min2 = new int[2];
        Arrays.fill(max3, Integer.MIN_VALUE);
        Arrays.fill(min2, Integer.MAX_VALUE);
        for (int num : nums) {
            max3update(max3, num);
            min2update(min2, num);
        }
        int res1 = max3[0] * max3[1] * max3[2];
        int res2 = min2[0] * min2[1] * max3[2];
        return Math.max(res1, res2);
    }

    private void max3update(int[] max3, int num) {
        if (num >= max3[2]) {
            max3[0] = max3[1];
            max3[1] = max3[2];
            max3[2] = num;
        } else if (num >= max3[1]) {
            max3[0] = max3[1];
            max3[1] = num;
        } else if (num > max3[0]) {
            max3[0] = num;
        }
    }

    private void min2update(int[] min2, int num) {
        if (num <= min2[0]) {
            min2[1] = min2[0];
            min2[0] = num;
        } else if (num < min2[1]) {
            min2[1] = num;
        }
    }
}
```

