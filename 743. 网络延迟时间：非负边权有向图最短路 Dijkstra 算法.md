题目简述：

> 有 `n` 个网络节点，标记为 `1` 到 `n`。
>
> 给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

题目链接：[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

# Dijkstra 算法

Dijkstra 算法是适用于非负权有向图最短路的算法，能够找出从单个起点开始至每个阶段的最短路径。

> 无权图最短路直接考虑 BFS 即可，对于无权图不会有效率更高的算法；此外，Dijkstra 算法不能直接用于存在负权重的有向图，这种情况可以考虑基于 Dijkstra 改进的 Bellman-Ford 算法。
>
> A* 算法是 Dijkstra 算法的启发式改进版本。

Dijkstra 算法是一种使用贪心策略的算法，其流程为：

1. 准备距离表 `distance` 与尚未确定最短路的点集合 `unsearched`，初始化距离表中起点为 `0`、其他点为无穷大（代表未知），初始化 `uncertain` 为所有点的集合，包括起点；
2. 贪心策略：从 `uncertain` 中取出已知最短路距离的点中距离最小的点，记该点为 `a`，将该点从 `uncertain` 中移除；
3. 如果无法找出这样一个 `a`，即 `uncertain` 中所有点的距离均为无穷大，则可以宣布我们找出了单源起点到所有点的最短路径，现在 `uncertain` 中剩下的点就是该起点的不可达点，算法终止；
4. 松弛操作：进行一步探索，访问 `a` 的所有邻居，对于邻居 `b`，若距离表中记录的起点至 `a` 的距离加上 `a` 至 `b` 的一步距离小于表中记录的起点至 `b` 的距离，则更新距离表 `distance`。即：若满足 `distance(a) + weight(a, b) < distance(b)`，则更新 `distance(b)` 为 `distance(a) + weight(a, b)`；
5. 如果 `uncertain` 非空，则回到第二步重复流程；否则可以宣布我们找出了单源起点到所有点的最短路径，并且该起点可达至任意处，算法终止。

注意：对于有向图中的一个起点可能存在其不可达点，此时算法将会在第二步（贪心）与第四步（松弛）之间结束。

# 代码

```java
class Dijkstra {
    public static Map<Integer, Integer> SPP(int[][] weights, int start) {
        // 初始化邻接表 adj 与所有点集合 uncertain
        Set<Integer> uncertain = new HashSet<>();
        Map<Integer, List<Pair>> adj = new HashMap<>();

        for (int[] w : weights) {
            List<Pair> list = adj.computeIfAbsent(w[0], key -> new ArrayList<>());
            list.add(new Pair(w[1], w[2]));
            uncertain.add(w[0]);
            uncertain.add(w[1]);
        }
        
        Map<Integer, Integer> distance = new HashMap<>(adj.size());
        for (int i : uncertain) {
            distance.put(i, (i == start) ? 0 : Integer.MAX_VALUE);
        }

        // Dijkstra 算法主体
        while (!uncertain.isEmpty()) {
            // 贪心
            Integer minOne = null;
            Integer minDist = Integer.MAX_VALUE;
            for (Integer u : uncertain) {
                if (distance.get(u) < minDist) {
                    minOne = u;
                    minDist = distance.get(u);
                }
            }
            uncertain.remove(minOne);
            if (minOne == null) return distance;

            // 松弛
            int dist = distance.get(minOne);
            List<Pair> list = adj.get(minOne);
            if (list == null) continue;
            for (Pair p : list) {
                if (dist + p.weight < distance.getOrDefault(p.next, Integer.MAX_VALUE)) {
                    distance.put(p.next, dist + p.weight);
                }
            }
        }

        return distance;
    }

    // 封装邻居与权重
    private static class Pair {

        public final int next;
        public final int weight;

        public Pair(int next, int weight) {
            this.next = next;
            this.weight = weight;
        }
    }
}

class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer, Integer> dist = Dijkstra.SPP(times, k);
        int res = Collections.max(dist.values());
        if (n > dist.size()) return -1;
        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
```

