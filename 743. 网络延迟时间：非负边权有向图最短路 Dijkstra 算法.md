题目简述：

> 有 `n` 个网络节点，标记为 `1` 到 `n`。
>
> 给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

题目链接：[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

# Dijkstra 算法

Dijkstra 算法是适用于非负权有向图最短路的算法，能够找出从单个起点开始至每个阶段的最短路径。

> 无权图最短路直接考虑 BFS 即可，对于无权图不会有效率更高的算法；此外，Dijkstra 算法不能直接用于存在负权重的有向图，这种情况可以考虑基于 Dijkstra 改进的 Bellman-Ford 算法。
>
> A* 算法是 Dijkstra 算法的启发式改进版本。

Dijkstra 算法是一种使用贪心策略的算法，其流程为：

1. 准备距离表 `distance` 与尚未确定最短路的点集合 `unsearched`，初始化距离表中起点为 `0`、其他点为无穷大（代表未知），初始化 `uncertain` 为所有点的集合，包括起点；
2. ***贪心策略***：从 `uncertain` 中取出已知最短路距离的点中距离最小的点，记该点为 `a`，将该点从 `uncertain` 中移除；
3. 如果无法找出这样一个 `a`，即 `uncertain` 中所有点的距离均为无穷大，则可以宣布我们找出了单源起点到所有点的最短路径，现在 `uncertain` 中剩下的点就是该起点的不可达点，算法终止；
4. ***松弛操作***：进行一步探索，访问 `a` 的所有邻居，对于邻居 `b`，若距离表中记录的起点至 `a` 的距离加上 `a` 至 `b` 的一步距离小于表中记录的起点至 `b` 的距离，则更新距离表 `distance`。即：若满足 `distance(a) + weight(a, b) < distance(b)`，则更新 `distance(b)` 为 `distance(a) + weight(a, b)`；
5. 如果 `uncertain` 非空，则回到第二步重复流程；否则可以宣布我们找出了单源起点到所有点的最短路径，并且该起点可达至任意处，算法终止。

> 注意：对于有向图中的一个起点可能存在其不可达点，此时算法将会在第二步（贪心）与第四步（松弛）之间结束。

可见，Dijkstra 算法本质上是一种***使用优先队列（优先取出最短距离的节点）（从而结合贪心策略的）改良版本的 BFS***。

并不需要花费时间专门去记忆 Dijkstra 算法的具体流程，只要记得 Dijkstra 算法实际上是考虑优先队列的 BFS，那么就不难推导出 Dijkstra 算法的思路。贪心的思想正体现在优先队列这一数据结构上。

# 代码

下述 Dijkstra 算法实现的时间复杂度为 $O\big((V+E)\log V\big)$、空间复杂度为 $O(V+E)$，其中 $V$ 是顶点（节点）的数量，$E$ 是边的数量。

```java
class Dijkstra {
    public static Map<Integer, Integer> SPP(int[][] weights, int start) {
        // 初始化邻接表 adj、优先队列与距离表
        Map<Integer, List<Node>> adj = new HashMap<>();
        PriorityQueue<Dist> pq = new PriorityQueue<>();
        Map<Integer, Integer> distance = new HashMap<>(adj.size());

        for (int[] w : weights) {
            List<Node> list = adj.computeIfAbsent(w[0], key -> new ArrayList<>());
            list.add(new Node(w[1], w[2]));
            distance.put(w[0], (w[0] == start) ? 0 : Integer.MAX_VALUE);
            distance.put(w[1], (w[1] == start) ? 0 : Integer.MAX_VALUE);
        }

        pq.offer(new Dist(start, 0));

        // Dijkstra 算法主体
        while (!pq.isEmpty()) {
            // 贪心
            Dist minOne = pq.poll();
            int dist = minOne.dist;
            if (dist > distance.get(minOne.node)) continue;

            // 松弛
            List<Node> list = adj.get(minOne.node);
            if (list == null) continue;
            for (Node p : list) {
                if (dist + p.weight < distance.getOrDefault(p.next, Integer.MAX_VALUE)) {
                    distance.put(p.next, dist + p.weight);
                    pq.offer(new Dist(p.next, dist + p.weight));
                }
            }
        }

        return distance;
    }

    // 封装邻居与权重
    private static class Node {

        public final int next;
        public final int weight;

        public Node(int next, int weight) {
            this.next = next;
            this.weight = weight;
        }
    }

    // 封装节点与距离（以支持贪心策略的优先队列）
    private static class Dist implements Comparable<Dist> {

        public final int node;
        public final int dist;

        public Dist(int node, int dist) {
            this.node = node;
            this.dist = dist;
        }

        @Override
        public int compareTo(Dist o) {
            return Integer.compare(this.dist, o.dist);
        }
    }
}

class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer, Integer> dist = Dijkstra.SPP(times, k);
        int res = Collections.max(dist.values());
        if (n > dist.size()) return -1;
        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
```
