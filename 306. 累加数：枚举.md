题目简述：

> **累加数** 是一个字符串，组成它的数字可以形成累加序列。
>
> 一个有效的 **累加序列** 必须 **至少** 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。
>
> 给你一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是 **累加数** 。如果是，返回 `true` ；否则，返回 `false` 。
>
> **说明：**累加序列里的数，除数字 0 之外，**不会** 以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。
>
> **进阶：**你计划如何处理由过大的整数输入导致的溢出?

题目链接：[306. 累加数](https://leetcode.cn/problems/additive-number/)

# 思路

枚举前两个数字即可。

Java 中，如果需要大数的四则运算可以考虑 `java.math.BigInteger` 类，不必从 0 写字符串加法。

阅读源码可以知道，Java 的 `java.math.BigInteger` 实现并非封装了一层字符串，其底层是被解释为二进制位的大进制数组 `int[]`（外加一个 `int` 变量表示符号），整个数组被解释一个 word array。相较字符串解释，显然这一实现效率更高，而且也便于支持更多的运算。

# 代码

```java
import java.math.BigInteger;

class Solution {
    public boolean isAdditiveNumber(String num) {
        int n = num.length();
        for (int len1 = 1; len1 <= n - 2; len1++) {
            for (int len2 = 1; len1 + len2 <= n - 1; len2++) {
                
                String strA = num.substring(0, len1);
                if (!checkPrefixZeros(strA)) continue;
                BigInteger a = new BigInteger(strA);

                String strB = num.substring(len1, len1 + len2);
                if (!checkPrefixZeros(strB)) continue;
                BigInteger b = new BigInteger(strB);
                
                int start = len1 + len2;

                while (true) {
                    BigInteger c = a.add(b);
                    String s = c.toString();
                    if (start + s.length() > n) break;
                    if (s.equals(num.substring(start, start + s.length()))) {
                        a = b;
                        b = c;
                        start += s.length();
                    } else {
                        break;
                    }
                }
                if (start == n) return true;
            }
        }

        return false;
    }

    private boolean checkPrefixZeros(String number) {
        return !(number.startsWith("0") && number.length() > 1);
    }
}
```

