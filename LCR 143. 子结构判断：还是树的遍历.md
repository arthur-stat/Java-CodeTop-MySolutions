题目简述：

> 给定两棵二叉树 `tree1` 和 `tree2`，判断 `tree2` 是否以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。
> 注意，**空树** 不会是以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。

题目链接：[LCR 143. 子结构判断](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

# 思路

这和 [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) 有些区别，关键在于不要求一棵树具有和另一棵树一模一样的子树，而只要有一样的结构就可以了，允许该树的这一结构上具有一些另一棵树所没有的子树子结构。

那么，在进行判断时，以另一棵树为主决定是否继续 DFS 的分支即可。

# 代码

注：如果将代码中 `isSubstructure` 的

```java
        if (b == null) return true;
        if (a == null && b != null) return false;
```

改为

```java
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;
```

那么算法变成了和 [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) 相差无几的样子。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

    int b_val;
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null || B == null) return false;
        b_val = B.val;
        return forEach(A, B);
    }

    private boolean forEach(TreeNode a, TreeNode B) {
        if (a.val == b_val && isSubstructure(a, B)) return true;
        if (a.left != null && forEach(a.left, B)) return true;
        if (a.right != null && forEach(a.right, B)) return true;
        return false;
    }

    private boolean isSubstructure(TreeNode a, TreeNode b) {
        if (b == null) return true;
        if (a == null && b != null) return false;
        if (a.val != b.val) return false;
        return isSubstructure(a.left, b.left) && isSubstructure(a.right, b.right);
    }
}
```
