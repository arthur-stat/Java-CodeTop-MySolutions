题目简述：

> 给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。
>
> 另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。
>
> 返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。
>
> **注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。
>
> **注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

题目链接：[399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

# 图的遍历

## 思路

众所周知，
$$
\frac{A}{B}\times\frac{B}{C}=\frac{A}{C}
$$
所以能否给出 `queries` 中算式 $\frac{a_1}{a_m}$ 的答案，取决于我们能否找到形如 $\prod\limits^{m-1}_{i=1}\frac{a_i}{a_{i+1}}$ 的链式数对组合，且这一条件是充要的。

> 并不需要去解出未知数，甚至于考虑线性代数哦！

如果我们把分子与分母组成的数对视为一个节点，则该节点的邻居节点是已知的（即邻接表是已知的）。那么现在如何设计算法就很简单了，考虑记忆化搜索找出所有可能的化简后的数对组合结果。

实际上可以考虑 BFS 或 DFS 的形式遍历化简后的数对组合结果所组成的图，通过记忆化避免重复访问节点从而解决循环依赖。

思路是很直白的，具体实现请结合代码理解。例如，为了加速寻找合法的链式数对组合，我们使用哈希表记录分子到数对的映射。

一个需要注意的小细节是如果 $\frac{A}{B}$ 是已知的，那么 $\frac{B}{A}=\frac{1}{\frac{A}{B}}$ 也是已知的，因此需要将相反数也考虑进潜在的数对组合中。

## 代码

这里给出 BFS 的实现。DFS 也是完全可行的。

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String, List<Node>> map = new HashMap<>();  // f1 → Node，实际上为图的邻接表
        Map<String, Node> visited = new HashMap<>();
        Deque<Node> queue = new ArrayDeque<>();

        // init
        for (int i = 0; i < equations.size(); i++) {
            List<String> pair = equations.get(i);

            Node node1 = new Node(pair.get(0), pair.get(1), values[i]);
            visited.put(node1.f1() + '|' + node1.f2(), node1);
            map.computeIfAbsent(pair.get(0), key -> new ArrayList<>()).add(node1);
            queue.offer(node1);

            Node node2 = new Node(pair.get(1), pair.get(0), 1.0 / values[i]);
            visited.put(node2.f1() + '|' + node2.f2(), node2);
            map.computeIfAbsent(pair.get(1), key -> new ArrayList<>()).add(node2);
            queue.offer(node2);
        }

        while (!queue.isEmpty()) {
            Node node = queue.poll();

            List<Node> list1 = map.get(node.f1());
            int m = list1.size();

            for (int i = 0; i < m; i++) {
                Node next = list1.get(i);
                Node newNode = new Node(node.f1(), next.f2(), node.res() * next.res());
                Node res = visited.putIfAbsent(newNode.f1() + '|' + newNode.f2(), newNode);

                if (res == null) {
                    map.computeIfAbsent(node.f1(), key -> new ArrayList<>()).add(newNode);
                    queue.offer(newNode);
                }
            }

            List<Node> list2 = map.get(node.f2());
            int n = list2.size();

            for (int i = 0; i < n; i++) {
                Node next = list2.get(i);
                Node newNode = new Node(node.f1(), next.f2(), node.res() * next.res());
                Node res = visited.putIfAbsent(newNode.f1() + '|' + newNode.f2(), newNode);

                if (res == null) {
                    map.computeIfAbsent(node.f1(), key -> new ArrayList<>()).add(newNode);
                    queue.offer(newNode);
                }
            }
        }

        double[] answer = new double[queries.size()];
        for (int i = 0; i < answer.length; i++) {
            List<String> pair = queries.get(i);
            Node node = visited.get(pair.get(0) + '|' + pair.get(1));
            if (node != null) {
                answer[i] = node.res();
            } else {
                answer[i] = -1;
            }
        }

        return answer;
    }

    record Node(String f1, String f2, double res) {
        @Override
        public boolean equals(Object o) {
            return this == o || (o instanceof Node node) && f1.equals(node.f1()) && f2.equals(node.f2());
        }

        @Override
        public int hashCode() {
            return Objects.hash(f1, f2);
        }
    }
}
```

# Floyd-Warshall 算法

## 算法分析

本问题也可以建模为分子或分母作为节点构成的图（而不再是分子和分母组成的数对作为节点），因此还可以考虑计算点对最短路，进而适用于 Floyd-Warshall 算法。

Floyd-Warshall 算法是一种用于计算所有顶点对之间的最短路的算法，适用于带权有向图或无向图中不存在负权环的场景。这里要与 Dijkstra 算法以及其支持负权边的改进版本 Bellman-Ford 算法相区分：Floyd-Warshall 算法是一次性计算所有点对最短路的算法，而 Dijkstra 算法与 Bellman-Ford 算法是计算单源最短路的算法。

Dijkstra 算法与 Bellman-Ford 算法可以被视为是通过优先队列结合贪心策略的 BFS，而 Floyd-Warshall 算法则更多（或者所更加显著地）体现动态规划的思想。

首先设 $dp[i][j]$ 表示节点 $i$ 到节点 $j$ 的已知最短距离，初始化 $dp$ 表：

- $\forall i,\ dp[i][i]=0$；
- 如果 $i$ 与 $j$ 相邻且权重为 $w_{ij}$，则 $dp[i][j]=w_{ij}$；
- 否则初始化 $dp[i][j]=+\infty$，表示暂不可达。

然后在一个三重循环中更新 $dp$ 表，考虑下述状态转移转移方程：
$$
dp[i][j]=\min\big\{dp[i][k]+dp[k][j]:\forall k\big\}
$$
三重循环用 Python 伪代码表示是

```python
for k in range(0, n):
    for i in range(0, n):
        for j in range(0, n):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
```

<u>这里一定要注意 $k$ 在最外层的循环，而不是最内层。</u>

## 算法实现

Floyd-Warshall 算法的时间复杂度为 $O(|V|^3+|E|)$，空间复杂度为 $O(|V|^2)$，其中 $V$ 表示顶点集，$E$ 表示边集。

```java
/* 当然本问题需要计算比式的值，因此这里只给出标准的 Floyd-Warshall 算法，求解本问题不会用到这个实现 */
class Floyd {
    /* Floyd-Warshall algorithm */
    public static <T> Map<List<T>, Integer> solve(Map<List<T>, Integer> weights) {
        Map<List<T>, Integer> dp = new HashMap<>();
        Set<T> nodes = new HashSet<>();

        // init
        for (var entry : weights.entrySet()) {
            List<T> pair = entry.getKey();
            T i = pair.get(0);
            T j = pair.get(1);
            nodes.add(i);
            nodes.add(j);
            dp.put(List.of(i, j), entry.getValue());
        }

        for (T i : nodes) {
            for (T j : nodes) {
                if (i.equals(j)) dp.put(List.of(i, j), 0);
                else dp.putIfAbsent(List.of(i, j), Integer.MAX_VALUE / 2);
            }
        }

        // DP: Triple nested loop
        for (T k : nodes) {
            for (T i : nodes) {
                for (T j : nodes) {
                    List<T> key = List.of(i, j);
                    dp.put(key, Math.min(dp.get(key), dp.get(List.of(i, k)) + dp.get(List.of(k, j))));
                }
            }
        }

        return dp;
    }
}

/* 这才是求解「399. 除法求值」的方法 */
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String, Double> ratio = new HashMap<>();     // pair to ratio
        Set<String> nodes = new HashSet<>();

        for (int i = 0; i < equations.size(); i++) {
            List<String> pair = equations.get(i);
            ratio.put(pair.get(0) + "->" + pair.get(1), values[i]);
            ratio.put(pair.get(1) + "->" + pair.get(0), 1.0 / values[i]);
            nodes.add(pair.get(0));
            nodes.add(pair.get(1));
        }

        // for (String node : nodes) ratio.put(node + "->" + node, 1.0);

        /* 令 Floyd-Warshall 算法在计算点对最短路的同时计算 values */
        for (String k : nodes) {
            for (String i : nodes) {
                for (String j : nodes) {
                    if (ratio.containsKey(i + "->" + k) && ratio.containsKey(k + "->" + j)) {
                        ratio.putIfAbsent(i + "->" + j, ratio.get(i + "->" + k) * ratio.get(k + "->" + j));
                    }
                }
            }
        }

        double[] res = new double[queries.size()];
        for (int i = 0; i < res.length; i++) {
            List<String> pair = queries.get(i);
            String start = pair.get(0);
            String end = pair.get(1);
            res[i] = ratio.getOrDefault(start + "->" + end, -1.0);
        }

        return res;
    }
}
```

# 带权并查集

## 思路

还可以考虑带权并查集。如果 `parent(a1) = an`，则我们认为存在式子 $\frac{a_1}{a_2}\times\frac{a_2}{a_3}\times\cdots\times\frac{a_{n-1}}{a_n}=\frac{a_1}{a_n}$，并且 $\{a_i\}$ 均属于同一并查集。

对于同一并查集内的元素，我们选取代表元 $root$ 的值作为基准（尽管这个值具体是多少我们是不清楚的），记录该并查集内各元素与 $root$ 的比值，这样：

- 如果 $a$ 与 $b$ 不在同一并查集，即 $root_a\neq root_b$，则 $\frac{a}{b}$ 与 $\frac{b}{a}$ 无解；
- 如果 $a$ 与 $b$ 在同一并查集内，即 $root_a=root_b$，则 $\frac{a}{b}=\frac{a}{root}\times\frac{root}{b}$，$\frac{b}{a}=\frac{1}{\frac{a}{b}}$。

为此，我们需要维护每个根节点到其子节点的比例关系，使用哈希表 `ratio` 记录每个节点相对于其父节点的比值。在 `find` 进行路径压缩时同时更新比例值，确保每个节点直接指向根节点，并计算该节点相对于根节点的累积比例。

## 代码

```java
class Solution {

    private static class UnionFind<T> {

        private Map<T, T> parent = new HashMap<>();
        private Map<T, Integer> rank = new HashMap<>();
        private Map<T, Double> ratio = new HashMap<>();

        UnionFind(List<List<T>> equations, double[] values) {
            for (int i = 0; i < equations.size(); i++) {
                List<T> pair = equations.get(i);
                T a = pair.get(0);
                T b = pair.get(1);
                double value = values[i];
                
                parent.putIfAbsent(a, a);
                parent.putIfAbsent(b, b);
                ratio.putIfAbsent(a, 1.0);
                ratio.putIfAbsent(b, 1.0);
                rank.putIfAbsent(a, 0);
                rank.putIfAbsent(b, 0);
                
                union(a, b, value);
            }
        }

        public T find(T e) {
            if (!parent.get(e).equals(e)) {
                T originalParent = parent.get(e);
                T root = find(originalParent);
                double originalRatio = ratio.get(e);
                double parentRatio = ratio.get(originalParent);
                
                parent.put(e, root);
                ratio.put(e, originalRatio * parentRatio);
            }
            return parent.get(e);
        }

        public void union(T a, T b, double value) {
            T rootA = find(a);
            T rootB = find(b);
            
            if (rootA.equals(rootB)) {
                return;
            }
            
            int rankA = rank.get(rootA);
            int rankB = rank.get(rootB);
            double ratioA = ratio.get(a);
            double ratioB = ratio.get(b);
            double newRatio = value * ratioB / ratioA;
            
            if (rankA < rankB) {
                parent.put(rootA, rootB);
                ratio.put(rootA, newRatio);
            } else if (rankA > rankB) {
                parent.put(rootB, rootA);
                ratio.put(rootB, 1.0 / newRatio);
            } else {
                parent.put(rootA, rootB);
                ratio.put(rootA, newRatio);
                rank.put(rootB, rankB + 1);
            }
        }

        public double query(T a, T b) {
            if (!parent.containsKey(a) || !parent.containsKey(b)) return -1.0;
            
            T rootA = find(a);
            T rootB = find(b);
            if (!rootA.equals(rootB)) return -1.0;
            
            double ratioA = ratio.get(a);
            double ratioB = ratio.get(b);
            return ratioA / ratioB;
        }
    }

    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        UnionFind<String> uf = new UnionFind<>(equations, values);
        double[] results = new double[queries.size()];
        
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String a = query.get(0);
            String b = query.get(1);
            results[i] = uf.query(a, b);
        }
        
        return results;
    }
}
```

