题目简述：

> 你的面前有一堵矩形的、由 `n` 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。
>
> 你现在要画一条 **自顶向下** 的、穿过 **最少** 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。**你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。**
>
> 给你一个二维数组 `wall` ，该数组包含这堵墙的相关信息。其中，`wall[i]` 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 **穿过的砖块数量最少** ，并且返回 **穿过的砖块数量** 。

题目链接：[554. 砖墙](https://leetcode.cn/problems/brick-wall/)

# 思路

原本我的思路是：使用一个数组 `crack` 记录累计至第 $i$ 层的纵向缝隙总数，其中 `crack[j]` 表示累计至第 $i$ 层时第 $j$ 列的纵向缝隙总数，这样当我们遍历完输入 `wall` 后，`crack` 就记录了每一列上纵向缝隙的总数。于是，我们取其中最多的纵向缝隙数，再用 `wall.size()`——即砖块总层数减去最多的纵向缝隙数，就得到了纵向画一条线所需要穿过的最少砖块数。

按照这一思路，我实现的代码是这样的：

```java
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        int width = 0;
        for (int b : wall.get(0)) width += b;
        int[] crack = new int[width + 1];

        for (List<Integer> brick : wall) {
            int w = 0;
            for (int b : brick) {
                w += b;
                crack[w]++;
            }
        }

        int maxCrackNum = 0;
        for (int i = 1; i < width; i++) maxCrackNum = Math.max(maxCrackNum, crack[i]);
        return wall.size() - maxCrackNum;
    }
}
```

代码本身能够通过许多测试用例，但是面对剩下的一些测试用例，比如 `[[100000000],[100000000],[100000000]]`，会超出内存限制……想来，应该是砖墙的宽度 `width`，即每一层砖块长度之和，太大了，而我们初始化 `crack` 数组时是直接考虑到每一列的，因此 `crack` 数组的长度也为 `width`。显然，当 `width` 的数字太大时，数组也会变得非常庞大。

解决这个问题的办法是改 `crack` 从数组至哈希表，只记录至少存在一个缝隙的列，而不是初始化时就考虑到每一列。这样，其余的逻辑均不需要修改。算法便能 AC。

# 代码

算法的时间复杂度为 $O(B)$，空间复杂度为 $O(B)$，其中 $B$ 是砖块的总数。

```java
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        long width = 0;
        for (int b : wall.get(0)) width += b;
        Map<Long, Integer> crack = new HashMap<>();

        for (List<Integer> brick : wall) {
            long w = 0;
            for (int b : brick) {
                w += b;
                if (w < width) crack.merge(w, 1, Integer::sum);
            }
        }

        int maxCrackNum = 0;
        for (Map.Entry<Long, Integer> entry : crack.entrySet()) {
            maxCrackNum = Math.max(maxCrackNum, entry.getValue());
        }
        return wall.size() - maxCrackNum;
    }
}
```

