题目简述：

> Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，**排成一行**；每堆都有 **正** 整数颗石子，数目为 `piles[i]` 。
>
> 游戏以谁手中的石子最多来决出胜负。石子的 **总数** 是 **奇数** ，所以没有平局。
>
> Alice 和 Bob 轮流进行，**Alice 先开始** 。 每回合，玩家从行的 **开始** 或 **结束** 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 **石子最多** 的玩家 **获胜** 。
>
> 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 `true` ，当 Bob 赢得比赛时返回 `false` 。

题目链接：[877. 石子游戏](https://leetcode.cn/problems/stone-game/)

# 思路

这个问题与 [486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/) 没有本质上的区别，都是完全信息无随机零和博弈问题，就连问题形式都相似：每个玩家每次在剩余数组中选择首或尾以获得积分，考虑记忆化搜索或区间 DP。这是因为，由于两个玩家都 “发挥出最佳水平”，因此只要当前剩余的石子堆是确定的，那么最终一个玩家比另一个玩家能获得的更多的石头数量就是确定的。

更具体的分析可以看看我在 [486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/) 的题解中给出的内容，与本问题是通用的。

# 记忆化搜索

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        // 剩余石子堆区间下 Alice 能获得的更多石头数
        Map<Long, Integer> cache = new HashMap<>();
        dfs(cache, piles, 0, piles.length - 1);
        return cache.get((long) (piles.length - 1)) > 0;
    }

    // 返回当前玩家最多能获得多少个更多的石子 (当前玩家是谁能通过 j - i 的奇偶性唯一确定)
    private int dfs(Map<Long, Integer> cache, int[] piles, int i, int j) {
        long interval = ((long) i << 32) | (j & 0xffffffffL);
        if (i == j) return piles[i];
        Integer res = cache.get(interval);
        if (res != null) return res;

        int r1 = piles[i] - dfs(cache, piles, i + 1, j);
        int r2 = piles[j] - dfs(cache, piles, i, j - 1);
        int r = Math.max(r1, r2);
        cache.put(interval, r);
        return r;
    }
}
```

# 动态规划

设 $dp[i][j]$ 表示索引数组中闭区间 $[i,j]$ 对应的石子堆还未被选走时，当前玩家能够获得的最大的更多石子数量，则
$$
dp[i][j]=\max\big\{piles[i]-dp[i+1][j],\ piles[j]-dp[i][j-1]\big\}
$$
算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int n = piles.length;
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) dp[i][i] = piles[i];

        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
            }
        }

        return dp[0][n - 1] > 0;
    }
}
```

使用滚动数组将空间复杂度降低至 $O(n)$。

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int n = piles.length;
        int[] dp = new int[n];

        for (int i = n - 1; i >= 0; i--) {
            dp[i] = piles[i];
            for (int j = i + 1; j < n; j++) {
                dp[j] = Math.max(piles[i] - dp[j], piles[j] - dp[j - 1]);
            }
        }

        return dp[n - 1] > 0;
    }
}
```
