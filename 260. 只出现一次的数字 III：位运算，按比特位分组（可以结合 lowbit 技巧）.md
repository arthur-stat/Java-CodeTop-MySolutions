题目简述：

> 给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。
>
> 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

题目链接：[260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/)

# 思路

非常巧妙的一个问题，位运算用得出神入化。

由于 `nums` 中只有两个数字不同，因此经过一轮异或后，结果必然不全为比特 0，必然在某个位置上比特位为 1，这等价于那两个不同的数字在该位上比特位相反，一个为 0，一个为 1。那么，我们再次遍历数组，在这次遍历时对该比特位按是 0 还是 1 进行二分分组，这样就保证了最终结果一定被分为两组，且每个组中各只包含一个不重复数字，于是问题转为了两个 [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 小问题。最终再次遍历，分别对两个组按位异或，就能够找出那两个不重复的数字。

由于只允许使用常数级别的额外空间，因此我们不能显式地用两个集合进行分组。所以我们可以用两个变量分别保存两个组的异或临时结果，利用位判断组别后让当前数字选择相应的临时变量进行异或位运算即可。

---

要找到异或结果为 1 的那一个位（可能有多个，但我们只需要用到其中一个），当然可以将结果转为二进制，再逐位判断看看哪个比特位的值为 1。但我们可以用 lowbit 技巧更优雅地实现这点：对于一个二进制数 $a$，$a\land(\overline{a}+1)$ 恰等于除了值位比特 1 的最低位保持为比特 1 以外、其他位全赋为比特 0 的结果，我们称该结果为 lowbit，这里 $\land$ 表示 AND 位运算，$\overline{\ast}$ 表示 NOT 位运算。例如，我们说 110100 的 lowbit 为 000100。

对于以补码表示的整型变量 $b$，由于在计算机内 $-b=\overline{b}+1$，因此在编程时写 `b & -b` 即可得到 lowbit。

# 代码

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) xor ^= num;
        final int lowbit = xor & -xor;

        int a = 0;
        int b = 0;
        for (int num : nums) {
            int groupLabel = num & lowbit;
            if (groupLabel == 0) {
                a ^= num;
            } else if (groupLabel == lowbit) {
                b ^= num;
            } else {
                throw new RuntimeException("不应该到这个分支");
            }
        }

        return new int[]{a, b};
    }
}
```

