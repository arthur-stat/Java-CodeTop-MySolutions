题目简述：

> 给定一个长度为4的整数数组 `cards` 。你有 `4` 张卡片，每张卡片上都包含一个范围在 `[1,9]` 的数字。您应该使用运算符 `['+', '-', '*', '/']` 和括号 `'('` 和 `')'` 将这些卡片上的数字排列成数学表达式，以获得值24。
>
> 你须遵守以下规则:
>
> - 除法运算符 `'/'` 表示实数除法，而不是整数除法。
>   - 例如， `4 /(1 - 2 / 3)= 4 /(1 / 3)= 12` 。
> - 每个运算都在两个数字之间。特别是，不能使用 `"-"` 作为一元运算符。
>   - 例如，如果 `cards =[1,1,1,1]` ，则表达式 `“-1 -1 -1 -1”` 是 **不允许** 的。
> - 你不能把数字串在一起
>   - 例如，如果 `cards =[1,2,1,2]` ，则表达式 `“12 + 12”` 无效。
>
> 如果可以得到这样的表达式，其计算结果为 `24` ，则返回 `true`，否则返回 `false` 。

题目链接：[679. 24 点游戏](https://leetcode.cn/problems/24-game/)

# 思路

每次选取两个数组成无序对，考虑两数经计算后所有可能的值，然后递归即可。该无序对实际上模拟的就是小括号提升运算优先级的逻辑。

理解这一点后，本问题和 N 皇后问题一样，都是经典的回溯算法应用。

请结合代码，代码会比文字更直观。

# 代码

```java
class Solution {

    public boolean judgePoint24(int[] cards) {
        boolean[] used = new boolean[4];
        double[] cards_double = new double[4];
        for (int n = 0; n < 4; n++) {
            cards_double[n] = (double) cards[n];
        }

        return dfs(cards_double, used, 4);
    }

    private boolean dfs(double[] cards, boolean[] used, int count) {
        if (count == 1) {
            for (int n1 = 0; n1 < 4; n1++) {
                if (!used[n1]) {
                    return Math.abs(cards[n1] - 24.0) < 1e-5;
                }
            }
            // return false;
        }

        for (int n1 = 0; n1 < 4; n1++) {
            if (!used[n1]) {
                for (int n2 = n1 + 1; n2 < 4; n2++) {
                    if (!used[n2]) {
                        used[n2] = true;
                        double tmp = cards[n1];

                        cards[n1] = tmp + cards[n2];
                        if(dfs(cards, used, count - 1)) return true;
                        cards[n1] = tmp - cards[n2];
                        if(dfs(cards, used, count - 1)) return true;
                        cards[n1] = cards[n2] - tmp;
                        if(dfs(cards, used, count - 1)) return true;
                        cards[n1] = tmp * cards[n2];
                        if(dfs(cards, used, count - 1)) return true;
                        if (Math.abs(cards[n2]) > 1e-5) {
                            cards[n1] = tmp / cards[n2];
                            if(dfs(cards, used, count - 1)) return true;
                        }
                        if (Math.abs(tmp) > 1e-5) {
                            cards[n1] = cards[n2] / tmp;
                            if(dfs(cards, used, count - 1)) return true;
                        }

                        cards[n1] = tmp;
                        used[n2] = false;
                    }
                }
            }
        }

        return false;
    }
}
```

