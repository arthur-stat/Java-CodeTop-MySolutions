题目简述：

> 给定一个无序的数组 `nums`，返回 *数组在排序之后，相邻元素之间最大的差值* 。如果数组元素个数小于 2，则返回 `0` 。
>
> 您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。

题目链接：[164. 最大间距](https://leetcode.cn/problems/maximum-gap/)

# 基数排序

## 思路

最简单的思路就是直接对数组排序后检查相邻元素的最大差值。

但基于比较的排序理论时间复杂度都至少为 $O(n\log n)$，不符合问题要求的线性时间复杂度。

注意到允许使用线性额外空间，因此可以考虑基数排序——毕竟数据类型为 32 位有符号数，常数可以忽略。

可以在我的题解 “912. 排序数组：基数排序（LSD）.md” 中找到基数排序的解释，这里就不再赘述了。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int maximumGap(int[] nums) {
        sort(nums);
        int gap = 0;
        for (int i = 0; i < nums.length - 1; i++) gap = Math.max(gap, nums[i + 1] - nums[i]);
        return gap;
    }

    /* 基于二进制位的 LSD 的基数排序，适用于 32 位有符号非负整数 */
    public void sort(int[] nums) {
        int n = nums.length;
        int[] prefix = new int[256 + 1];
        int[] tmp = new int[n];

        for (int i = 0; i < 4; i++) {
            Arrays.fill(prefix, 0);

            for (int j = 0; j < n; j++) {
                prefix[(nums[j] >>> (8 * i) & 0xff) + 1]++;
            }

            for (int k = 1; k <= 256; k++) {
                prefix[k] += prefix[k - 1];
            }

            for (int j = 0; j < n; j++) {
                tmp[prefix[nums[j] >>> (8 * i) & 0xff]++] = nums[j];
            }

            int[] arr = nums;
            nums = tmp;
            tmp = arr;
        }
    }
}
```

# 分桶

## 思路

遍历扫描数组，记录数组的最大值 $M$ 与最小值 $m$，于是排序后相邻元素的平均差值为 $\frac{M-m}{n-1}$，这意味着最大的差值必然大于等于 $\frac{M-m}{n-1}$。划分出 $n-1$ 个桶，第 $k$ 个桶装入值在闭区间 $\big[m+(k-1)\cdot\frac{M-m}{n-1},m+k\frac{M-m}{n-1}\big]$ 内的元素，于是可以肯定每个桶内的任意两个元素差值均小于等于 $\frac{M-m}{n-1}$，所以他们不可能是差值最大的元素——除非所有排序后相邻元素差值均为 $\frac{M-m}{n-1}$。

 现在我们可以断言，排序后相邻元素差值的两个元素必然分别位于两个相邻的桶上，于是我们分别取每个桶的最大值与最小值，尝试用下一个桶的最小值减去当前桶的最大值以得到两个桶间的差值，最后取其中的最大者即为问题的解。

与基数排序一样地，我们不必真的实例化出桶来，只需要维护每个桶内的最大值与最小值即可。

如果还是感到困惑，可以参考 [详细解释 O(n) 分桶法（Python/Java/C++/C/Go/JS/Rust）](https://leetcode.cn/problems/maximum-gap/solutions/2772242/xiang-xi-jie-shi-on-fen-tong-fa-pythonja-mi5s/)，那里给出了具体的计算例子。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int maximumGap(int[] nums) {
        int n = nums.length;
        if (n < 2) return 0;
        if (n == 2) return Math.max(nums[0], nums[1]) - Math.min(nums[0], nums[1]);
        int numsMin = nums[0];
        int numsMax = nums[0];
        for (int num : nums) {
            numsMin = Math.min(numsMin, num);
            numsMax = Math.max(numsMax, num);
        }

        double average = (numsMax - numsMin) / (n - 1.0);
        double size = Math.ceil(average);

        int[] bucketsMin = new int[n];
        int[] bucketsMax = new int[n];
        Arrays.fill(bucketsMin, Integer.MAX_VALUE);

        for (int num : nums) {
            int bucket = (int) Math.floor((num - numsMin) / size);
            bucketsMin[bucket] = Math.min(bucketsMin[bucket], num);
            bucketsMax[bucket] = Math.max(bucketsMax[bucket], num);
        }

        int res = 0;
        int bucket = -1;
        while (true) {
            int next = bucket + 1;
            while (next < n) {
                if (bucketsMin[next] == Integer.MAX_VALUE) next++;
                else break;
            }
            if (next == n) break;
            // init
            if (bucket != -1) res = Math.max(res, bucketsMin[next] - bucketsMax[bucket]);
            bucket = next;
        }

        return res;
    }
}
```

