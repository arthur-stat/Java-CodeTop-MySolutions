题目简述：

> 给定一个数组 `nums` ，将其划分为两个连续子数组 `left` 和 `right`， 使得：
>
> - `left` 中的每个元素都小于或等于 `right` 中的每个元素。
> - `left` 和 `right` 都是非空的。
> - `left` 的长度要尽可能小。
>
> *在完成这样的分组后返回 `left` 的 **长度*** 。
>
> 用例可以保证存在这样的划分方法。

题目链接：[915. 分割数组](https://leetcode.cn/problems/partition-array-into-disjoint-intervals/)

# 思路

说白了就是要找一个分割，使得分割左边的最大值要小于等于分割右边的最小值。

那我们先预处理得到一个前缀最大值数组数组与一个后缀最小值数组就好了，分别记为 `premax` 与 `sufmin`，然后从 `i = 0` 开始遍历 `i`，直到发现首个满足 `premax[i] <= sufmin[i+1]` 的 `i`，那么 `i + 1` 就是左半部分的长度，而且是尽可能小的使左半部分元素均小于等于右半部分元素的分割下左半部分的长度。

# 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int partitionDisjoint(int[] nums) {
        int n = nums.length;
        int[] premax = new int[n];
        int[] sufmin = new int[n];
        int maxVal = Integer.MIN_VALUE;
        int minVal = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            maxVal = Math.max(maxVal, nums[i]);
            premax[i] = maxVal;
            minVal = Math.min(minVal, nums[n - i - 1]);
            sufmin[n - i - 1] = minVal;
        }

        for (int i = 0; i < n - 1; i++) {
            if (premax[i] <= sufmin[i + 1]) return i + 1;
        }

        return -1;
    }
}
```