题目简述：

> 给你一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效。
>
> 返回所有可能的结果。答案可以按 **任意顺序** 返回。

题目链接：[301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

# BFS 最短路

我认为这是本问题最常规的解法，也是最容易想到并实现正确的方案。

不过就性能而言，BFS 远远不如另外两个方案，特别是在回溯算法充分剪枝时。

## 思路

将删除元素的个数作为 BFS 的层序，进行层序遍历，每层存储上一层各字符串删掉一个括号字符后的各字符串。这是很自然直观的想法。这也是 BFS 最短路的思路，我们这里用最短路的逻辑寻找最少删除的最长有效括号。

既然是 BFS，那么就需要队列这一数据结构。然而，某一层中可能有大量重复的字符串，我们不希望进行大量的重复求解（指数爆炸，无法接受），例如针对 `"(((((((()"` 要删除一个括号字符，显然除了 `')'` 外删除任何左括号得到的结果字符串都是相同的——因此我们需要进行去重。

Set 本身是无序的，我们不能直接把 HashSet 作为队列使用，否则层序可能会混乱；但我们可以在计算下一层字符串时先在 HashSet 中检查其是否已存在，只有不存在时才入队，同时在 HashSet 中记忆该字符串。

记得在进行到下一层前清空 HashSet，因为当进行到下一层时，上一层的字符串必然不存在于属于当前层的 HashSet 范围，节约内存。

## 代码

AC 时花费 51ms。

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        if (checkValid(s)) return List.of(s);

        List<String> res = new ArrayList<>();
        Set<String> cache = new HashSet<>();
        Set<String> resCache = new HashSet<>();
        Deque<String> q = new ArrayDeque<>();
        q.offer(s);
        int n = s.length();
        int thisLayerNum = 1;
        int nextLayerNum = 0;
        boolean found = false;

        while (!q.isEmpty()) {
            String ss = q.poll();
            thisLayerNum--;
            
            for (int i = 0; i < n; i++) {
                char c = ss.charAt(i);
                if (c != '(' && c != ')') continue;
                if (i > 0 && ss.charAt(i) == ss.charAt(i - 1)) continue;

                String ssDel = ss.substring(0, i) + ss.substring(i + 1);
                if (!cache.contains(ssDel)) {
                    if (checkValid(ssDel)) {
                        found = true;
                        // cache 只确保下一层元素不重复，resCache 用于构建解时确保当前层不重复
                        if (!resCache.contains(ssDel)) {
                            res.add(ssDel);
                            resCache.add(ssDel);
                        }
                    }
                    if (!found) {
                        q.offer(ssDel);
                        nextLayerNum++;
                        cache.add(ssDel);
                    }
                }
            }

            if (thisLayerNum == 0) {
                if (found) return res;
                thisLayerNum = nextLayerNum;
                nextLayerNum = 0;
                n--;
                cache.clear();
            }
        }

        return res;
    }

    private boolean checkValid(String s) {
        int i = 0;  // 尚未匹配的左括号数
        int n = s.length();
        for (int j = 0; j < n; j++) {
            if (s.charAt(j) == '(') {
                i++;
            } else if (s.charAt(j) == ')') {
                if (i > 0) {
                    i--;
                } else {
                    return false;
                }
            }
        }
        return i == 0;
    }
}
```

# 回溯算法（大量剪枝）

本问题的回溯算法剪枝堪称教科书级，否则必然超时，为了实现高效剪枝需要对 DFS 参数设计、回溯设计理解十分透彻。这部分内容本文将逐步推导。

## 思路

最暴力的全搜索回溯算法是必然会超时的，因此本问题可以应用回溯算法，但必须做大量的剪枝。

最重要的一个剪枝是约束 DFS 搜索的深度，实际上我们可以事先算出最少删除数，在一趟扫描时分别用两个变量表示尚未匹配的左括号数量与多余的右括号数量即可，例如

```java
private int getMinNumDel(String s) {
    int l = 0;  // 尚未匹配的左括号数量
    int r = 0;  // 需要被删除的多余右括号数量
    int n = s.length();

    for (int i = 0; i < n; i++) {
        char c = s.charAt(i);
        if (c == '(') {
            l++;
        } else if (c == ')') {
            if (l > 0) {
                l--;
            } else {
                r++;
            }
        }
    }

    return l + r;
}
```

`getMinNumDel` 方法将返回精确的最少删除数，于是我们在回溯算法的 DFS 过程中得以约束搜索的最大深度。其实只有最大深度依然无法高效剪枝，因为信息太少，我们应返回 `[l, r]` 数组，后文会提到原因。

在 BFS 中，我们对字符串逐渐删掉一个字符，并按已删除字符个数作为层序。对于回溯算法不建议沿用这样的逻辑，一方面这样实现的回溯算法更像是 IDDFS 而非是标准、基于 DFS 的回溯算法，另一方面，也是更重要的，这样效率不太高，因为要从字符串中删除一个字符就不可避免地需要新建字符串对象，即使是字符串对象可变的语言，也只能在修改而非删除字符时做到极低的开销。

更推荐的回溯算法实现是对每个元素考虑 “选” 与 “不选”，并在 “不选” 时更新深度，即已删除字符数量，这样可以直接用 `StringBuilder` 动态地构造 path，无需大量重复新建字符串对象。

DFS 的参数设计也值得花时间仔细研究，事实上只有扫描索引 `i` 和当前深度 `depth` 是不足以高效剪枝的，仍会带来大量重复计算。更好的做法是设计参数 `(i, open, l, r)`，其中 `open` 表示当前路径里未闭合的左括号数量，用于子串合法性判断——如果在构建过程中就已经必然非法，当然就可以提前回溯而不必要继续构建了；`l` 与 `r` 则分别表示已删除（或剩余待删除）的左括号数量和已删除（或剩余待删除）的右括号数量。这里便能解释为什么前文提到其实只返回最大深度是不够的，因为我们只有深度的话完全无法实现提前回溯，信息太少，同样的 `(i, depth)` 却有可能对应多个 path 状态，无法充分剪枝。

事实上，可以证明现在我们设计的 DFS 参数 `(i, open, l, r)` 已经能够唯一确定搜索的状态了，换句话说，四元组 `(i, open, l, r)` 能唯一确定子问题，这也是 `(i, depth)` 参数设计所做不到的。要充分剪枝，必要条件就是参数应足以刻画子问题，`(i, depth)` 做不到这一点，而 `(i, open, l, r)` 能直接唯一确定子问题。

## 基本剪枝的实现（逐字符）

AC 时花了 148ms。

```java
class Solution {

    private int n;
    private int l_r[];
    private String s;
    private StringBuilder path;
    private Set<String> res;
    private List<String> t = new ArrayList<>();

    public List<String> removeInvalidParentheses(String s) {
        n = s.length();
        l_r = getMinNumDel(s);
        path = new StringBuilder();
        res = new HashSet<>();
        this.s = s;
        dfs(0, 0, 0, 0);
        return new ArrayList<>(res);
    }

    /**
     * open: 当前路径中尚未闭合的左括号数量
     * l: 已删除左括号数量
     * r: 已删除右括号数量
     */
    private void dfs(int i, int open, int l, int r) {
        if (i == n) {
            if (open == 0 && l == l_r[0] && r == l_r[1]) res.add(path.toString());
            return;
        }
        char c = s.charAt(i);
        if (c != '(' && c != ')') {
            path.append(c);
            dfs(i + 1, open, l, r);
            path.setLength(path.length() - 1);
            return;
        }


        if (c == '(') {
            // 删除
            if(l < l_r[0]) dfs(i + 1, open, l + 1, r);
            // 保留
            path.append('(');
            dfs(i + 1, open + 1, l, r);
            path.setLength(path.length() - 1);
        } else {
            // 删除
            if (r < l_r[1]) dfs(i + 1, open, l, r + 1);
            // 保留
            if (open > 0) {
                path.append(')');
                dfs(i + 1, open - 1, l, r);
                path.setLength(path.length() - 1);
            }
        }
    }

    private int[] getMinNumDel(String s) {
        int l = 0;  // 尚未匹配的左括号数量
        int r = 0;  // 需要被删除的多余右括号数量

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == '(') {
                l++;
            } else if (c == ')') {
                if (l > 0) {
                    l--;
                } else {
                    r++;
                }
            }
        }

        return new int[]{l, r};
    }
}
```

## 进一步剪枝的实现（逐字符块）

AC 时只花了 2ms。

```java
class Solution {

    private int n;
    private int l_r[];
    private String s;
    private StringBuilder path;
    private Set<String> res;
    private List<String> t = new ArrayList<>();

    public List<String> removeInvalidParentheses(String s) {
        n = s.length();
        l_r = getMinNumDel(s);
        path = new StringBuilder();
        res = new HashSet<>();
        this.s = s;
        dfs(0, 0, 0, 0);
        return new ArrayList<>(res);
    }

    /**
     * open: 当前路径中尚未闭合的左括号数量
     * l: 已删除左括号数量
     * r: 已删除右括号数量
     */
    private void dfs(int i, int open, int l, int r) {
        if (i == n) {
            if (open == 0 && l == l_r[0] && r == l_r[1]) res.add(path.toString());
            return;
        }
        char c = s.charAt(i);
        if (c != '(' && c != ')') {
            path.append(c);
            dfs(i + 1, open, l, r);
            path.setLength(path.length() - 1);
            return;
        }

        int count = 1;  // 连续相同字符计数
        while (i < n - 1 && s.charAt(i + 1) == c) {
            count++;
            i++;
        }

        if (c == '(') {
            for (int j = 0; j <= count; j++) {
                if (l + count - j <= l_r[0]) {
                    path.append("(".repeat(j));
                    dfs(i + 1, open + j, l + count - j, r);
                    path.setLength(path.length() - j);
                }
            }
        } else {
            for (int j = 0; j <= count; j++) {
                if (r + count - j <= l_r[1] && open - j >= 0) {
                    path.append(")".repeat(j));
                    dfs(i + 1, open - j, l, r + count - j);
                    path.setLength(path.length() - j);
                }
            }
        }
    }

    private int[] getMinNumDel(String s) {
        int l = 0;  // 尚未匹配的左括号数量
        int r = 0;  // 需要被删除的多余右括号数量

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == '(') {
                l++;
            } else if (c == ')') {
                if (l > 0) {
                    l--;
                } else {
                    r++;
                }
            }
        }

        return new int[]{l, r};
    }
}
```

# 两次翻转的技巧性解法

## 思路

这个解法技巧性比较强，或许仅作了解？就算是追求极致的效率，充分剪枝的回溯算法也很强劲。

实现一个方法 `remove`，该方法能够删除掉多余的右括号。由于多余的右括号可能有多种删法，因此该方法应直接修改传入的引用字符串列表，或返回一个字符串列表。考虑右括号不同删除选择的可能性，可以通过递归实现。

应用一次 `remove` 方法，然后翻转字符串后再应用一次 `remove` 方法——这样就删掉了多余的左括号与右括号，最后再将字符串翻转回来得到的就是问题的解。

