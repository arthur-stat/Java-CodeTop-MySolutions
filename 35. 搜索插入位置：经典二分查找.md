题目简述：

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。

题目链接：[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

# 二分搜索原理引用

本问题就是二分查找算法最直接的应用，是非常标准且经典的二分查找问题。

这里直接引用我此前为问题 [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) 撰写的题解中所总结的二分查找算法的黄金模板：

> # 二分查找黄金模板
>
> - 循环条件：$\mathrm{left}\leqslant\mathrm{right}$
>
> - 指针更新条件：`if nums[mid] < target` 时，`left = mid + 1`；否则 `right = mid - 1`
>
>   注 1：`mid = left + (right - left) / 2`
>
>   注 2：也可以等价地将指针更新条件细化为若 `if nums[mid] < target`，则 `left = mid + 1`；若 `if nums[mid] > target`，则 `right = mid - 1`；否则 `if nums[mid] == target`，则直接返回 `mid`。这一指针更新条件更符合直接的逻辑，实际上没有本质区别。
>
> - 指针更新动作：都至少移动 $1$ 位！即 `left = mid + 1` 与 `right = mid - 1`
>
> 最终，当循环退出时，
>
> - ***保证 `left` 停留在首个大于等于 `target` 的位置，即顺序动态数组中 `target` 的插入位置***；
> - ***保证 `right` 停留在最后一个小于 `target` 的位置***。
>
> 按该模板实现二分查找的好处是终于不用在每次写二分查找时绞尽脑汁纠结到底是该让 `left` 至少移动一位还是让 `right` 至少移动一位以避免整数除法导致的死循环了——通通移动吧！
>
> 同时注意指针更新动作为 `left = mid + 1` 与 `right = mid - 1`，即都至少移动一位时，循环条件为 $\mathrm{left}\leqslant\mathrm{right}$；如果改为 $\mathrm{left}<\mathrm{right}$ 则 `left` 最终不会停留在首个不小于 `target` 的位置。
>
> ---
>
> 一个重要变种：
>
> - 将指针更新条件改为：`if nums[mid] <= target` 时，`left = mid + 1` 
>
> 最终，当循环退出时，
>
> - ***保证 `left` 停留在首个大于 `target` 的位置***；
> - ***保证 `right` 停留在最后一个小于等于 `target` 的位置***。
>
> ---
>
> 另一个特殊变种：
>
> 若需要计算旋转数组最小值的索引，则将 `if nums[mid] <= target` 改为 `if nums[mid] >= nums[0]` 即可。
>
> 这里引用我在 [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 题解中给出的原理：
>
> > 其实只要修改 “黄金模板” 中的 if-else 条件就可以直接变成旋转数组寻找最小值的模板：
> >
> > ```java
> > if (nums[0] <= nums[nums.length - 1]) {
> >   min = 0;
> > } else {
> >   while (left <= right) {
> >       int mid = left + (right - left) / 2;
> >       // mid 位于左半侧
> >       if (nums[mid] >= nums[0]) {
> >           left = mid + 1;
> >       } else {
> >           // mid 位于右半侧
> >           right = mid - 1;
> >       }
> >   }
> >   min = left;
> > }
> > ```
> >
> > 原因是这里的 `if (nums[mid] >= nums[0])` 条件在 “黄金模板” 中对应 `if nums[mid] < target`。之所以直接改这一处就能直接生效，是因为他们背后的语义都是一样的：判断条件表达了目标元素（`target` 或旋转数组最小值）是否严格在 `mid` 的右侧（相对地，`mid` 严格在目标元素左侧），从而指导区间收缩方向。
>
> # 从不变式角度系统分析二分查找
>
> “黄金模板” 只是给出了一个标准二分查找的可以直接使用的套路，节省脑力。对于更多的二分查找变种，就需要我们进行系统性的分析，寻找算法中的不变式（invariant）了。
>
> ---
>
> 我们先来看 “黄金模板” 中的不变式，大名鼎鼎的黑皮书《算法导论》中所介绍的二分查找算法实际上就是从不变式的角度系统分析出了我所总结的 “黄金模板”，二者等价，都是考虑闭区间查找的情况，考虑的同一种不变式。
>
> “黄金模板” 中 `left` 与 `right` 作为端点构成的区间的语义为 “搜索范围为 `left` 至 `right` 的闭区间，目标只可能存在于 `left` 至 `right` 的闭区间”，不变式蕴含于此：“在每一次循环开始时，`target` 只可能蕴含于 `left` 至 `right` 的闭区间”。
>
> 因此，在 “黄金模板” 中，循环的条件为 `while (left <= right)`，这是因为 `left == right` 时闭区间内尚存在一个元素，应当继续循环。这就是这一不变式对应的循环条件并非 `while (left < right)` 的原因。
>
> 同时，也是因为不变式的原因，当 `if nums[mid] < target` 时应更新 `left = mid + 1`，否则更新 `right = mid - 1`，而不是更新 `left = mid` 或 `right = mid`，这是因为搜索范围为闭区间，既然 `mid` 已经可以确认不满足条件，则下一轮的区间中可以排除 `mid`，这便是 “黄金模板” 中更新区间时直接令 `left = mid + 1` 或 `right = mid - 1` 的原因。
>
> 这种情况下，可以保证区间每次都是收缩的——至少收缩一个单位。
>
> ---
>
> 在同一不变式下，代码也可以有不一样的写法。比如，“黄金模板” 中循环的条件完全可以改为 `while (left < right)`，含义为搜索的闭区间内还剩一个元素时就停止，同时配套地将 `right = mid - 1` 改为 `right = mid`。
>
> 这里解释一下为什么配套的改动是必要的，当不满足 `if nums[mid] < target`，意味着存在 `if nums[mid] == target` 的可能性，此时直接令 `right = mid - 1` 就漏掉了解 `mid`。因此，如果愿意区分 `if nums[mid] < target`、`if nums[mid] > target` 以及 `if nums[mid] == target` 这三种情况，那么在 `if nums[mid] > target` 时更新 `right = mid - 1` 是正确的。若坚持二分——只判断是否有 `if nums[mid] < target`，则当不满足条件时便只能令 `right = mid`。
>
> > 为什么在 “黄金模板” 中的写法就不怕漏掉解 `mid`？
> >
> > 因为 “黄金模板” 不要求解必须留在搜索区间内作为候选，仅依赖于不变式本身。换言之，这种写法依赖的是边界不变式，而不是候选解。也就是说，它只保证「`< l` 的数一定小于 target，`> r` 的数一定大于等于 target」，最后通过 `l`、`r` 的边界位置来推出答案。既然答案由边界决定，就不需要在循环过程中把等于 target 的 `mid` 留下来，只要保证不变式成立，解就一定不会丢。
> >
> > 而这一写法的的语义是「搜索区间本身就是候选解所在的范围」。循环在只剩一个元素时停下，而不会再去检查这个元素，所以必须保证真正的解一直留在 `[l, r]` 中。正因为如此，更新的时候如果遇到可能是解的 `mid`，就不能用 `r = mid - 1` 把它排除，只能用 `r = mid` 保留它，直到最后区间收缩到唯一的候选点。
>
> 也就是说：取条件 `while (left <= right)` 还是 `while (left < right)`，根本区别在于我们**是要靠 “边界不变式” 来锁定解，还是靠 “候选区间收敛到单点” 来得到解**。

# 代码

算法的时间复杂度为 $O(\log n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0;
        int r = nums.length - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;

            if (nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        return l;
    }
}
```