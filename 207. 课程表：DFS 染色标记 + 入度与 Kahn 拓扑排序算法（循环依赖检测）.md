题目简述：

> 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。
>
> - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
>
> 请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

题目链接：[207. 课程表](https://leetcode.cn/problems/course-schedule/)

# 前言

> 推荐读完本题解后继续读一下我在 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 问题中编写的题解，那里的代码更成熟，而且理论更正确~

# 分析

如果课程 $A$ 是另一个课程 $B$ 的先修课程，那么我们称 $B$ 依赖于 $A$。在这一定义下，课程间的依赖关系构成有向图。显然，我们能否修完所有课程，等价于有向图是否为无环有向图（DAG）。

因此，本问题实际上就是一个纯粹的拓扑排序 / 循环依赖检验问题。

最简单的方案是从每个节点出发进行 DFS，如果遍历到已访问且未完成回溯的节点则认为存在环。这一方法比较直观，但是开销较大，是比较暴力的算法。我们可以减枝以大大降低开销。

实际上对于这类问题，推荐基于入度的 Kahn 拓扑排序算法，也称为基于 BFS 的拓扑排序算法。但是 DFS 算法也是可行的，因此这里分别给出这两种不同思路的实现。

# DFS

这里也给出 DFS 的方案，性能上而言 Kahn 算法可能更好（好得也有限，常数因子的差别）。DFS 环路检测的最大好处是可能不需要任何图论功底——如果只需要进行环检测。但应注意，DFS 也是可以进行拓扑排序的，而且在拓扑排序时也能进行环路检测。

本文对于 DFS 主要介绍染色标记这一不需要图论基础的实现，DFS 拓扑排序与拓扑排序时的环路检测请移步至我在 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 问题中编写的题解，那里对 DFS 分别实现了染色标记的环路检测与基于拓扑排序的环路检测。

其实我感觉 DFS 拓扑排序比染色标记还优雅些？

## 染色标记 DFS 循环检测思路

染色标记的 DFS 环路检测思路就是从每个节点出发，不断探索他的后继节点，看看我们是否最终会回到曾访问过的节点（染色标记）。不需要考虑一个节点的所有前驱节点，只需要考虑一个节点的后继节点——这就是上文中说 “不需要图论基础” 的方案。如果要考虑一个节点的所有前驱节点，那么就要考虑入度，这样子实际上就是使用 DFS 进行拓扑排序了。DFS 拓扑排序详见我为 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 问题编写的题解，此处不多介绍。

为降低时间复杂度，最好也使用邻接表——如果不熟悉这一概念，请先阅读后文〖基于 BFS 的拓扑排序算法〗。

此外，我们还需要一个数组 `visited` 用于染色标记，以便在一次 DFS 中检测是否进入了循环。

## O(N²) DFS 代码实现

这份算法能够得到正确结果，但是可能超时。时间复杂度最坏为 $O(N^2)$，即使只将入度为 $0$ 的课程作为 `startCourse`，因为没有剪纸优化。最好的方案是记忆化搜索。

```java
class Solution {

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int i = 0; i < numCourses; i++) adj.put(i, new ArrayList<Integer>());

        for (int[] pre : prerequisites) {
            adj.get(pre[1]).add(pre[0]);
        }

        boolean[] visited = new boolean[numCourses];
        
        for (int startCourse = 0; startCourse < numCourses; startCourse++) {
            if (dfs(startCourse, adj, visited)) return false;
        }

        return true;
    }

    private boolean dfs(int course, Map<Integer, List<Integer>> adj, boolean[] visited) {
        if (visited[course]) return true;
        visited[course] = true;

        for (int nextCourse : adj.get(course)) {
            if(dfs(nextCourse, adj, visited)) return true;
        }

        visited[course] = false;
        return false;
    }
}
```

## 改进的 O(V + E) 记忆化搜索实现

该算法时间复杂度为 $O(V+E)$，其中 $V$ 为课程数 `numCourses`（节点数）、$E$ 为依赖关系数 `prerequisites.length`（边数）。该时间复杂度实际上与 Kahn 算法是相同的。

为了降低时间开销，我们需要剪枝优化。简而言之，<u>如果 DFS 探索到某个节点，但该节点已经作为过某次 `dfs` 方法的输入被证明其作为子路径起点时不存在循环链路，那么就没必要继续探索</u>，因为这是重复的，可以直接返回确认结果。我们可以引入额外的 `dfsed` 数组缓存 DFS 的探索结果。

这样的 DFS 算法在时间复杂度与空间复杂度上与 Kahn 算法是一致的。

```java
class Solution {

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int i = 0; i < numCourses; i++) adj.put(i, new ArrayList<Integer>());

        for (int[] pre : prerequisites) {
            adj.get(pre[1]).add(pre[0]);
        }

        boolean[] visited = new boolean[numCourses];
        boolean[] dfsed = new boolean[numCourses];
        
        for (int startCourse = 0; startCourse < numCourses; startCourse++) {
            if (dfs(startCourse, adj, visited, dfsed)) return false;
        }

        return true;
    }

    private boolean dfs(int course, Map<Integer, List<Integer>> adj, boolean[] visited, boolean[] dfsed) {
        if (dfsed[course]) return false;

        if (visited[course]) return true;
        visited[course] = true;

        for (int nextCourse : adj.get(course)) {
            if(dfs(nextCourse, adj, visited, dfsed)) return true;
        }

        visited[course] = false;
        dfsed[course] = true;
        return false;
    }
}
```

# 基于 BFS 的拓扑排序算法

## 入度与 Kahn 拓扑排序

> 基于 BFS 的拓扑排序算法

入度（in-degree）：在一个有向图中，一个节点的入度是 “指向它的边的数量”。

如果一个节点的入度为 $0$，意味着该节点没有任何依赖，因此它可以作为拓扑排序下的起点。

Kahn 算法非常自然：首先统计所有节点的入度，将所有已知的入度为 $0$ 的节点加入队列。依次从队列中取出节点，并且在每取出一个节点时，移除未入队列节点对该节点的依赖——相对于移除该节点的边，然后更新剩余未入队列节点的入度，如果更新后存在新的入度为 $0$ 的节点，则将其也加入队列。不断重复操作，直到不剩下任何节点，或者剩余节点入度均不为 $0$。前者对应 DAG，后者对应存在环路。

Kahn 算法是一种拓扑排序算法，环路检测仅是其 “附赠品”。当然，DFS 也能给出拓扑序，详见我在 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 中编写的题解，在那里我们同时使用 DFS 与 BFS 给出了拓扑序（拓扑序即为节点从队列中取出的顺序）。

## 邻接表

要高效率地更新入度表，（正向）邻接表（adjacency list）是必不可少的。

邻接表是图的标准表示方法，在这里可以帮助我们以常量时间复杂度更新入度表，而不必每一次都重新构建新的入度表。邻接表可以用 `Map<Integer, List<Integer>>` 或 `List<List<Integer>>` 表示，邻接表直接存储了针对某一节点有哪些节点依赖该节点。

## Kahn 算法代码实现

对于该问题而言，判断 `numCourses` 是否等于可达节点数量即可。算法结束时，队列中的节点即为可达节点。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] inDegree = new int[numCourses];
        Map<Integer, List<Integer>> adj = new HashMap<>();

        // 构建邻接表和入度表
        for (int[] pre : prerequisites) {
            int course = pre[0], prereq = pre[1];
            inDegree[course]++;
            adj.computeIfAbsent(prereq, k -> new ArrayList<>()).add(course);
        }

        // 初始化队列，加入所有入度为 0 的课程
        Deque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) queue.offer(i);
        }

        int finishedCourses = 0;

        // 拓扑排序
        while (!queue.isEmpty()) {
            int course = queue.poll();
            finishedCourses++;

            List<Integer> nextCourses = adj.getOrDefault(course, Collections.emptyList());
            for (int next : nextCourses) {
                inDegree[next]--;
                if (inDegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }

        return finishedCourses == numCourses;
    }
}
```

