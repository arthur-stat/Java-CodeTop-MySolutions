题目简述：

> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>
> **进阶：**如果输入链表不能翻转该如何解决？

题目连接：[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

# 翻转链表

## 思路

翻转链表可以实现 $O(\max\{m,n\})$ 时间复杂度与 $O(1)$ 的空间复杂度，利用了加法算术从右到左计算的性质。

<u>但这里有一个细节就是我们不需要对结果链表也进行一次翻转，我们只要每次结果链表都插在头部而非尾部，那么最后得到的结果链表直接就是正序的。</u>

## 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode r1 = reverse(l1);
        ListNode r2 = reverse(l2);
        ListNode res = null;
        boolean carryOver = false;

        while (r1 != null && r2 != null) {
            int val = carryOver ? r1.val + r2.val + 1 : r1.val + r2.val;
            if (val > 9) {
                val = val % 10;
                carryOver = true;
            } else {
                carryOver = false;
            }
            res = new ListNode(val, res);
            r1 = r1.next;
            r2 = r2.next;
        }

        ListNode r3 = r2 == null ? r1 : r2;
        while (r3 != null) {
            int val = carryOver ? r3.val + 1 : r3.val;
            if (val > 9) {
                val = val % 10;
                carryOver = true;
            } else {
                carryOver = false;
            }
            res = new ListNode(val, res);
            r3 = r3.next;
        }

        if (carryOver) res = new ListNode(1, res);

        return res;
    }

    private ListNode reverse(ListNode head) {
        ListNode prev = new ListNode(0, head);
        ListNode node = head;

        while (node != null) {
            ListNode temp = node.next;
            node.next = prev;
            prev = node;
            node = temp;
        }

        head.next = null;
        return prev;
    }
}
```

# 如果一定不要翻转链表呢？

## 思路

如果不翻转链表，则应该无法做到 $O(1)$ 的空间开销，那么使用栈或者干脆使用数组以在逻辑上实现翻转即可——这样我们在事实上没有翻转原链表。

没有什么难度，就不单独给出实现了，只需要对上文中的代码做很少的改动。