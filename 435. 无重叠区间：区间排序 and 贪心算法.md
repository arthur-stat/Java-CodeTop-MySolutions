题目简述：

> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。
>
> **注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

题目链接：[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

# 思路

在 [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/) 的题解中我有总结过，这类问题套路都是区间排序后使用贪心算法。

如果读者不清楚，这里引用我在 [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/) 问题的题解中对区间贪心算法的归纳总结：

> - 区间调度
>
>   - 选出最多个互不重叠的区间
>   - 最少删多少个区间使之互不重叠（注：即当前问题 [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)）
>
>   按右端点排序，总是优先选右端点最小的区间。
>
> - 区间合并
>
>   - 将所有重叠的区间合并为并集，输出合并后的若干段
>
>   按左端点排序，维护当前合并段，如果不重叠则另开辟新段。
>
> - 区间刺点
>
>   - 例如本问题（注：这里的 “本问题” 指 [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)）
>
>   按右端点排序，总是优先选右端点最小的区间。

对于本问题，套路是先对各区间按右端点排序，然后对于当前区间，比较其左端点与上一个区间的右端点，

- 如果当前区间左端点大于等于上一个区间右端点，当然无事发生，无需删除区间；
- 否则删除两个区间中右端点值最大的那个区间，保留右端点值更小的那个区间。

逻辑上局部最优比较好理解，**因为对于两个重叠的区间，显然删除右端点更大的那个区间能够使剩余区间与其他区间重叠的风险最小**，但为什么每次都选择局部最优最终可以达到全局最优就没那么好理解了。

# 代码

算法的平均时间复杂度为 $O(n\log n)$，平均空间复杂度为 $O(\log n)$——这些开销均主要来自于快速排序算法。

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));
        int del = 0;
        int prevRight = Integer.MIN_VALUE;
        for (int[] interval : intervals) {
            int left = interval[0];
            if (left >= prevRight) {
                prevRight = interval[1];
            } else {
                prevRight = Math.min(prevRight, interval[1]);
                del++;
            }
        }
        return del;
    }
}
```

