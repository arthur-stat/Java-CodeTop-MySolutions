题目简述：

> 你选择掷出 `num` 个色子，请返回所有点数总和的概率。
>
> 你需要用一个浮点数数组返回答案，其中第 `i` 个元素代表这 `num` 个骰子所能掷出的点数集合中第 `i` 小的那个的概率。
>
> **提示：**
>
> - `1 <= num <= 11`

题目链接：[LCR 185. 统计结果概率](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

# 思路

众所周知，在概率论中，两个互相独立的离散随机变量 $X,Y$ 的和 $Z=X+Y$ 的卷积公式定义为
$$
P(Z=z)=P(X+Y=z)=\sum_{x+y=z}P(X=x)P(Y=y)
$$
记 $X$ 的分布为 $P_x$、$Y$ 的分布为 $P_y$，可以用记号 $\ast$ 表示卷积，则 $Z=X+Y$ 的分布为 $P(Z=z)=(P_x\ast P_y)(z)$。

拓展到多个变量，对于互相独立的离散变量 $X_1,X_2,\cdots,X_n$，对于 $Y=\sum X_i$，其概率分布为
$$
P(Y=y)=(P_1\ast P_2\ast\cdots\ast P_n)(y)
$$
离散卷积与连续卷积均满足交换律、结合律以及分配律，所以同快速幂一样，我们可以用分治算法加速多变量卷积的计算。

对于本问题，当只有一个骰子时，其概率分布是显而易见的：$P(X=x)=\frac16$，其中 $x\in\{1,2,\cdots,6\}$，因此直接按上述公式进行计算即可，考虑分治算法加速计算。

# 代码

算法的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。

如果考虑快速傅里叶变换 FFT，可以将时间复杂度进一步降至 $O(n\log n)$。

```java
class Solution {

    private Map<Integer, Double>[] cache;

    public double[] statisticsProbability(int num) {
        cache = (Map<Integer, Double>[]) new Map[num + 1];
        cache[1] = new HashMap<>();
        for (int i = 1; i <= 6; i++) cache[1].put(i, 1.0 / 6);
        Map<Integer, Double> p = conv(num);
        System.out.println(p);
        return p.entrySet().stream()
                .sorted(Map.Entry.comparingByKey())
                .mapToDouble(Map.Entry::getValue)
                .toArray();
    }

    private Map<Integer, Double> conv(int num) {
        if (cache[num] != null) return cache[num];

        Map<Integer, Double> p1 = conv(num / 2);
        Map<Integer, Double> p2 = conv((int) Math.ceil(num / 2.0));

        Map<Integer, Double> p = new HashMap<>();
        for (int z = num; z <= 6 * num; z++) {
            for (int x = num / 2; x <= 6 * (num / 2); x++) {
                int y = z - x;
                if (!p2.containsKey(y)) continue;

                p.merge(z, p1.get(x) * p2.get(y), Double::sum);
            }
        }

        cache[num] = p;
        return p;
    }
}
```

