题目简述：

> 给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。
>
> `k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
>
> **进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

题目链接：[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

# 递归

## 递归思路

对于链表 $[1,2,3,4]$，我们可以怎样一步步将其翻转为 $[4,3,2,1]$ 呢？

1. $[1,2,3,4]\to[4,1,2,3]$，只调整一个节点
2. $[4,1,2,3]\to[4,3,1,2]$，只调整一个节点
3. $[4,3,1,2]\to[4,3,2,1]$，只调整一个节点

可见，我们只需要实现方法 `reverseKGroupLast`，该方法每次将最后一个节点移动至 “头部” 的右侧——这里 “头部” 并非是 `head`、也不是链表第 $k'$ 段的首个节点，而是链表第 $k'$ 段中的一个动态递增的节点。

1. 第一次 `reverseKGroupLast`，$[1,2,3,4]\to[4,1,2,3]$，“头部” 为 $1$ 的前驱节点

2. 第二次 `reverseKGroupLast`，$[4,1,2,3]\to[4,3,1,2]$，“头部” 为 $4$

3. 第三次 `reverseKGroupLast`，$[4,3,1,2]\to[4,3,2,1]$，“头部” 为 $3$

4. 当 “头部” 的右侧节点为链表第 $k'$ 段的末尾节点——该节点恰为翻转前的首个节点，则终止算法。

   如果考虑递归实现，我们可以设计让 `reverseKGroupLast` 返回 “头部” 节点，方便递归调用。

最后，我们对每 $k$ 个节点应用一轮 `reverseKGroupLast` 方法即可。

## 递归实现

为了语义清晰，我们为前文分析中的 “头部” 节点命名为 `prev`。

算法实现的难点是细节比较多，这也是链表相关问题的特点。

递归实现的时间复杂度为 $O(Nk)$，空间复杂度为 $O(k)$，其中空间复杂度由递归栈主导。实际上这是一个尾递归，如果是支持尾递归优化的语言及编译器，那么空间复杂度为 $O(1)$。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {

    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode prev = new ListNode(0, head);
        ListNode cur = head;
        ListNode newHead = head;
        for (int j = 0; j < k - 1; j++) {
            if (newHead == null) return head;
            newHead = newHead.next;
        }

        int i = 1;
        while (cur != null) {
            cur = cur.next;
            i++;

            if (i == k) {
                ListNode headK = prev.next;
                if (cur == null) break;
                reverseKGroupLast(prev, headK, cur.next);
                prev = headK;
                cur = prev.next;
                i = 1;
            }
        }

        return newHead;
    }

    /**
     * prev: 即分析中链表当前段的 “头部” 节点
     * headK: 开始翻转以前的首位节点，用于递归终止条件的判断
     * nextK: 链表当前段的后继节点，可能为 null
     */
    private void reverseKGroupLast(ListNode prev, ListNode headK, ListNode nextK) {
        if (prev.next.next == nextK) return;
        
        // last2ndK: 链表当前段的当前翻转状态的倒数第二个节点
        ListNode last2ndK = prev;
        while (last2ndK.next.next != nextK) last2ndK = last2ndK.next;

        ListNode temp = prev.next;
        prev.next = last2ndK.next;
        prev.next.next = temp;
        last2ndK.next = nextK;
        reverseKGroupLast(prev.next, headK, nextK);
    }

}
```

# 迭代（最优解）

## 迭代思路

如果不限制空间复杂度，可以轻易地设计 $O(k)$ 空间复杂度的迭代算法：每次将 $k$ 个元素装入一个数组中，然后每次调换两端未翻转的节点。

1. $[1(l),2,3,4(r)]\to[4(r),2,3,1(l)]$
2. $[4,2(l),3(r),1]\to[4,3(r),2(l),1]$

但在 $O(1)$ 空间开销的前提下，就不能借用数组这样简单地操作了。先来讨论如何翻转整个链表，对于链表 $[1,2,3,4]$，需要将其翻转为 $[4,3,2,1]$。

任意挑选其中一个节点进行研究，以 $2$ 为例，原本其前驱节点为 $1$、后继节点为 $3$，翻转后其前驱节点为 $3$、后继节点为 $1$。这意味着，在循环中，我们只需要依次***让当前的节点的 `next` 指针指向自身的前驱节点***，就可以实现子链表的翻转。

## 迭代实现

算法的时间复杂度为 $O(N)$，空间复杂度为 $O(1)$。

```java
class Solution {

    public ListNode reverseKGroup(ListNode head, int k) {
        if (k == 1) return head;

        ListNode virtualHead = new ListNode(0, head);
        ListNode left = virtualHead;
        int i = 1;

        while (head != null) {

            if (i == k) {
                ListNode newLeft = left.next;
                reverseSublist(left, head.next);
                left = newLeft;
                head = left.next;
                i = 1;
            } else {
                head = head.next;
                i++;
            }
        }

        return virtualHead.next;
    }
    
    /**
     * left: 子链表的上一个节点
     * right: 子链表的下一个节点
     */
    private void reverseSublist(ListNode left, ListNode right) {
        ListNode newLast = left.next;
        ListNode cur = left.next;
        ListNode next = cur.next;
        ListNode nextNext = next.next;

        while (nextNext != right) {
            next.next = cur;
            cur = next;
            next = nextNext;
            nextNext = nextNext.next;
        }

        next.next = cur;
        left.next = next;
        newLast.next = right;
    }
}
```

