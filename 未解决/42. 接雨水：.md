题目简述：

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

题目链接：[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

# 前言

这个问题可以用很多方法解决，比如BFS、DFS，但这里只记录动态规划与单调栈的方法。

# 方法一、动态规划

这个问题可以通过简单地逐行扫描或逐列扫描解决，但时间复杂度在 $O(n^2)$。动态规划可以将时间复杂度控制在 $O(n)$。

首先公式化地设 $dp[i]$ 为前 $i+1$ 个柱子能够接到的雨水量，设第 $k+1$ 个柱子是前 $i$ 个柱子中的最高者，如果有多个最高柱子则取最右侧的柱子，即
$$
\left\{\begin{align}
&k<i\\\\
&\forall j\in[0,i)\text{ and }j\neq k,\ \ \text{height}[j]\leqslant\text{height}[i]\\\\
&\forall j\in(k,i),\ \ \text{height}[j]<\text{height}[k]
\end{align}\right.
$$
那么有
$$
dp[i]=dp[i-1]+\underbrace{(i-k-1)}_{\text{area width}}\times\underbrace{\Big(\min\big\{\text{height}[i],\text{height}[k]\big\}-\max\big\{\text{height}[j]:k<j<i\big\}\Big)}_{\text{area height}}
$$
该公式的原理如图所示，其中红色区域即为 $(i-k-1)\times\Big(\min\big\{\text{height}[i],\text{height}[k]\big\}-\max\big\{\text{height}[j]:k<j<i\big\}\Big)$

![动态规划示意图](/images/42.png)

本质上这其实还是一种逐列扫描，如果按照以上定义公式去一比一构建算法的逻辑则需要在遍历 $i$ 的主循环中嵌套一个内循环寻找 $k$，最终算法的时间复杂度在 $O(n^2)$。但注意到 $k$ 其实就是“当前已知的最高柱子”、红色区域实际上是“在当前已知的最高柱子右边的已知最高柱子”，如果我们在遍历的过程中使用两个变量保存并更新当前已知的最高柱子和他右边的已知最高柱子，那样就不需要再在遍历 $i$ 的主循环中嵌套一个内循环了，通过这种方式可以将时间复杂度降低至 $O(n)$。





# 方法二、利用单调栈

请区分单调栈和最大/最小堆。单调栈和单调队列是一家人，和最大/最小堆不是一家人。最大/最小堆底层是基于逻辑上的完全二叉树的（物理上可以基于真正的树，但由于完全二叉树的优秀性质，一般基于数组/动态数组），而单调栈和单调队列则并未修改栈和队列的底层数据结构，只不过为栈和队列加上一个单调的限制，以最小栈为例，在栈的基础上维护栈底最大、栈顶最小的性质。这么维护呢？在push时检查栈顶，如果被push的新元素不大于栈顶，则将新元素压入栈使之成为新的栈顶，如果被push的新元素大于栈顶，则丢弃原栈顶，让原栈顶出栈，再次检查将被压入栈的新元素和原栈顶出栈后的新栈顶之间的大小关系，如果被push的新元素更小则之直接压入，否则继续让新栈顶出栈，直到被push的新元素入栈——这样就保证了被压入的元素一定是全局最小的，当需要pop的时候，出栈者一定是全局最小元素。

这里再区分一下，以最小堆和最小栈、最小队列为例：

- 最小堆可以解决bottom-K问题，因为他在初始化建堆维护逻辑完全二叉树时不会丢失原有数据的任何值，当我们一次次把根元素移出堆时，能够保证从堆中取出的元素不仅是堆中的当前最小值，而且可以取出n次，如果将取出的元素依取出顺序排列，就得到了原数据排序后的结果，因此最小堆可以用来排序，这种排序方法称为堆排序。

  这里补充一下，堆排序是稳定的，堆的构建和调整过程不受数据初始顺序影响，因此无论输入数据如何分布堆排序始终保持稳定的 $O(n\log n)$ 时间复杂度，而且基于数组的实现方案空间复杂度是 $O(1)$，相比之下快速排序的空间复杂度是 $O(n)$。但实际上正因为堆排序的时间复杂度很稳定——构建堆时一定要经过那么多次步骤，因此不考虑空间开销和稳定时间复杂度需求（如实时系统）时，更常见快速排序。毕竟，快速排序通过三向切分，对于重复元素很多的数据能够很快结束排序，虽然他和堆排序平均时间复杂度相同，但在大多数情况下性能都优于堆排序，时间开销更小，只要数据被精心布置或者按某种规则分布时，快速排序才会退化到 $O(n^2)$ 而劣于堆排序。

- 但是最小栈和最小队列就不可用用来排序了。在入栈或入队的过程中，为了保证进入的元素是全局最小的，可能会弹出栈或队列若干个元素，这导致构建最小栈或最小队列时会丢失原有的数据和信息。因此，最小栈和最小队列适合用来解决 ***存在顺序的要求，但是被挤出去的元素对后续计算不产生任何影响*** 的问题，但不适合用来排序。

  在Java中，栈、单端队列、双端队列、单调栈、单调队列都可以统一通过 `Deque` 实现。

---

说完了单调栈、单调队列是什么以及他们与最大堆、最小堆的异同，我们再来看看如何用单调栈解决这个问题。

什么时候能够接更多的雨水呢？假设我们遍历右端点，那么当右端点固定时，当然是取其左侧第一个大于右端点的点，这个点作为左端点时能接的雨水就是最多的。这里就完美符合最小堆的结构：<u>我们要找到每个右端点的左侧第一个大于等于他的左端点，而且对每个右端点，我们也只在意他左侧第一个大于等于他的左端点</u>。推荐观看视频[单调栈？单调队列？单调双端队列！](https://www.bilibili.com/video/BV1oNAfesENj)的算法可视化加以理解。

---



