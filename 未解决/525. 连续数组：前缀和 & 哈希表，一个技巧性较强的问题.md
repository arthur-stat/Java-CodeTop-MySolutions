题目简述：

> 给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

题目链接：[525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

# 思路

从问题描述来看，该问题可能可以用动态规划解决。例如，可以设 $dp[i][j]$ 表示 `nums[i]`  至 `nums[j]` 的子数组范围内 `1` 多于 `0` 的数量，该数量允许为负数，那么状态转移是非常好寻找的，而且最终的解即为 $dp$ 值为 $0$ 的最长子数组的长度。

然而这会导致 $O(n^2)$ 的时间复杂度——注意到题目所给出的数据范围是 `1 <= nums.length <= 10^5`，这暗示我们很大概率需要设计一个 $O(n)$ 时间复杂度的算法。

---

实际上这是一个比较有技巧性的题目，利用前缀和与哈希表实现 $O(n)$ 时间复杂度的算法。和此前的 “摩尔投票” 算法有相似之处。

为了算法通用性，我们不关注数字的实际字面量，即我们仅视 `0` 和 `1` 为不同的两种元素，不关心其具体的值——这是一个很重要的视角，稍后我们将对这两种元素计数，而不在关心其具体的值为多少。

现在我们对 `nums` 进行一次遍历，并且使用一个计数器 `counter` 计数，当扫描到 `1` 时计数器加一、扫描到 `0` 时计数器减一，并且

- 在计数器每次更新后检查哈希表中计数器的值作为 key 是否存在，若不存在则映射该值作为 key 至 当前遍历元素的索引；
- 再