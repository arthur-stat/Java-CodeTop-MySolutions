题目简述：

> 给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。
>
> - `'.'` 匹配任意单个字符
> - `'*'` 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。
>
> **提示：**
>
> - `s` 只包含从 `a-z` 的小写字母。
> - `p` 只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。
> - 保证每次出现字符 `*` 时，前面都匹配到有效的字符

题目连接：[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

# 思路

脑残题目。

## 正则表达式匹配

正则表达式匹配（regular expression matching）是指输入包含一个长为$n$的字符串$s$与一个长为$m$的字符规律$p$，需要实现一个支持`'.'`与`'*'`的正则表达式匹配。为简化实现，`'.'`与`'*'`仅可能在$p$中出现。提示，`'.'`与`'*'`的匹配规则为：

- `'.'`可以匹配任何单个字符
- 对于任意元素`'?'`，`'?*'`可以匹配零个或多个`'?'`（`'*'`不会单独出现在$p$的首位，必须搭配前继元素以发挥作用）

如果$p$能够完全匹配整个$s$则返回`true`，否则返回`false`。注意，这里的`'*'`实际上可以对其前一位元素不予考虑，而上一个问题中的`'*'`至多只能对本处的`'*'`不予考虑，这是二者的根本差别。例如，当`s = 'abc'`、`p = 'c*abc'`时，在本问题中应当返回`true`，因为`'c*abc'`可以被视为`'abc'`；而在上一个问题中则应返回`false`，因为`'c*abc'`至多应被视为`'cabc'`，首位永远为`'c'`。

正则表达式匹配最好最标准的实现还是通过生成编译原理中的有限状态机，可以参考[正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/solutions/6881/yi-bu-dao-wei-zhi-jie-an-zheng-ze-biao-da-shi-de-s/)；由动态规划的实现，也有一篇写得很好的文章[『 动态规划 』字符串 DP 详解：状态转移推导 + 滚动优化 + 提前结束](https://leetcode.cn/problems/regular-expression-matching/solutions/1444108/by-flix-musv/)，可以补充阅读，提供了与本文不一样的视角。

该问题与上一个问题类似，$DP$表也应是二维的，定义$DP[i][j]$为$p$的前$i$个元素能否涵盖$s$的前$j$个字符，接下来寻找状态转移方程。

- 若$p_i$为文本字符，则$DP[i][j]=DP[i-1][j-1]\land\big(p_i==s_j\big)$

- 若$p_i$为`'.'`，则将$DP[i-1]$右移一位作为$DP[i]$

- 若$p_i$为`'*'`，则需要讨论$p_{i-1}$

  - 若$p_{i-1}$为`'*'`，则视`'**'`为`'*'`，$DP[i]=DP[i-1]$

  - 若$p_{i-1}$为`'.'`，则视`'.*'`为任意长字符串（但长度不能为零），所以$DP[i][j]=DP$

  - 若$p_{i-1}$为文本字符`'x'`，则视`'x*'`为`'x'`重复任意次的字符串，因此令

    - 当`'x*'`匹配`''`，相当于对子字符规律的最后$2$个元素不予考虑，取$\big\{j':DP[i][j'-1]=\text{true}\big\}$，则$DP[i][j']=DP[i-2][j']$，蕴含有$p_{i-1}=s_{j'}$

    - 当`'x*'`匹配`'x'`，$DP[i][j'+1]=DP[i-2][j'+1]$

    - 当`'x*'`匹配`'xx'`，$DP[i][j'+2]=DP[i-2][j'+2]$

    - … …

    - 当`'*'`匹配$k$个`'x'`，$DP[i][j'+k]=DP[i-2][j'+k]$

      其中$k$满足$\forall j',\ \ j'+k'\notin\big\{j':DP[i][j'-1]=\text{true}\big\},\ \,k'\leqslant k$，也就是说当$j$遍历到下一个$j'$时，$k$置$0$，重新开始这一匹配流程

    总结下来，当$p_i$为`'*'`且$p_{i-1}$为`'x'`时状态转移可简化为$DP[i][j]=\left\{\begin{aligned}&DP[i-2][j]\,\lor\,DP[i][j-1],&&p_{j-1}=s_j\\\\&DP[i-2][j],&&p_{j-1}\neq s_j\end{aligned}\right.$

这个问题用动态规划处理的难点在寻找`'x*'`时的状态转移。但只要我们逐步分析，问题也能够迎刃而解。

需要注意由于本问题的算法中涉及到$DP[i][j]=DP[i-2][j]\cdots$的状态转移，所以初始化时不能“简单粗暴”地令第一行与第一列除$DP[0][0]$外均为`false`，而应当考虑`p`中的`'*'`：按行数从小到大遍历，当$p_i$为`'*'`时令$DP[i][0]=DP[i-2][0]$，否则置`false`。

# 代码

