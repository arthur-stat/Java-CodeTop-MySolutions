题目简述：

> 给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。
>
> 按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：
>
> 1. `"123"`
> 2. `"132"`
> 3. `"213"`
> 4. `"231"`
> 5. `"312"`
> 6. `"321"`
>
> 给定 `n` 和 `k`，返回第 `k` 个排列。

题目链接：[60. 排列序列](https://leetcode.cn/problems/permutation-sequence/)

# 笨办法

## 思路

回溯算法找出全部排列，然后返回第 `k` 个排列。

显然针对本问题这是效率很差的办法，但你就说 `n` 不算很大时能不能用吧。

## 代码

`n <= 9` 的数据范围下 AC 时花费了 1081ms，效率低下。

```java
class Solution {

    private boolean[] used;
    private String[] permutations;
    private char[] path;
    private int count;
    private int n;

    public String getPermutation(int n, int k) {
        used = new boolean[n + 1];
        permutations = new String[factorial(n)];
        path = new char[n];
        count = 0;
        this.n = n;
        dfs(0);
        Arrays.sort(permutations);
        return permutations[k - 1];
    }

    private void dfs(int i) {
        if (i == n) {
            permutations[count++] = new String(path);
        }

        for (int d = 1; d <= n; d++) {
            if (!used[d]) {
                used[d] = true;
                path[i] = (char) (d + '0');
                dfs(i + 1);
                used[d] = false;
            }
        }
    }

    private int factorial(int n) {
        int res = n;
        while (n > 1) {
            n--;
            res *= n;
        }
        return res;
    }
}
```

# Factorial Number System

## 思路

解决这个问题有一种专门的高效算法，注意到前 $n$ 个数一共有 $n!$ 种排列，于是可以用 $n!$ 进制分解 $k$。

具体的灵感源于：

1. 当确定前 $m$ 位数后，剩下 $n-m$ 个数一共有 $(n-m)!$ 种全排列；
2. 现在考虑如何确定第 $m+1$ 位，
   - 假设剩下的 $n-m$ 个数升序排列，那么这就是字典序最小的排列，这时可以确定该数字