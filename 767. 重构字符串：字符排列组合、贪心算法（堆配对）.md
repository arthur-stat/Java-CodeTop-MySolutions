题目简述：

> 给定一个字符串 `s` ，检查是否能重新排布其中的字母，使得两相邻的字符不同。
>
> 返回 *`s` 的任意可能的重新排列。若不可行，返回空字符串 `""`* 。

题目链接：[767. 重构字符串](https://leetcode.cn/problems/reorganize-string/)

# 我的方案

本方案完全由我自己想到并证明、编写。

## 引理

当且仅当字符串中频数最大的字符（之一）可以被互不相邻地重新排布时，所有的字符均可以互不相邻地重新排布。

### 必要性证明

必要性是显然的，如果存在字符不能被互不相邻地重新排布，无论该字符是否是频数最大的字符，那么整个字符串中的字符就必然不可能被全部互不相邻地重新排布。

### 充分性证明

我们将字符串中频数最多的字符 $c$ 与其他字符分开来看，我们用正则表达式表示该字符，则该字符必然是 `(c.+)?(c.+)*c?`，其中 `.` 特别规定不允许匹配 `c`。

如果字符串中频数最多的字符 $c$ 能够互不相邻地排布，就可以肯定所有的字符都可以互不相邻地排布，因为其他的字符频数不可能比 $c$ 的频数更多，设 $c$ 的频数为 $f$，$c$ 的互不相邻排布产生了 $f+1$ 个空位，因此能够保证任何剩余的字符都可以被互不相邻地排布。

## 应用

我们只需要找出最大频数的字符的频数，不妨记为 $f$，并将其他所有字符均视为同一种间隔（而不加以区分具体的字符）。

根据引理，问题等价于最大频数的字符能否被互不相邻地排列。最大频数的字符频数为 $f$，因此至少需要 $f-1$ 个其他字符才能保证最大频数的字符能够互不相邻地排列。

因此，能够如要求地重新排布，只取决于最大频数字符的频数 $f$ 与总字符频数（或其他字符总频数）的大小关系，当且仅当其他字符总频数大于等于 $f-1$ 时能够给出所要求的排列。

在确定能够进行无相邻重复字符的排列后，我们将重新排列字符串的可用位置分为奇数位与偶数位，按字符频数由高至低的顺序（把一种字符填完了才填下一种）先依次填入奇数位，然后再依次填入偶数位，易证这样就可以保证结果中不存在相邻的重复字符。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
record Pair(char ch, int freq) {}

class Solution {
    public String reorganizeString(String s) {
        int n = s.length();

        int[] freq = new int[26];
        for (char c : s.toCharArray()) {
            freq[c - 'a']++;
        }

        int maxFreq = 0;
        int totalFreq = 0;
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Integer.compare(b.freq(), a.freq()));
        for (int i = 0; i < 26; i++) {
            totalFreq += freq[i];
            pq.offer(new Pair((char) (i + 'a'), freq[i]));
            if (freq[i] > maxFreq) {
                maxFreq = freq[i];
            }
        }

        if (totalFreq - maxFreq < maxFreq - 1) return "";

        char[] res = new char[n];
        int i = 0;
        Pair p = pq.poll();
        char c = p.ch();
        int f = p.freq();
        while (true) {
            while (f == 0) {
                p = pq.poll();
                if (p == null) return new String(res);
                c = p.ch();
                f = p.freq();
            }

            if (i >= n) i = 1;

            res[i] = c;
            f--;
            i += 2;
        }
    }
}
```

# 贪心算法（堆配对）

## 思路

每次取出剩余字符中两个出现频率最高的不同字符放到结果末尾，减频再放回堆。

当堆中不存在元素时，算法终止。

该过程保证如果存在无相邻重复字符的排列，则得到的排列必然无相邻重复字符，但在构建字符串的过程中需要我们自行检测是否存在重复。

## 代码

算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public String reorganizeString(String s) {
        int n = s.length();

        int[] freq = new int[26];
        for (char c : s.toCharArray()) {
            freq[c - 'a']++;
        }

        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Integer.compare(b.freq, a.freq));
        for (int i = 0; i < 26; i++) {
            if (freq[i] > 0) pq.offer(new Pair((char) (i + 'a'), freq[i]));
        }

        char[] res = new char[n];
        int i = n - 1;
        while (i >= 0) {
            Pair p1 = pq.poll();
            Pair p2 = pq.poll();

            if (i < n - 1 && res[i + 1] == p1.ch) return "";

            res[i--] = p1.ch;
            p1.freq--;

            if (p2 != null) {
                res[i--] = p2.ch;
                p2.freq--;
            }

            if (p1.freq > 0) pq.offer(p1);
            if (p2 != null && p2.freq > 0) pq.offer(p2);
        }

        return new String(res);
    }

    private static class Pair {
        char ch;
        int freq;

        public Pair(char ch, int freq) {
            this.ch = ch;
            this.freq = freq;
        }
    }
}
```

