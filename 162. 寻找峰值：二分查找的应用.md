题目简述：

> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。
>
> 你可以假设 `nums[-1] = nums[n] = -∞` 。
>
> 你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。
>
> 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]` 。

题目链接：[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

# 思路

看到要求实现 $O(\log(N))$ 时间复杂度的算法，就应该想到考虑二分查找/分治算法。

这很简单。对于一个数组中的一个元素，

- 如果该元素比其右端的元素更小，则其右侧必然存在一个峰值元素；
- 如果该元素比其左端的元素更小，则其左侧必然存在一个峰值元素。

证明是很容易的，以该元素比其右端的元素更小为例，要么该元素右端元素连续单调递增，那么末位元素就是峰值元素，因为可以认为 `nums[n] = -∞`；否则，如果该元素右端元素不是连续单调递增的，那么必然有自该元素起单调递增直到某个位置不再递增，那么该位置上的元素就是峰值元素。

# 代码

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;

        int l = 0;
        int r = n - 1;

        while (true) {
            int mid = l + (r - l) / 2;
            if (isPeak(nums, mid)) return mid;

            if (mid > 0 && nums[mid - 1] > nums[mid]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
    }

    private boolean isPeak(int[] nums, int i) {
        int n = nums.length;
        return n == 1 || (i > 0 && i < n - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) ||
                (i == 0 && nums[0] > nums[1]) || (i == n - 1 && nums[n - 1] > nums[n - 2]);
    }
}
```

