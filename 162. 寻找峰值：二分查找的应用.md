题目简述：

> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。
>
> 你可以假设 `nums[-1] = nums[n] = -∞` 。
>
> 你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。
>
> 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]` 。

题目连接：[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

# 思路

看到要求实现 $O(\log(N))$ 时间复杂度的算法，就应该想到考虑二分查找/分治算法。

我们来分析下这个问题，因为可以认为数组两端为无穷小，因此峰值一定是存在的：就算是单调递增或单调递减的数组也存在峰值元素，分别为末位元素和首位元素；对于不单调的数组我们可以使用反证法轻松证明一定存在峰值元素。假设一个不单调的数组不存在峰值元素，即不存在极大值，那么就不存在局部单调递增后再单调递减的区域。由于数组不全局单调且相邻元素不相同，那么数组就只能在全局范围内先严格递减再递增，否则会出现极大值——这种情况下首位元素就是峰值。因此我们证明了，任何满足题目要求的数组都存在峰值元素。

证明峰值元素的存在性，接下来我们就要想办法设计一个分治算法找到该峰值元素了，这需要我们分析数组和峰值元素的性质。

对于一个数组我们首先找到其中点元素，对于中点以及中点左右的元素，由于题目保证相邻的元素不相等，因此如果我们用1、2、3表示这三个元素的相对大小，那么三者只可能存在以下情况：

- 123：中点不是峰值元素，但根据中点至中点右侧局部单调递增可知中点右侧必然存在峰值元素。
- 132：返回中点即可。
- 213：中点不是峰值元素，同“123”，中点右侧必然存在峰值元素。
- 231：返回中点即可。
- 312：中点不是峰值元素，同“123”，中点右侧必然存在峰值元素。
- 321：中点不是峰值元素，但根据中点左侧至中点局部单调递减可知中点左侧必然存在峰值元素。
- 121：返回中点即可。
- 212：中点不是峰值元素，同“123”，中点右侧必然存在峰值元素。

看，我们轻松设计出了解决该问题的二分查找算法。

# 代码

```java
class Solution {
    private int[] nums;

    public int findPeakElement(int[] nums) {
        this.nums = nums;
        return search(0, nums.length - 1);
    }

    private int search(int left, int right) {
        if (left == right) return left;
        if (left + 1 == right) return nums[left] > nums[right] ? left : right;

        int mid = (left + right) >>> 1;
        int res = -1;

        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
            res =  mid;
        } else if (nums[mid] < nums[mid + 1]) {
            res =  search(mid + 1, right);
        } else {
            res =  search(left, mid - 1);
        }

        return res;
    }
}
```

