题目简述：

> 给你一个字符串化学式 `formula` ，返回 **每种原子的数量** 。
>
> 原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。
>
> 如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。
>
> - 例如，`"H2O"` 和 `"H2O2"` 是可行的，但 `"H1O2"` 这个表达是不可行的。
>
> 两个化学式连在一起可以构成新的化学式。
>
> - 例如 `"H2O2He3Mg4"` 也是化学式。
>
> 由括号括起的化学式并佐以数字（可选择性添加）也是化学式。
>
> - 例如 `"(H2O2)"` 和 `"(H2O2)3"` 是化学式。
>
> 返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。

题目链接：[726. 原子的数量](https://leetcode.cn/problems/number-of-atoms/)

# 递归

## 思路

像递归处理括号匹配那样，遇见左括号就进入递归调用，遇到右括号就返回递归调用。元素的计数考虑哈希表。

这一方案我认为是很好实现的，因为我们可以在设计算法和编写代码时将全部的专注力投入到模拟的部分中，而不必关心栈的括号匹配部分。递归栈为我们天然提供了更符合思维直观的 LIFO 数据结构。

对于模拟的部分，简单来讲：

- 遇见大写字母时就尝试尽可能寻找后续的小写字母以结算元素，结算元素后再尽可能寻找后续的数字以结算数字；
- 遇见左括号则进入递归调用，遇见右括号则考虑结束递归调用，但返回递归调用前应尽可能寻找后续的数字以结算倍数。

## 代码

```java
class Solution {

    private int i;
    private int n;
    private String formula;

    public String countOfAtoms(String formula) {
        i = 0;
        n = formula.length();
        this.formula = formula;
        Map<String, Integer> res = recursion​();

        StringBuilder sb = new StringBuilder();
        List<String> keys = new ArrayList<>(res.keySet());
        keys.sort(null);
        for (String key : keys) {
            sb.append(key);
            int num = res.get(key);
            if (num > 1) sb.append(num);
        }

        return sb.toString();
    }

    private Map<String, Integer> recursion() {
        Map<String, Integer> count = new HashMap<>();

        while (i < n) {
            char c = formula.charAt(i);

            if (Character.isUpperCase(c)) {
                String e = String.valueOf(c);
                i++;

                while (i < n && Character.isLowerCase(formula.charAt(i))) {
                    e += formula.charAt(i);
                    i++;
                }

                int num = 0;
                while (i < n && Character.isDigit(formula.charAt(i))) {
                    num = num * 10 + formula.charAt(i) - '0';
                    i++;
                }

                num = Math.max(num, 1);

                count.merge(e, num, Integer::sum);
            } else if (c == '(') {
                i++;
                plus(count, recursion());
            } else {
                int mult = 0;
                i++;

                while (i < n && Character.isDigit(formula.charAt(i))) {
                    mult = mult * 10 + formula.charAt(i) - '0';
                    i++;
                }

                mult = Math.max(mult, 1);
                multiple(count, mult);

                return count;
            }
        }

        return count;
    }

    private void plus(Map<String, Integer> a, Map<String, Integer> b) {
        b.forEach((key, value) -> a.merge(key, value, Integer::sum));
    }

    private void multiple(Map<String, Integer> a, int mult) {
        a.replaceAll((key, value) -> value * mult);
    }
}
```

# 迭代（括号匹配栈）

## 思路

既然已经实现了递归的版本，那么把代码改为使用显式栈即可修改为迭代版本。

## 代码

```java
class Solution {
    public String countOfAtoms(String formula) {
        int i = 0;
        int n = formula.length();
        Map<String, Integer> count = new HashMap<>();
        Deque<Map<String, Integer>> stack = new ArrayDeque<>();

        while (i < n) {
            char c = formula.charAt(i);

            if (Character.isUpperCase(c)) {
                String e = String.valueOf(c);
                i++;

                while (i < n && Character.isLowerCase(formula.charAt(i))) {
                    e += formula.charAt(i);
                    i++;
                }

                int num = 0;
                while (i < n && Character.isDigit(formula.charAt(i))) {
                    num = num * 10 + formula.charAt(i) - '0';
                    i++;
                }

                num = Math.max(num, 1);

                count.merge(e, num, Integer::sum);
            } else if (c == '(') {
                i++;
                stack.push(count);
                count = new HashMap<>();
            } else {
                int mult = 0;
                i++;

                while (i < n && Character.isDigit(formula.charAt(i))) {
                    mult = mult * 10 + formula.charAt(i) - '0';
                    i++;
                }

                mult = Math.max(mult, 1);
                multiple(count, mult);

                plus(count, stack.pop());
            }
        }

        StringBuilder sb = new StringBuilder();
        List<String> keys = new ArrayList<>(count.keySet());
        keys.sort(null);
        for (String key : keys) {
            sb.append(key);
            int num = count.get(key);
            if (num > 1) sb.append(num);
        }

        return sb.toString();
    }

    private void plus(Map<String, Integer> a, Map<String, Integer> b) {
        b.forEach((key, value) -> a.merge(key, value, Integer::sum));
    }

    private void multiple(Map<String, Integer> a, int mult) {
        a.replaceAll((key, value) -> value * mult);
    }
}
```

