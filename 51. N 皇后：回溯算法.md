题目简述：

> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
>
> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
>
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

题目链接：[51. N 皇后](https://leetcode.cn/problems/n-queens/)

# 思路

经典回溯算法。

回溯的条件可以归结为：

- 同一列上不能有两个皇后
- 同一行上不能有两个皇后
- 任何一个皇后的对角线上不能有另一个皇后

虽然是 hard 问题，但感觉写起来还挺轻松的？一次编译并 AC。

请结合代码理解。

# 代码

算法的时间复杂度近似 $O(n!)$，递归最大深度为 $O(n)$，因此不计输出路径时空间复杂度为 $O(n)$。

```java
class Solution {

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();
        List<String> path = new ArrayList<>();
        boolean[] col = new boolean[n];
        boolean[] diag = new boolean[1 + 2 * (n - 1)];
        boolean[] antiDiag = new boolean[1 + 2 * (n - 1)];
        dfs(res, path, 0, col, diag, antiDiag);
        return res;
    }

    private void dfs(List<List<String>> res, List<String> path, int row, boolean[] col, boolean[] diag, boolean[] antiDiag) {
        int depth = path.size();
        int n = col.length;

        if (depth == n) {
            res.add(new ArrayList<String>(path));
            return;
        }

        // case 1. 同一行上只能存在一个皇后
        for (int j = 0; j < n; j++) {
            // case 2. 同一列上只能存在一个皇后
            if (col[j]) continue;

            // case 3. 对角线上不允许存在其他皇后
            // case 3.1 主对角线上不允许存在皇后
            int diagInex = (n - row - 1) + j;
            if (diag[diagInex]) continue;

            // case 3.2 副对角线上不允许存在皇后
            int antiDiagIndex = row + j;
            if (antiDiag[antiDiagIndex]) continue;

            path.add(buildRowStr(j, n));
            col[j] = true;
            diag[diagInex] = true;
            antiDiag[antiDiagIndex] = true;
            dfs(res, path, row + 1, col, diag, antiDiag);
            col[j] = false;
            diag[diagInex] = false;
            antiDiag[antiDiagIndex] = false;
            path.removeLast();
        }
    }

    private String buildRowStr(int queenIndex, int n) {
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < queenIndex; i++) res.append('.');
        res.append('Q');
        for (int i = queenIndex + 1; i < n; i++) res.append('.');
        return res.toString();
    }
}
```

