题目简述：

> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
>
> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
>
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

题目链接：[51. N 皇后](https://leetcode.cn/problems/n-queens/)

# 思路

经典回溯算法。

回溯的条件可以归结为：

- 同一列上不能有两个皇后
- 同一行上不能有两个皇后
- 任何一个皇后的对角线上不能有另一个皇后

虽然是 hard 问题，但感觉写起来还挺轻松的？一次编译并 AC。

# 代码

递归最大深度为 $O(n)$，因此空间复杂度为 $O(n)$。时间复杂度近似 $O(n\times n!)$。

```java
class Solution {

    private int n;
    private List<List<String>> res;

    public List<List<String>> solveNQueens(int n) {
        this.n = n;
        res = new ArrayList<>();
        List<String> path = new ArrayList<>();
        boolean[] queensStatusForCol = new boolean[n];
        dfs(path, queensStatusForCol);
        return res;
    }

    private void dfs(List<String> path, boolean[] queensStatusForCol) {
        int depth = path.size();

        if (depth == n) {
            res.add(new ArrayList<String>(path));
            return;
        }

        // case 1. 同一行上只能存在一个皇后
        main_loop:
        for (int i = 0; i < n; i++) {
            // case 2. 同一列上只能存在一个皇后
            if (queensStatusForCol[i]) continue;

            // case 3. 对角线上不允许存在其他皇后
            // case 3.1 主对角线上不允许存在皇后
            for (int j = 1; depth - j >= 0 && i - j >= 0; j++) {
                if (path.get(depth - j).charAt(i - j) == 'Q') continue main_loop;
            }
            // case 3.2 副对角线上不允许存在皇后
            for (int j = 1; depth - j >= 0 && i + j < n; j++) {
                if (path.get(depth - j).charAt(i + j) == 'Q') continue main_loop;
            }

            path.add(buildRowStr(i, n));
            queensStatusForCol[i] = true;
            dfs(path, queensStatusForCol);
            queensStatusForCol[i] = false;
            path.removeLast();
        }
    }

    private String buildRowStr(int queenIndex, int n) {
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < queenIndex; i++) res.append('.');
        res.append('Q');
        for (int i = queenIndex + 1; i < n; i++) res.append('.');
        return res.toString();
    }
}
```

