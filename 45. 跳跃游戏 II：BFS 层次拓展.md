题目简述：

> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
> 每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
>
> - `0 <= j <= nums[i]` 
> - `i + j < n`
>
> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

题目链接：[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

# 思路

在 [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/) 的题解中我们提到，一层循环的贪心策略可以解决 [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)，但无法求解 [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)。要求解本问题，我们需要实现显式层次的 BFS 层次拓展，并结合贪心擦略——因为 BFS 的层级 `order` 正是当前范围内的最小跳跃次数。

BFS 层次拓展思路请参见我在 [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/) 的题解。或结合代码。

# 代码

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int left = 0;
        int right = 0;
        int order;

        for (order = 0; right < n - 1; order++) {
            int nextRight = right;
            for (int i = left; i <= right; i++) {
                nextRight = Math.max(nextRight, i + nums[i]);
            }
            left = right + 1;
            right = nextRight;
        }

        return order;
    }
}
```

